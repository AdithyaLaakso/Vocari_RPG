{
  "games": [
    {
      "name": {
        "native_language": "Breakfast Bridges",
        "target_language": "Puentes del desayuno"
      },
      "description": {
        "native_language": "Drag preposition bridges and deliver bread to the café while practicing giving/receiving.",
        "target_language": "Arrastra puentes de preposición y entrega pan al café mientras practicas dar/recibir."
      },
      "language_level": "A0+",
      "target_vocabulary": [
        {
          "native_language": "bread",
          "target_language": "pan"
        },
        {
          "native_language": "café (coffee shop)",
          "target_language": "café"
        },
        {
          "native_language": "breakfast",
          "target_language": "desayuno"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Prepositions of place/direction: a, en",
          "target_language": "Preposiciones de lugar/dirección: a, en"
        },
        {
          "native_language": "Giving/receiving: dar, recibir",
          "target_language": "Dar/recibir: dar, recibir"
        }
      ],
      "game_prompt": "Game: Bridge-builder puzzle using preposition tokens.\nMechanics:\n- The screen shows two islands: left island labeled with a house icon (player) and right island labeled with a cup icon (café). A small bread token (pan) starts on the left.\n- At the center gap, there are empty bridge slots (rectangular gaps). Below, draggable bridge tiles labeled with Spanish prepositions: 'a', 'en'. One distractor tile can appear later with 'de'.\n- Player must drag the correct preposition tile into the slot to form a path that matches the on-screen bilingual instruction, then drag the bread token across the bridge to the café.\n- After placement, if correct, the bridge flashes green and the bread can cross. If incorrect, it flashes red and returns to the tray.\nVisual design:\n- Background: soft morning colors (light yellow gradient). Islands: rounded green shapes. Bridge tiles: rectangles (120x40) with bold Spanish text centered. Bread token: small brown circle with 'pan' label. Café: brown rectangle with 'café' label.\nEducational content (use exactly these bilingual on-screen texts):\n- Instructions per round:\n  1) {\"native_language\":\"Give the bread to the café.\",\"target_language\":\"Da el pan al café.\"}\n  2) {\"native_language\":\"Breakfast is at the café.\",\"target_language\":\"El desayuno es en el café.\"}\n  3) {\"native_language\":\"Receive bread at the café.\",\"target_language\":\"Recibe pan en el café.\"}\n- Preposition tiles (Spanish labels only on tiles): 'a', 'en', 'de' (distractor in later rounds).\n- Vocabulary labels near objects:\n  - {\"native_language\":\"bread\",\"target_language\":\"pan\"}\n  - {\"native_language\":\"café\",\"target_language\":\"café\"}\n  - {\"native_language\":\"breakfast\",\"target_language\":\"desayuno\"}\n- UI text:\n  - {\"native_language\":\"Start\",\"target_language\":\"Iniciar\"}\n  - {\"native_language\":\"Correct!\",\"target_language\":\"¡Correcto!\"}\n  - {\"native_language\":\"Try again\",\"target_language\":\"Inténtalo de nuevo\"}\n  - {\"native_language\":\"Drag a preposition tile\",\"target_language\":\"Arrastra una preposición\"}\nWin/Lose:\n- 3 rounds. Win by completing all 3 in under 90 seconds or with ≤3 mistakes. Each mistake shakes the wrong tile. On win, display {\"native_language\":\"Breakfast delivered!\",\"target_language\":\"¡Desayuno entregado!\"}.\n- If timer runs out or 4 mistakes occur, lose and show {\"native_language\":\"Let's practice again.\",\"target_language\":\"Practiquemos otra vez.\"}\nAnimations:\n- Bridge glow (green/red), subtle bounce when placing tiles; bread token slides smoothly across the bridge.",
      "skill_points": 18,
      "lua_code": "local W, H\nlocal gameState = \"menu\"\nlocal rounds = {}\nlocal currentRound = 1\nlocal tiles = {}\nlocal slot = {x=0,y=0,w=140,h=48,filled=false,correct=false,glow=0,bounce=0}\nlocal bread = {x=0,y=0,r=16,drag=false,targetX=0,allow=false}\nlocal leftIsland = {x=0,y=0,w=0,h=0}\nlocal rightIsland = {x=0,y=0,w=0,h=0}\nlocal startButton = {x=0,y=0,w=220,h=60}\nlocal timerTotal = 90\nlocal timeLeft = timerTotal\nlocal mistakes = 0\nlocal message = \"\"\nlocal messageTimer = 0\nlocal endTimer = 0\nlocal time = 0\nlocal hudPulse = 0\nlocal colors = {}\nlocal sfx = {}\nlocal draggingTile = nil\nlocal dragOffsetX = 0\nlocal dragOffsetY = 0\n\nlocal function rgbf(r,g,b) return rgb(r,g,b) end\nlocal function clamp(v,a,b) if v<a then return a elseif v>b then return b else return v end end\nlocal function lerp(a,b,t) return a+(b-a)*t end\nlocal function pointInRect(px,py,rx,ry,rw,rh) return px>=rx and px<=rx+rw and py>=ry and py<=ry+rh end\nlocal function dist(ax,ay,bx,by) local dx=ax-bx local dy=ay-by return math.sqrt(dx*dx+dy*dy) end\n\nlocal function setupColors()\n  colors.bg1 = rgbf(255,239,185)\n  colors.bg2 = rgbf(255,214,165)\n  colors.island = rgbf(120,200,140)\n  colors.islandDark = rgbf(95,170,115)\n  colors.bridgeSlot = rgbf(220,220,220)\n  colors.bridgeGood = rgbf(120,230,170)\n  colors.bridgeBad = rgbf(255,120,120)\n  colors.tile = rgbf(255,245,230)\n  colors.tileText = rgbf(60,60,60)\n  colors.tray = rgbf(240,230,210)\n  colors.cafe = rgbf(150,100,70)\n  colors.house = rgbf(200,200,220)\n  colors.bread = rgbf(181,128,79)\n  colors.shadow = rgba(0,0,0,80)\n  colors.white = rgbf(255,255,255)\n  colors.black = rgbf(0,0,0)\n  colors.goodText = rgbf(10,150,80)\n  colors.badText = rgbf(200,40,40)\n  colors.ui = rgbf(60,60,60)\n  colors.gold = rgbf(255,200,60)\nend\n\nlocal function setupSfx()\n  createSound(\"place\", 660, 0.08, 0.4, \"square\")\n  createSound(\"ok\", 880, 0.10, 0.5, \"sine\")\n  createSound(\"ok2\", 1175, 0.10, 0.5, \"sine\")\n  createSound(\"wrong\", 200, 0.15, 0.5, \"sawtooth\")\n  createSound(\"tick\", 1200, 0.04, 0.3, \"triangle\")\n  createSound(\"win\", 740, 0.18, 0.5, \"sine\")\n  createSound(\"win2\", 988, 0.18, 0.5, \"sine\")\nend\n\nlocal function setupRounds()\n  rounds = {\n    {\n      native = \"Give the bread to the café.\",\n      target = \"Da el pan al café.\",\n      need = \"a\",\n      distractor = false\n    },\n    {\n      native = \"Breakfast is at the café.\",\n      target = \"El desayuno es en el café.\",\n      need = \"en\",\n      distractor = true\n    },\n    {\n      native = \"Receive bread at the café.\",\n      target = \"Recibe pan en el café.\",\n      need = \"en\",\n      distractor = true\n    }\n  }\nend\n\nlocal function layout()\n  W = getScreenWidth()\n  H = getScreenHeight()\n  local islandW = math.floor(W*0.22)\n  local islandH = math.floor(H*0.26)\n  local gap = math.floor(W*0.24)\n  leftIsland.w = islandW\n  leftIsland.h = islandH\n  leftIsland.x = math.floor(W*0.08)\n  leftIsland.y = math.floor(H*0.46 - islandH/2)\n  rightIsland.w = islandW\n  rightIsland.h = islandH\n  rightIsland.x = W - math.floor(W*0.08) - islandW\n  rightIsland.y = leftIsland.y\n  slot.w = 140\n  slot.h = 48\n  slot.x = math.floor(W/2 - slot.w/2)\n  slot.y = math.floor(leftIsland.y + leftIsland.h*0.62 - slot.h/2)\n  bread.r = math.floor(H*0.022)\n  bread.x = leftIsland.x + math.floor(leftIsland.w*0.70)\n  bread.y = slot.y + slot.h/2\n  bread.targetX = bread.x\n  startButton.w = math.floor(W*0.28)\n  startButton.h = 64\n  startButton.x = math.floor(W/2 - startButton.w/2)\n  startButton.y = math.floor(H*0.70)\nend\n\nlocal function resetTiles()\n  tiles = {}\n  local labels = {\"a\",\"en\"}\n  if rounds[currentRound].distractor then\n    table.insert(labels,\"de\")\n  end\n  local trayY = H - 90\n  local cx = W/2\n  local spacing = 140\n  local startX = cx - ( (#labels-1) * spacing * 0.5 )\n  for i,label in ipairs(labels) do\n    local t = {\n      label = label,\n      x = startX + (i-1)*spacing,\n      y = trayY,\n      w = 120,\n      h = 40,\n      baseX = startX + (i-1)*spacing,\n      baseY = trayY,\n      dragging = false,\n      locked = false,\n      shake = 0,\n      returnSpeed = 0,\n      scale = 1.0,\n      returnToBase = false\n    }\n    table.insert(tiles, t)\n  end\nend\n\nlocal function resetRound()\n  slot.filled = false\n  slot.correct = false\n  slot.glow = 0\n  slot.bounce = 0\n  bread.allow = false\n  bread.x = leftIsland.x + math.floor(leftIsland.w*0.70)\n  bread.targetX = bread.x\n  bread.y = slot.y + slot.h/2\n  bread.drag = false\n  resetTiles()\nend\n\nlocal function startGame()\n  currentRound = 1\n  mistakes = 0\n  timeLeft = timerTotal\n  message = \"Arrastra una preposición\\nDrag a preposition tile\"\n  messageTimer = 2.2\n  gameState = \"playing\"\n  resetRound()\nend\n\nlocal function completeRound()\n  playSound(\"ok2\")\n  currentRound = currentRound + 1\n  if currentRound > #rounds then\n    gameState = \"win\"\n    message = \"¡Desayuno entregado!\\nBreakfast delivered!\"\n    messageTimer = 2.5\n    endTimer = 2.5\n  else\n    message = \"¡Correcto!\"\n    messageTimer = 1.0\n    resetRound()\n  end\nend\n\nlocal function loseGame(reason)\n  gameState = \"lose\"\n  message = \"Practiquemos otra vez.\\nLet's practice again.\"\n  messageTimer = 2.8\n  endTimer = 2.8\nend\n\nfunction init()\n  setupColors()\n  setupRounds()\n  setupSfx()\n  layout()\nend\n\nlocal function updateDragging(dt)\n  local mx = getMouseX()\n  local my = getMouseY()\n  if isMouseJustPressed() then\n    if gameState == \"menu\" then\n      if pointInRect(mx,my,startButton.x,startButton.y,startButton.w,startButton.h) then\n        playSound(\"tick\")\n        startGame()\n      end\n      return\n    end\n    if gameState ~= \"playing\" then return end\n\n    draggingTile = nil\n    for i = #tiles,1,-1 do\n      local t = tiles[i]\n      if not t.locked and pointInRect(mx,my,t.x - t.w/2, t.y - t.h/2, t.w, t.h) then\n        t.dragging = true\n        draggingTile = t\n        dragOffsetX = mx - t.x\n        dragOffsetY = my - t.y\n        break\n      end\n    end\n    if draggingTile == nil and bread.allow then\n      if dist(mx,my,bread.x,bread.y) <= bread.r*1.4 then\n        bread.drag = true\n        dragOffsetX = mx - bread.x\n        dragOffsetY = my - bread.y\n      end\n    end\n  end\n\n  if isMouseDown() then\n    if draggingTile and draggingTile.dragging then\n      draggingTile.x = mx - dragOffsetX\n      draggingTile.y = my - dragOffsetY\n    end\n    if bread.drag and bread.allow then\n      local tx = mx - dragOffsetX\n      bread.targetX = clamp(tx, leftIsland.x + leftIsland.w*0.50, rightIsland.x + rightIsland.w*0.60)\n      bread.y = slot.y + slot.h/2 + math.sin(getTime()*8)*1.2\n    end\n  end\n\n  if isMouseJustReleased() then\n    if draggingTile and draggingTile.dragging then\n      local t = draggingTile\n      t.dragging = false\n      local overSlot = pointInRect(t.x - t.w/2, t.y - t.h/2, slot.x, slot.y, slot.w, slot.h) or pointInRect(t.x, t.y, slot.x, slot.y, slot.w, slot.h)\n      if overSlot and not slot.filled then\n        if t.label == rounds[currentRound].need then\n          slot.filled = true\n          slot.correct = true\n          t.locked = true\n          t.x = slot.x + slot.w/2\n          t.y = slot.y + slot.h/2\n          t.scale = 1.0\n          slot.glow = 1.0\n          slot.bounce = 0.4\n          bread.allow = true\n          message = \"¡Correcto!\"\n          messageTimer = 1.0\n          playSound(\"place\")\n          playSound(\"ok\")\n        else\n          mistakes = mistakes + 1\n          message = \"Inténtalo de nuevo\\nTry again\"\n          messageTimer = 1.2\n          t.shake = 0.6\n          t.returnToBase = true\n          playSound(\"wrong\")\n          if mistakes >= 4 then\n            loseGame(\"mistakes\")\n          end\n        end\n      else\n        t.returnToBase = true\n      end\n      draggingTile = nil\n    end\n    if bread.drag then\n      bread.drag = false\n      if bread.allow then\n        local cafeZoneX = rightIsland.x + rightIsland.w*0.50\n        if bread.x >= cafeZoneX then\n          completeRound()\n        end\n      end\n    end\n  end\nend\n\nlocal function updateTiles(dt)\n  for _,t in ipairs(tiles) do\n    if t.shake and t.shake > 0 then\n      t.shake = t.shake - dt\n      if t.shake < 0 then t.shake = 0 end\n    end\n    if t.returnToBase then\n      t.x = lerp(t.x, t.baseX, 10*dt)\n      t.y = lerp(t.y, t.baseY, 10*dt)\n      if math.abs(t.x - t.baseX) < 0.5 and math.abs(t.y - t.baseY) < 0.5 then\n        t.x = t.baseX\n        t.y = t.baseY\n        t.returnToBase = false\n      end\n    end\n  end\nend\n\nlocal function updateBread(dt)\n  if bread.allow then\n    bread.x = lerp(bread.x, bread.targetX, 10*dt)\n  else\n    bread.targetX = bread.x\n  end\nend\n\nfunction update(dt)\n  time = getTime()\n  hudPulse = (math.sin(time*2.0)+1)*0.5\n  if gameState == \"playing\" then\n    timeLeft = timeLeft - dt\n    if timeLeft <= 0 then\n      timeLeft = 0\n      loseGame(\"time\")\n    end\n  end\n  if messageTimer > 0 then\n    messageTimer = messageTimer - dt\n    if messageTimer < 0 then messageTimer = 0 end\n  end\n  if slot.glow > 0 then\n    slot.glow = slot.glow - dt*0.8\n    if slot.glow < 0 then slot.glow = 0 end\n  end\n  if slot.bounce > 0 then\n    slot.bounce = slot.bounce - dt*1.8\n    if slot.bounce < 0 then slot.bounce = 0 end\n  end\n\n  updateDragging(dt)\n  updateTiles(dt)\n  updateBread(dt)\n\n  if (gameState == \"win\" or gameState == \"lose\") and endTimer > 0 then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      if gameState == \"win\" then\n        playSound(\"win\")\n        playSound(\"win2\")\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n  end\nend\n\nlocal function drawBackground()\n  drawGradientRect(0,0,W,H, colors.bg1, colors.bg2, true)\n  setBlendMode(\"add\")\n  local sunX = W*0.18\n  local sunY = H*0.18\n  drawRadialGradient(sunX, sunY, H*0.20, rgba(255,240,180,220), rgba(255,240,180,0))\n  setBlendMode(\"normal\")\nend\n\nlocal function drawIslands()\n  drawRoundedRect(leftIsland.x, leftIsland.y, leftIsland.w, leftIsland.h, 36, colors.island, true)\n  drawRoundedRect(leftIsland.x, leftIsland.y+leftIsland.h-12, leftIsland.w, 12, 4, colors.islandDark, true)\n  drawRoundedRect(rightIsland.x, rightIsland.y, rightIsland.w, rightIsland.h, 36, colors.island, true)\n  drawRoundedRect(rightIsland.x, rightIsland.y+rightIsland.h-12, rightIsland.w, 12, 4, colors.islandDark, true)\n\n  local hx = leftIsland.x + leftIsland.w*0.28\n  local hy = leftIsland.y + leftIsland.h*0.35\n  drawTriangle(hx-18,hy, hx,hy-22, hx+18,hy, colors.house, true)\n  drawRect(hx-15,hy, 30,26, colors.house, true)\n  drawRect(hx-15,hy, 30,26, rgba(0,0,0,40), false, 2)\n\n  local cx = rightIsland.x + rightIsland.w*0.60\n  local cy = rightIsland.y + rightIsland.h*0.42\n  drawRoundedRect(cx-28, cy-18, 56, 36, 6, colors.cafe, true)\n  drawRect(cx-20, cy-24, 40, 10, colors.cafe, true)\n  drawText(\"café\", cx-20, cy+28, colors.black, 16, \"monospace\")\nend\n\nlocal function drawBridge()\n  drawRoundedRect(slot.x, slot.y, slot.w, slot.h, 10, colors.bridgeSlot, true)\n  drawRoundedRect(slot.x, slot.y, slot.w, slot.h, 10, rgba(0,0,0,60), false, 2)\n  if slot.filled and slot.correct then\n    local bounceY = -math.sin((1-slot.bounce)*math.pi)*6*slot.bounce\n    pushTransform()\n    translate(0,bounceY)\n    drawRoundedRect(slot.x, slot.y, slot.w, slot.h, 10, colors.bridgeGood, true)\n    popTransform()\n    setBlendMode(\"add\")\n    local glowA = math.floor(120*slot.glow + 70*math.abs(math.sin(time*6))*slot.glow)\n    drawRoundedRect(slot.x-6, slot.y-6, slot.w+12, slot.h+12, 14, rgba(120,255,190, glowA), false, 6)\n    setBlendMode(\"normal\")\n  elseif slot.filled and not slot.correct then\n    drawRoundedRect(slot.x, slot.y, slot.w, slot.h, 10, colors.bridgeBad, true)\n  end\nend\n\nlocal function drawTiles()\n  local trayX = W*0.1\n  local trayW = W*0.8\n  drawRoundedRect(trayX, H-110, trayW, 80, 12, colors.tray, true)\n  drawRoundedRect(trayX, H-110, trayW, 80, 12, rgba(0,0,0,60), false, 2)\n  for _,t in ipairs(tiles) do\n    local dx = 0\n    if t.shake and t.shake > 0 then\n      dx = math.sin(time*26)*8*(t.shake/0.6)\n    end\n    local px = t.x + dx\n    local py = t.y\n    pushTransform()\n    translate(px,py)\n    if t.locked then\n      local s = 1.0 + 0.08*slot.bounce\n      scale(s,s)\n    end\n    drawRoundedRect(-t.w/2, -t.h/2, t.w, t.h, 8, colors.tile, true)\n    drawRoundedRect(-t.w/2, -t.h/2, t.w, t.h, 8, rgba(0,0,0,80), false, 2)\n    drawText(t.label, -10, 7, colors.tileText, 24, \"monospace\")\n    popTransform()\n  end\nend\n\nlocal function drawBread()\n  drawCircle(bread.x+2, bread.y+2, bread.r+1, colors.shadow, true)\n  drawCircle(bread.x, bread.y, bread.r, colors.bread, true)\n  drawText(\"pan\", bread.x - 14, bread.y - bread.r - 10, colors.black, 16, \"monospace\")\nend\n\nlocal function drawHUD()\n  local pad = 14\n  local barW = W*0.44\n  local barX = pad\n  local barY = pad\n  drawRoundedRect(barX, barY, barW, 16, 8, rgba(0,0,0,50), true)\n  local pct = timeLeft / timerTotal\n  pct = clamp(pct,0,1)\n  local col = rgbf(120,200,140)\n  if pct < 0.33 then col = rgbf(220,100,100) elseif pct < 0.66 then col = rgbf(240,180,80) end\n  drawRoundedRect(barX+2, barY+2, (barW-4)*pct, 12, 6, col, true)\n  drawText(string.format(\"Tiempo: %ds\", math.floor(timeLeft+0.99)), barX+barW+12, barY-2, colors.ui, 18, \"monospace\")\n  drawText(string.format(\"Errores: %d/3\", mistakes), barX+barW+12, barY+18, colors.ui, 16, \"monospace\")\n  drawText(string.format(\"Ronda: %d/3\", currentRound<=#rounds and currentRound or #rounds), W-120, barY-2, colors.ui, 18, \"monospace\")\nend\n\nlocal function drawInstructions()\n  local y = 54\n  drawText(\"Arrastra una preposición\", 20, y, colors.ui, 20, \"monospace\")\n  drawText(\"Drag a preposition tile\", 20, y+18, rgba(0,0,0,140), 14, \"monospace\")\n  local inst = rounds[currentRound] or rounds[#rounds]\n  local txY = y+46\n  drawText(inst.target, 20, txY, colors.black, 22, \"monospace\")\n  drawText(inst.native, 20, txY+22, rgba(0,0,0,160), 16, \"monospace\")\n  drawText(\"desayuno\", W-120, y, colors.ui, 16, \"monospace\")\nend\n\nlocal function drawStartScreen()\n  drawBackground()\n  drawIslands()\n  drawBridge()\n  drawBread()\n  drawTiles()\n  local title = \"Breakfast Bridges\"\n  drawText(\"Puentes de Desayuno\", W/2 - 150, H*0.20, colors.black, 28, \"monospace\")\n  drawText(\"(Breakfast Bridges)\", W/2 - 120, H*0.20+22, rgba(0,0,0,150), 16, \"monospace\")\n  drawText(\"Preposiciones: a, en\", W/2 - 110, H*0.20+48, colors.ui, 16, \"monospace\")\n  local pulse = 6*hudPulse\n  drawRoundedRect(startButton.x-4, startButton.y-4, startButton.w+8, startButton.h+8, 14, rgba(0,0,0,50), true)\n  drawRoundedRect(startButton.x, startButton.y, startButton.w, startButton.h, 12, colors.gold, true)\n  setBlendMode(\"add\")\n  drawRoundedRect(startButton.x-6, startButton.y-6, startButton.w+12, startButton.h+12, 16, rgba(255,220,120, 60+math.floor(80*hudPulse)), false, 4)\n  setBlendMode(\"normal\")\n  drawText(\"Iniciar\", startButton.x + startButton.w/2 - 32, startButton.y + startButton.h/2 - 8, colors.black, 24, \"monospace\")\nend\n\nlocal function drawMessages()\n  if messageTimer > 0 and message ~= \"\" then\n    local w,h = measureText(message, 18)\n    local x = W/2 - w/2 - 12\n    local y = H*0.08\n    local alphaBg = 160\n    drawRoundedRect(x, y, w+24, 40, 10, rgba(255,255,255,alphaBg), true)\n    local col = colors.ui\n    if message == \"¡Correcto!\" or string.find(message, \"Correct\") then col = colors.goodText end\n    if string.find(message, \"Inténtalo\") then col = colors.badText end\n    drawText(message, x+12, y+10, col, 18, \"monospace\")\n  end\nend\n\nfunction draw()\n  clear(colors.bg1)\n  drawBackground()\n  if gameState == \"menu\" then\n    drawStartScreen()\n  else\n    drawIslands()\n    drawBridge()\n    drawBread()\n    drawTiles()\n    drawHUD()\n    drawInstructions()\n    drawMessages()\n  end\n\n  if gameState == \"win\" then\n    local w1,h1 = measureText(\"¡Desayuno entregado!\", 28)\n    local w2,h2 = measureText(\"Breakfast delivered!\", 18)\n    local bx = W/2 - (w1+40)/2\n    local by = H/2 - 60\n    drawRoundedRect(bx, by, w1+40, 90, 12, rgba(255,255,255,220), true)\n    drawText(\"¡Desayuno entregado!\", bx+20, by+18, colors.goodText, 28, \"monospace\")\n    drawText(\"Breakfast delivered!\", bx+20, by+50, colors.ui, 18, \"monospace\")\n  elseif gameState == \"lose\" then\n    local t1 = \"Practiquemos otra vez.\"\n    local t2 = \"Let's practice again.\"\n    local w1,h1 = measureText(t1, 26)\n    local w2,h2 = measureText(t2, 18)\n    local bx = W/2 - (w1+40)/2\n    local by = H/2 - 60\n    drawRoundedRect(bx, by, w1+40, 90, 12, rgba(255,255,255,220), true)\n    drawText(t1, bx+20, by+18, colors.badText, 26, \"monospace\")\n    drawText(t2, bx+20, by+50, colors.ui, 18, \"monospace\")\n  end\nend",
      "id": "game_1_breakfast_bridges",
      "trigger_id": "loc_6_caf_de_los_susurros",
      "trigger_type": "location",
      "related_quest_id": "quest_2_bread_for_breakfast"
    },
    {
      "name": {
        "native_language": "Street Shouts",
        "target_language": "Gritos de la calle"
      },
      "description": {
        "native_language": "Click the correct Spanish word on Main Street before it disappears.",
        "target_language": "Haz clic en la palabra en español correcta en la Calle Principal antes de que desaparezca."
      },
      "language_level": "A0",
      "target_vocabulary": [
        {
          "native_language": "water bottle",
          "target_language": "botella de agua"
        },
        {
          "native_language": "street",
          "target_language": "calle"
        },
        {
          "native_language": "park",
          "target_language": "parque"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Imperatives: Haz clic, Busca",
          "target_language": "Imperativos: Haz clic, Busca"
        },
        {
          "native_language": "Present tense recognition: es/está (very basic)",
          "target_language": "Reconocimiento del presente: es/está (muy básico)"
        }
      ],
      "game_prompt": "Game: Whack-a-word on Main Street.\nMechanics:\n- Words float up as speech bubbles from shop windows on a grey road. Player must click the bubble that matches the bilingual instruction.\n- Each round shows a large instruction at the top (bilingual). Three to five bubbles appear containing Spanish words; sometimes include one English distractor to test recognition.\n- Correct click earns a point; wrong click costs a heart.\nVisual design:\n- Background: flat grey strip for street with white lane lines; green rectangle patches for 'parque' area at edges. Bubbles: circles with text; colors: blue for targets, red for recent miss flash.\nEducational content (on-screen):\n- Round prompts (randomized):\n  - {\"native_language\":\"Click 'street' in Spanish.\",\"target_language\":\"Haz clic en 'calle'.\"}\n  - {\"native_language\":\"Click 'park' in Spanish.\",\"target_language\":\"Haz clic en 'parque'.\"}\n  - {\"native_language\":\"Find 'water bottle' in Spanish.\",\"target_language\":\"Busca 'botella de agua'.\"}\n- Bubble pool (Spanish words): 'calle', 'parque', 'botella de agua'. Add simple distractors in Spanish at A0 level like 'sí', 'no'.\n- UI text:\n  - {\"native_language\":\"Start\",\"target_language\":\"Iniciar\"}\n  - {\"native_language\":\"Score\",\"target_language\":\"Puntuación\"}\n  - {\"native_language\":\"Lives\",\"target_language\":\"Vidas\"}\n  - {\"native_language\":\"Great!\",\"target_language\":\"¡Genial!\"}\n  - {\"native_language\":\"Oops!\",\"target_language\":\"¡Ups!\"}\nWin/Lose:\n- Win by getting 8 correct before losing all 3 lives. Lose if lives reach 0.\nAnimations:\n- Bubbles drift upward at varied speeds; correct click pops with a small star burst; wrong click shakes screen slightly.",
      "skill_points": 12,
      "lua_code": "local W, H\nlocal state = \"start\"\nlocal score = 0\nlocal lives = 3\nlocal roundPrompt = nil\nlocal promptEs = \"\"\nlocal promptEn = \"\"\nlocal targetWord = \"\"\nlocal bubbles = {}\nlocal stars = {}\nlocal feedbackText = \"\"\nlocal feedbackColor = \"#FFFFFF\"\nlocal feedbackTimer = 0\nlocal waitNextTimer = 0\nlocal shakeTimer = 0\nlocal endTimer = 0\nlocal startBtn = {x=0,y=0,w=0,h=0}\nlocal timeAcc = 0\nlocal roadY, roadH = 0, 0\nlocal windowSpawns = {}\nlocal poolEs = {\"calle\",\"parque\",\"botella de agua\",\"sí\",\"no\"}\nlocal vocab = {\n  {en=\"street\", es=\"calle\"},\n  {en=\"park\", es=\"parque\"},\n  {en=\"water bottle\", es=\"botella de agua\"}\n}\nlocal prompts = {\n  {en=\"Click 'street' in Spanish.\", es=\"Haz clic en 'calle'.\", target=\"calle\"},\n  {en=\"Click 'park' in Spanish.\", es=\"Haz clic en 'parque'.\", target=\"parque\"},\n  {en=\"Find 'water bottle' in Spanish.\", es=\"Busca 'botella de agua'.\", target=\"botella de agua\"}\n}\nlocal okSoundName = \"ok\"\nlocal badSoundName = \"bad\"\nlocal popSoundName = \"pop\"\nlocal blueEdge = \"#66B3FF\"\nlocal blueCenter = \"#E6F4FF\"\nlocal textDark = \"#0A2E5C\"\n\nlocal function drawHeart(x, y, s, color)\n  local r = s*0.3\n  drawCircle(x - r*0.7, y - r*0.4, r, color, true)\n  drawCircle(x + r*0.7, y - r*0.4, r, color, true)\n  drawTriangle(x - r*1.4, y - r*0.2, x + r*1.4, y - r*0.2, x, y + r*1.8, color, true)\nend\n\nlocal function pointInCircle(px, py, cx, cy, r)\n  local dx = px - cx\n  local dy = py - cy\n  return dx*dx + dy*dy <= r*r\nend\n\nlocal function addStarBurst(x, y, n)\n  for i=1,n do\n    local a = random(0, math.pi*2)\n    local sp = random(60, 160)\n    local life = random(0.35, 0.7)\n    local sz = random(2, 4)\n    table.insert(stars, {x=x, y=y, vx=math.cos(a)*sp, vy=math.sin(a)*sp, life=life, max=life, size=sz})\n  end\nend\n\nlocal function buildWindows()\n  windowSpawns = {}\n  local buildingCount = 3\n  local gap = W*0.02\n  local totalGap = gap*(buildingCount+1)\n  local bw = (W - totalGap)/buildingCount\n  local shopH = H*0.22\n  local shopY = roadY - shopH - H*0.03\n  for i=1,buildingCount do\n    local bx = gap + (i-1)*(bw+gap)\n    local cols = 3\n    local rows = 2\n    local pad = bw*0.08\n    local ww = (bw - pad*(cols+1))/cols\n    local wh = (shopH*0.5 - pad*(rows+1))/rows\n    for r=1,rows do\n      for c=1,cols do\n        local wx = bx + pad + (c-1)*(ww+pad) + ww*0.5\n        local wy = shopY + pad + (r-1)*(wh+pad) + wh*0.5\n        table.insert(windowSpawns, {x=wx, y=wy})\n      end\n    end\n  end\nend\n\nlocal function pickWindowPos()\n  if #windowSpawns == 0 then return {x=W*0.5, y=roadY-20} end\n  local idx = randomInt(1, #windowSpawns)\n  return windowSpawns[idx]\nend\n\nlocal function makeBubble(text, isTarget)\n  local pos = pickWindowPos()\n  local fontSize = 20\n  local tw, th = measureText(text, fontSize)\n  local r = math.max(28, tw*0.6 + 14)\n  local speed = random(24, 42)\n  local driftAmp = random(8, 18)\n  local phase = random(0, math.pi*2)\n  return {\n    text=text,\n    x=pos.x + random(-8,8),\n    y=pos.y + random(-6,6),\n    r=r,\n    speed=speed,\n    driftAmp=driftAmp,\n    phase=phase,\n    isTarget=isTarget,\n    flash=0,\n    alive=true,\n    popped=false,\n    popTimer=0,\n    fontSize=fontSize\n  }\nend\n\nlocal function contains(t, v)\n  for i=1,#t do if t[i]==v then return true end end\n  return false\nend\n\nlocal function spawnRound()\n  bubbles = {}\n  local p = prompts[randomInt(1, #prompts)]\n  roundPrompt = p\n  promptEs = p.es\n  promptEn = p.en\n  targetWord = p.target\n  local count = randomInt(3,5)\n  local chosen = {}\n  table.insert(bubbles, makeBubble(targetWord, true))\n  table.insert(chosen, targetWord)\n  local candidates = {}\n  for i=1,#poolEs do\n    local w = poolEs[i]\n    if w ~= targetWord then table.insert(candidates, w) end\n  end\n  while #bubbles < count and #candidates > 0 do\n    local pickIndex = randomInt(1, #candidates)\n    local w = candidates[pickIndex]\n    table.remove(candidates, pickIndex)\n    table.insert(bubbles, makeBubble(w, false))\n    table.insert(chosen, w)\n  end\n  if random() < 0.5 then\n    local enList = {}\n    for i=1,#vocab do table.insert(enList, vocab[i].en) end\n    local enPick = enList[randomInt(1, #enList)]\n    if not contains(chosen, enPick) then\n      table.insert(bubbles, makeBubble(enPick, false))\n    end\n  end\nend\n\nlocal function resetForNextRound()\n  waitNextTimer = 0.7\nend\n\nlocal function onCorrect(x, y)\n  score = score + 1\n  feedbackText = \"¡Genial! (Great!)\"\n  feedbackColor = \"#29CC7A\"\n  feedbackTimer = 0.7\n  playSound(okSoundName)\n  playSound(popSoundName)\n  addStarBurst(x, y, 22)\n  if score >= 8 then\n    state = \"win\"\n    endTimer = 1.5\n  else\n    resetForNextRound()\n  end\nend\n\nlocal function onWrong(bub)\n  lives = lives - 1\n  feedbackText = \"¡Ups! (Oops!)\"\n  feedbackColor = \"#FF5555\"\n  feedbackTimer = 0.7\n  bub.flash = 0.35\n  shakeTimer = 0.28\n  playSound(badSoundName)\n  if lives <= 0 then\n    state = \"lose\"\n    endTimer = 1.5\n  end\nend\n\nfunction init()\n  randomSeed(os.time())\n  W = getScreenWidth()\n  H = getScreenHeight()\n  roadH = H*0.36\n  roadY = H*0.5 - roadH*0.15\n  buildWindows()\n  startBtn.w = math.min(260, W*0.6)\n  startBtn.h = 64\n  startBtn.x = W*0.5 - startBtn.w*0.5\n  startBtn.y = H*0.62\n  createSound(okSoundName, 880, 0.1, 0.5, \"triangle\")\n  createSound(badSoundName, 200, 0.25, 0.6, \"sawtooth\")\n  createSound(popSoundName, 1200, 0.05, 0.4, \"sine\")\nend\n\nfunction update(dt)\n  timeAcc = timeAcc + dt\n  if feedbackTimer > 0 then\n    feedbackTimer = feedbackTimer - dt\n    if feedbackTimer < 0 then feedbackTimer = 0 end\n  end\n  if shakeTimer > 0 then\n    shakeTimer = shakeTimer - dt\n    if shakeTimer < 0 then shakeTimer = 0 end\n  end\n  if state == \"start\" then\n    if isMouseJustPressed() then\n      local mx, my = getMouseX(), getMouseY()\n      if mx >= startBtn.x and mx <= startBtn.x+startBtn.w and my >= startBtn.y and my <= startBtn.y+startBtn.h then\n        state = \"play\"\n        score = 0\n        lives = 3\n        spawnRound()\n      end\n    end\n    return\n  end\n  if state == \"play\" then\n    if waitNextTimer > 0 then\n      waitNextTimer = waitNextTimer - dt\n      if waitNextTimer <= 0 then\n        spawnRound()\n      end\n    else\n      for i=#bubbles,1,-1 do\n        local b = bubbles[i]\n        if b.alive then\n          b.y = b.y - b.speed*dt\n          b.x = b.x + math.sin(timeAcc*1.7 + b.phase)*b.driftAmp*dt\n          if b.flash and b.flash > 0 then\n            b.flash = b.flash - dt\n            if b.flash < 0 then b.flash = 0 end\n          end\n          if b.popped then\n            b.popTimer = b.popTimer - dt\n            if b.popTimer <= 0 then\n              b.alive = false\n            end\n          end\n          if b.y + b.r < 0 then\n            local pos = pickWindowPos()\n            b.y = pos.y + random(-6,6)\n            b.x = pos.x + random(-8,8)\n          end\n        end\n      end\n      if isMouseJustPressed() then\n        local mx, my = getMouseX(), getMouseY()\n        local clicked = false\n        for i=#bubbles,1,-1 do\n          local b = bubbles[i]\n          if b.alive and not b.popped and pointInCircle(mx, my, b.x, b.y, b.r) then\n            clicked = true\n            if b.isTarget then\n              b.popped = true\n              b.popTimer = 0.35\n              onCorrect(b.x, b.y)\n              for j=1,#bubbles do\n                if j ~= i then\n                  bubbles[j].alive = false\n                end\n              end\n            else\n              onWrong(b)\n            end\n            break\n          end\n        end\n        if not clicked then\n          onWrong({flash=0})\n        end\n      end\n    end\n    for i=#stars,1,-1 do\n      local s = stars[i]\n      s.life = s.life - dt\n      s.x = s.x + s.vx*dt\n      s.y = s.y + s.vy*dt\n      s.vx = s.vx * (1 - dt*1.2)\n      s.vy = s.vy * (1 - dt*1.2) + 20*dt*0.2\n      if s.life <= 0 then table.remove(stars, i) end\n    end\n  elseif state == \"win\" then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      halt(2)\n    end\n  elseif state == \"lose\" then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      halt(1)\n    end\n  end\nend\n\nfunction draw()\n  local shakeX, shakeY = 0, 0\n  if shakeTimer > 0 then\n    local amp = 6 * (shakeTimer/0.28)\n    shakeX = random(-amp, amp)\n    shakeY = random(-amp*0.6, amp*0.6)\n  end\n  pushTransform()\n  translate(shakeX, shakeY)\n  drawGradientRect(0, 0, W, H, \"#BDE0FF\", \"#7FB3FF\", true)\n  drawRect(0, 0, W, H*0.12, \"#6AD76A\", true)\n  drawRect(0, H - H*0.14, W, H*0.14, \"#62C85F\", true)\n  drawRect(0, roadY, W, roadH, \"#575757\", true)\n  local laneCount = 10\n  local dashW = W/(laneCount*2)\n  local midY = roadY + roadH*0.5\n  for i=0,laneCount-1 do\n    local x = i*2*dashW + dashW*0.3\n    drawRect(x, midY-3, dashW*1.4, 6, \"#FFFFFF\", true)\n  end\n  local buildingCount = 3\n  local gap = W*0.02\n  local totalGap = gap*(buildingCount+1)\n  local bw = (W - totalGap)/buildingCount\n  local shopH = H*0.22\n  local shopY = roadY - shopH - H*0.03\n  for i=1,buildingCount do\n    local bx = gap + (i-1)*(bw+gap)\n    local col = i==2 and \"#FFC86B\" or (i==1 and \"#FF9FB3\" or \"#9ED8FF\")\n    drawRoundedRect(bx, shopY, bw, shopH, 10, col, true)\n    local signH = shopH*0.18\n    drawRect(bx, shopY, bw, signH, \"#333333\", true)\n    local name = i==1 and \"TIENDA\" or (i==2 and \"CAFÉ\" or \"LIBROS\")\n    local tw, th = measureText(name, 18)\n    drawText(name, bx + bw*0.5 - tw*0.5, shopY + signH*0.5 - th*0.5, \"#FFFFFF\", 18, \"monospace\")\n    local cols = 3\n    local rows = 2\n    local pad = bw*0.08\n    local ww = (bw - pad*(cols+1))/cols\n    local wh = (shopH*0.5 - pad*(rows+1))/rows\n    for r=1,rows do\n      for c=1,cols do\n        local wx = bx + pad + (c-1)*(ww+pad)\n        local wy = shopY + signH + pad + (r-1)*(wh+pad)\n        drawRect(wx, wy, ww, wh, \"#FFF2A0\", true)\n        drawRect(wx, wy, ww, wh, \"#E0C870\", false, 2)\n      end\n    end\n  end\n  local headerH = H*0.16\n  drawRoundedRect(W*0.5 - W*0.45, H*0.02, W*0.9, headerH, 12, \"#FFFFFF\", true)\n  local scoreText = \"Puntuación (Score): \"..tostring(score)\n  local livesText = \"Vidas (Lives):\"\n  drawText(scoreText, W*0.08, H*0.04, \"#1E1E1E\", 20, \"monospace\")\n  drawText(livesText, W*0.08, H*0.08, \"#1E1E1E\", 18, \"monospace\")\n  for i=1,3 do\n    local cx = W*0.08 + 160 + (i-1)*28\n    local cy = H*0.087\n    local col = i <= lives and \"#FF4D6D\" or \"#AAAAAA\"\n    drawHeart(cx, cy, 18, col)\n  end\n  if state ~= \"start\" then\n    local esSize = 26\n    local enSize = 16\n    local esW, esH = measureText(promptEs, esSize)\n    drawText(promptEs, W*0.5 - esW*0.5, H*0.03 + 4, \"#222222\", esSize, \"monospace\")\n    local enW, enH = measureText(promptEn, enSize)\n    drawText(promptEn, W*0.5 - enW*0.5, H*0.03 + 8 + esH, \"#4A4A4A\", enSize, \"monospace\")\n  end\n  if state == \"start\" then\n    drawRoundedRect(W*0.5 - W*0.42, H*0.18, W*0.84, H*0.48, 14, \"#FFFFFF\", true)\n    local t1 = \"Street Shouts\"\n    local t2 = \"Haz clic en la burbuja correcta\"\n    local t3 = \"(Click the correct bubble)\"\n    local t4 = \"Objetivo: 8 aciertos antes de perder 3 vidas\"\n    local t5 = \"Imperativos: Haz clic, Busca • Reconocimiento: es/está\"\n    local w1, h1 = measureText(t1, 36)\n    drawText(t1, W*0.5 - w1*0.5, H*0.22, \"#1E1E1E\", 36, \"monospace\")\n    local w2, h2 = measureText(t2, 22)\n    drawText(t2, W*0.5 - w2*0.5, H*0.22 + h1 + 10, \"#0A2E5C\", 22, \"monospace\")\n    local w3, h3 = measureText(t3, 16)\n    drawText(t3, W*0.5 - w3*0.5, H*0.22 + h1 + 10 + h2 + 4, \"#444444\", 16, \"monospace\")\n    local w4, h4 = measureText(t4, 18)\n    drawText(t4, W*0.5 - w4*0.5, H*0.22 + h1 + 10 + h2 + 4 + h3 + 8, \"#1E1E1E\", 18, \"monospace\")\n    local w5, h5 = measureText(t5, 14)\n    drawText(t5, W*0.5 - w5*0.5, H*0.22 + h1 + 10 + h2 + 4 + h3 + 8 + h4 + 8, \"#2B5A9A\", 14, \"monospace\")\n    local btnCol = \"#2D8CFF\"\n    drawRoundedRect(startBtn.x, startBtn.y, startBtn.w, startBtn.h, 12, btnCol, true)\n    drawRoundedRect(startBtn.x, startBtn.y, startBtn.w, startBtn.h, 12, \"#1450AA\", false, 3)\n    local label = \"Iniciar (Start)\"\n    local lw, lh = measureText(label, 22)\n    drawText(label, startBtn.x + startBtn.w*0.5 - lw*0.5, startBtn.y + startBtn.h*0.5 - lh*0.5, \"#FFFFFF\", 22, \"monospace\")\n    popTransform()\n    return\n  end\n  for i=1,#bubbles do\n    local b = bubbles[i]\n    if b.alive and not b.popped then\n      drawRadialGradient(b.x, b.y, b.r, blueCenter, blueEdge)\n      drawCircle(b.x, b.y, b.r, \"#FFFFFF\", false, 2)\n      if b.flash and b.flash > 0 then\n        local alpha = math.floor(160 * (b.flash/0.35))\n        drawCircle(b.x, b.y, b.r+2, rgba(255,70,70, math.max(80, alpha)), true)\n      end\n      local tw, th = measureText(b.text, b.fontSize)\n      drawText(b.text, b.x - tw*0.5, b.y - th*0.5, textDark, b.fontSize, \"monospace\")\n      if b.isTarget then\n        drawCircle(b.x, b.y, b.r+4, \"#3388FF\", false, 2)\n      end\n    end\n  end\n  if #stars > 0 then\n    setBlendMode(\"add\")\n    for i=1,#stars do\n      local s = stars[i]\n      local t = s.life / s.max\n      local a = math.floor(255 * math.max(0, t))\n      drawPoint(s.x, s.y, rgba(255, 230, 90, a), s.size)\n    end\n    setBlendMode(\"normal\")\n  end\n  if feedbackTimer > 0 then\n    local a = math.floor(255 * math.min(1, feedbackTimer/0.7))\n    local col = rgba(255,255,255,a)\n    local shadow = rgba(0,0,0,120)\n    local fs = 28\n    local wfb, hfb = measureText(feedbackText, fs)\n    drawText(feedbackText, W*0.5 - wfb*0.5 + 2, H*0.18 + 2, shadow, fs, \"monospace\")\n    drawText(feedbackText, W*0.5 - wfb*0.5, H*0.18, feedbackColor, fs, \"monospace\")\n  end\n  local grammar = \"Imperativos: Haz clic, Busca • Reconocimiento: es/está (A0)\"\n  local gw, gh = measureText(grammar, 14)\n  drawRoundedRect(W*0.5 - gw*0.5 - 12, H - gh - 18, gw + 24, gh + 12, 8, \"#FFFFFF\", true)\n  drawText(grammar, W*0.5 - gw*0.5, H - gh - 12, \"#1E1E1E\", 14, \"monospace\")\n  if state == \"win\" then\n    setBlendMode(\"multiply\")\n    drawRect(0,0,W,H, rgba(0, 255, 120, 60), true)\n    setBlendMode(\"normal\")\n    local msg = \"¡Genial! ¡Ganaste! (You win)\"\n    local wmsg, hmsg = measureText(msg, 34)\n    drawText(msg, W*0.5 - wmsg*0.5, H*0.42, \"#0A7A3A\", 34, \"monospace\")\n  elseif state == \"lose\" then\n    setBlendMode(\"multiply\")\n    drawRect(0,0,W,H, rgba(255, 0, 0, 60), true)\n    setBlendMode(\"normal\")\n    local msg = \"Fin del juego (Game Over)\"\n    local wmsg, hmsg = measureText(msg, 34)\n    drawText(msg, W*0.5 - wmsg*0.5, H*0.42, \"#7A0A0A\", 34, \"monospace\")\n  end\n  popTransform()\nend",
      "id": "game_2_street_shouts",
      "trigger_id": "npc_1_marcos",
      "trigger_type": "npc",
      "related_quest_id": "quest_12_message_of_the_main_street"
    },
    {
      "name": {
        "native_language": "Friend & Stone Memory",
        "target_language": "Memoria de amigo y piedra"
      },
      "description": {
        "native_language": "Flip cards to match English-Spanish pairs and answer tiny yes/no color questions.",
        "target_language": "Voltea cartas para emparejar pares inglés–español y responde pequeñas preguntas de sí/no sobre colores."
      },
      "language_level": "A0",
      "target_vocabulary": [
        {
          "native_language": "blue",
          "target_language": "azul"
        },
        {
          "native_language": "stone",
          "target_language": "piedra"
        },
        {
          "native_language": "friend",
          "target_language": "amigo"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Basic questions: ¿Es ...?; Yes/No: Sí/No",
          "target_language": "Preguntas básicas: ¿Es ...?; Sí/No: Sí/No"
        },
        {
          "native_language": "Simple present: es",
          "target_language": "Presente simple: es"
        }
      ],
      "game_prompt": "Game: Memory-match with mini yes/no prompts.\nMechanics:\n- 6 cards (3 pairs). Each pair is English on one card and Spanish on the other.\n- Click to flip two cards. If they match (e.g., 'blue' with 'azul'), they stay face-up. On a successful match, a tiny prompt appears; click 'Sí' or 'No' to answer.\n- Example: after matching 'blue/azul', show: {\"native_language\":\"Is it blue?\",\"target_language\":\"¿Es azul?\"}. Correct answer shows green check.\nVisual design:\n- Park-themed table: green background. Cards are rounded rectangles. Spanish cards have a small flag icon shape (triangle) in one corner; English cards have a circle icon.\nEducational content:\n- Card pairs:\n  - {\"native_language\":\"blue\",\"target_language\":\"azul\"}\n  - {\"native_language\":\"stone\",\"target_language\":\"piedra\"}\n  - {\"native_language\":\"friend\",\"target_language\":\"amigo\"}\n- Question prompts (shown after correct match):\n  - For blue: {\"native_language\":\"Is it blue?\",\"target_language\":\"¿Es azul?\"}\n  - For stone: {\"native_language\":\"Is it a stone?\",\"target_language\":\"¿Es una piedra?\"}\n  - For friend: {\"native_language\":\"Is it a friend?\",\"target_language\":\"¿Es un amigo?\"}\n- Answer buttons:\n  - {\"native_language\":\"Yes\",\"target_language\":\"Sí\"}\n  - {\"native_language\":\"No\",\"target_language\":\"No\"}\n- UI text:\n  - {\"native_language\":\"Moves\",\"target_language\":\"Movimientos\"}\n  - {\"native_language\":\"Matches\",\"target_language\":\"Aciertos\"}\n  - {\"native_language\":\"Great memory!\",\"target_language\":\"¡Gran memoria!\"}\nWin/Lose:\n- Win by finding all 3 pairs and answering 3 questions correctly within 12 flips. If flips run out, lose and show {\"native_language\":\"Try again.\",\"target_language\":\"Inténtalo de nuevo.\"}\nAnimations:\n- Card flip animation (scale + rotate slightly). Correct 'Sí/No' answer triggers a small sparkle.",
      "skill_points": 11,
      "lua_code": "local screenW = 0\nlocal screenH = 0\n\nlocal cards = {}\nlocal pairsData = {}\nlocal selected = {}\nlocal moves = 0\nlocal matches = 0\nlocal correctAnswers = 0\nlocal maxMoves = 12\nlocal mismatchTimer = 0\nlocal activePrompt = nil\nlocal sparkles = {}\nlocal endState = nil\nlocal endTimer = 0\nlocal uiTop = 0\nlocal grid = {cols = 3, rows = 2, gap = 0}\nlocal cardW = 0\nlocal cardH = 0\nlocal bokeh = {}\nlocal lockBoard = false\n\nlocal sounds = {\n  flip = \"s_flip\",\n  ok = \"s_ok\",\n  wrong = \"s_wrong\"\n}\n\nlocal function shuffle(t)\n  for i = #t, 2, -1 do\n    local j = randomInt(1, i)\n    t[i], t[j] = t[j], t[i]\n  end\nend\n\nlocal function pointInRect(px, py, rx, ry, rw, rh)\n  return px >= rx and px <= rx + rw and py >= ry and py <= ry + rh\nend\n\nlocal function approach(value, target, delta)\n  if value < target then\n    value = value + delta\n    if value > target then value = target end\n  elseif value > target then\n    value = value - delta\n    if value < target then value = target end\n  end\n  return value\nend\n\nlocal function createSparkles(cx, cy, c)\n  for i = 1, 24 do\n    local ang = random(0, math.pi * 2)\n    local spd = random(60, 180)\n    local life = random(0.3, 0.7)\n    table.insert(sparkles, {\n      x = cx, y = cy,\n      vx = math.cos(ang) * spd,\n      vy = math.sin(ang) * spd,\n      life = life,\n      age = 0,\n      color = c or rgb(255, 230, 80),\n      size = random(2, 4)\n    })\n  end\nend\n\nlocal function checkWinLose()\n  if endState ~= nil then return end\n  if matches == 3 and correctAnswers == 3 then\n    endState = \"win\"\n    endTimer = 0\n  elseif moves >= maxMoves and not (matches == 3 and correctAnswers == 3) then\n    endState = \"lose\"\n    endTimer = 0\n  end\nend\n\nlocal function openPrompt(pairId, cx, cy)\n  local pd = nil\n  for _, p in ipairs(pairsData) do\n    if p.id == pairId then pd = p break end\n  end\n  if not pd then return end\n  local w, h = 280, 140\n  local x = math.max(20, math.min(cx - w / 2, screenW - w - 20))\n  local y = math.max(uiTop + 10, math.min(cy - h - 10, screenH - h - 20))\n  activePrompt = {\n    pairId = pairId,\n    es = pd.promptEs,\n    en = pd.promptEn,\n    x = x, y = y, w = w, h = h,\n    result = nil,\n    resultTimer = 0,\n    closeTimer = 0,\n    correct = \"si\",\n    buttons = {}\n  }\n  local bx = x + 12\n  local by = y + h - 46\n  local bw = (w - 12 * 3) / 2\n  local bh = 34\n  activePrompt.buttons = {\n    {labelEs = \"Sí\", labelEn = \"Yes\", x = bx, y = by, w = bw, h = bh, key = \"si\"},\n    {labelEs = \"No\", labelEn = \"No\", x = bx + bw + 12, y = by, w = bw, h = bh, key = \"no\"}\n  }\nend\n\nlocal function resetGame()\n  cards = {}\n  selected = {}\n  sparkles = {}\n  activePrompt = nil\n  moves = 0\n  matches = 0\n  correctAnswers = 0\n  mismatchTimer = 0\n  endState = nil\n  endTimer = 0\n  lockBoard = false\n\n  pairsData = {\n    {id = \"blue\", en = \"blue\", es = \"azul\", promptEn = \"Is it blue?\", promptEs = \"¿Es azul?\"},\n    {id = \"stone\", en = \"stone\", es = \"piedra\", promptEn = \"Is it a stone?\", promptEs = \"¿Es una piedra?\"},\n    {id = \"friend\", en = \"friend\", es = \"amigo\", promptEn = \"Is it a friend?\", promptEs = \"¿Es un amigo?\"}\n  }\n\n  local deck = {}\n  for _, p in ipairs(pairsData) do\n    table.insert(deck, {pairId = p.id, lang = \"en\", text = p.en})\n    table.insert(deck, {pairId = p.id, lang = \"es\", text = p.es})\n  end\n  shuffle(deck)\n\n  local cols, rows, gap = grid.cols, grid.rows, grid.gap\n  local startX = (screenW - (cols * cardW + (cols - 1) * gap)) / 2\n  local startY = uiTop + ((screenH - uiTop) - (rows * cardH + (rows - 1) * gap)) / 2\n\n  for i = 1, #deck do\n    local c = deck[i]\n    local col = (i - 1) % cols\n    local row = math.floor((i - 1) / cols)\n    local x = startX + col * (cardW + gap)\n    local y = startY + row * (cardH + gap)\n    cards[i] = {\n      x = x, y = y, w = cardW, h = cardH,\n      pairId = c.pairId,\n      lang = c.lang,\n      text = c.text,\n      faceUp = false,\n      matched = false,\n      t = 0,\n      pop = 0\n    }\n  end\nend\n\nfunction init()\n  screenW = getScreenWidth()\n  screenH = getScreenHeight()\n\n  uiTop = math.floor(screenH * 0.18)\n  grid.gap = math.floor(math.min(screenW, screenH) * 0.03)\n  local availW = screenW - grid.gap * (grid.cols + 1)\n  local availH = (screenH - uiTop) - grid.gap * (grid.rows + 1)\n  cardW = availW / grid.cols\n  cardH = math.min(availH / grid.rows, cardW * 1.35)\n  cardW = math.min(cardW, cardH / 1.35)\n\n  randomSeed(os.time())\n\n  createSound(sounds.flip, 660, 0.05, 0.3, \"square\")\n  createSound(sounds.ok, 880, 0.12, 0.4, \"triangle\")\n  createSound(sounds.wrong, 220, 0.18, 0.4, \"sawtooth\")\n\n  bokeh = {}\n  for i = 1, 18 do\n    table.insert(bokeh, {\n      x = random(0, screenW),\n      y = random(uiTop, screenH),\n      r = random(30, 80),\n      dx = random(-10, 10),\n      dy = random(-6, 6),\n      a = random(40, 80)\n    })\n  end\n\n  resetGame()\nend\n\nlocal function cardContains(i, mx, my)\n  local c = cards[i]\n  return pointInRect(mx, my, c.x, c.y, c.w, c.h)\nend\n\nlocal function onCardClicked(index)\n  if endState ~= nil then return end\n  if lockBoard then return end\n  local c = cards[index]\n  if c.matched or c.faceUp then return end\n  if #selected >= 2 then return end\n\n  c.faceUp = true\n  playSound(sounds.flip)\n  moves = moves + 1\n  table.insert(selected, index)\n\n  if #selected == 2 then\n    local a = cards[selected[1]]\n    local b = cards[selected[2]]\n    if a.pairId == b.pairId and a.lang ~= b.lang then\n      a.matched = true\n      b.matched = true\n      matches = matches + 1\n      a.pop = 1\n      b.pop = 1\n      selected = {}\n      -- Open prompt near pair center\n      local cx = (a.x + a.w / 2 + b.x + b.w / 2) / 2\n      local cy = (a.y + a.h / 2 + b.y + b.h / 2) / 2\n      openPrompt(a.pairId, cx, cy)\n      lockBoard = true\n    else\n      mismatchTimer = 0.8\n      lockBoard = true\n      playSound(sounds.flip)\n    end\n  end\n\n  checkWinLose()\nend\n\nlocal function updateSparkles(dt)\n  for i = #sparkles, 1, -1 do\n    local p = sparkles[i]\n    p.age = p.age + dt\n    p.x = p.x + p.vx * dt\n    p.y = p.y + p.vy * dt\n    p.vy = p.vy + 60 * dt\n    if p.age >= p.life then\n      table.remove(sparkles, i)\n    end\n  end\nend\n\nfunction update(dt)\n  if endState ~= nil then\n    endTimer = endTimer + dt\n    if endTimer >= 2.0 then\n      if endState == \"win\" then\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n  end\n\n  -- Animate cards\n  for _, c in ipairs(cards) do\n    local target = c.faceUp and 1 or 0\n    c.t = approach(c.t, target, dt * 6)\n    if c.pop > 0 then\n      c.pop = math.max(0, c.pop - dt * 2.5)\n    end\n  end\n\n  -- Mismatch timer\n  if mismatchTimer > 0 then\n    mismatchTimer = mismatchTimer - dt\n    if mismatchTimer <= 0 then\n      for _, idx in ipairs(selected) do\n        local c = cards[idx]\n        c.faceUp = false\n      end\n      selected = {}\n      lockBoard = false\n    end\n  end\n\n  -- Prompt handling timers\n  if activePrompt then\n    if activePrompt.result ~= nil then\n      activePrompt.resultTimer = activePrompt.resultTimer + dt\n      if activePrompt.result == true then\n        activePrompt.closeTimer = activePrompt.closeTimer + dt\n        if activePrompt.closeTimer >= 0.65 then\n          activePrompt = nil\n          lockBoard = false\n          checkWinLose()\n        end\n      else\n        if activePrompt.resultTimer >= 0.5 then\n          activePrompt.result = nil\n          activePrompt.resultTimer = 0\n        end\n      end\n    end\n  end\n\n  -- Sparkles\n  updateSparkles(dt)\n\n  -- Gentle bokeh drift\n  for _, b in ipairs(bokeh) do\n    b.x = b.x + b.dx * dt * 0.2\n    b.y = b.y + b.dy * dt * 0.2\n    if b.x < -b.r then b.x = screenW + b.r end\n    if b.x > screenW + b.r then b.x = -b.r end\n    if b.y < uiTop - b.r then b.y = screenH + b.r end\n    if b.y > screenH + b.r then b.y = uiTop - b.r end\n  end\n\n  -- Input\n  if isMouseJustPressed() then\n    local mx = getMouseX()\n    local my = getMouseY()\n    if activePrompt then\n      for _, btn in ipairs(activePrompt.buttons) do\n        if pointInRect(mx, my, btn.x, btn.y, btn.w, btn.h) then\n          if btn.key == activePrompt.correct then\n            activePrompt.result = true\n            correctAnswers = correctAnswers + 1\n            playSound(sounds.ok)\n            createSparkles(activePrompt.x + activePrompt.w / 2, activePrompt.y + 20, rgb(120, 255, 160))\n            checkWinLose()\n          else\n            activePrompt.result = false\n            playSound(sounds.wrong)\n          end\n          activePrompt.resultTimer = 0\n        end\n      end\n    else\n      if not lockBoard then\n        for i = 1, #cards do\n          if cardContains(i, mx, my) then\n            onCardClicked(i)\n            break\n          end\n        end\n      end\n    end\n  end\n\n  -- If moves exceeded during passive time\n  checkWinLose()\nend\n\nlocal function drawBackground()\n  clear(rgb(20, 80, 40))\n  drawGradientRect(0, 0, screenW, screenH, rgb(80, 160, 90), rgb(40, 110, 60), true)\n  drawRadialGradient(80, 60, 120, rgba(255, 255, 220, 180), rgba(255, 255, 220, 0))\n  setBlendMode(\"lighten\")\n  for _, b in ipairs(bokeh) do\n    drawCircle(b.x, b.y, b.r, rgba(180, 230, 180, b.a), true)\n  end\n  setBlendMode(\"normal\")\n  drawGradientRect(0, 0, screenW, uiTop, rgb(35, 120, 60), rgb(25, 95, 50), true)\nend\n\nlocal function drawHeader()\n  local pad = 16\n  drawText(\"Memoria: Inglés + Español (Match English with Spanish)\", pad, 24, \"#E6FFE6\", 22, \"monospace\")\n\n  local movesText = \"Movimientos: \" .. tostring(moves) .. \"/\" .. tostring(maxMoves)\n  local matchesText = \"Aciertos: \" .. tostring(matches) .. \"/3\"\n  drawText(movesText, pad, 54, \"#FFFFFF\", 18, \"monospace\")\n  drawText(matchesText, pad, 78, \"#FFFFFF\", 18, \"monospace\")\n  drawText(\"Gramática: ¿Es ...?  Respuestas: Sí / No  (A0)\", pad, 104, \"#CFFFD0\", 16, \"monospace\")\n\n  local barW = 200\n  local barH = 10\n  local bx = screenW - barW - pad\n  local by = 28\n  drawRoundedRect(bx, by, barW, barH, 5, rgba(255, 255, 255, 50), true)\n  local t = math.max(0, math.min(1, 1 - moves / maxMoves))\n  drawRoundedRect(bx, by, barW * t, barH, 5, rgb(120, 220, 140), true)\n  drawText(\"Intentos restantes (Moves left)\", bx, by + 18, \"#FFFFFF\", 14, \"monospace\")\nend\n\nlocal function drawCard(c)\n  local cx = c.x + c.w / 2\n  local cy = c.y + c.h / 2\n  pushTransform()\n  translate(cx, cy)\n\n  local flipS = 1 - 2 * math.abs(c.t - 0.5)\n  if flipS < 0.03 then flipS = 0.03 end\n  local wobble = (c.t - 0.5) * 0.25\n  local popS = 1 + c.pop * 0.08\n\n  scale(flipS * popS, popS)\n  rotate(wobble)\n\n  local showFront = c.t >= 0.5\n\n  local rx = -c.w / 2\n  local ry = -c.h / 2\n\n  if showFront then\n    local col = c.lang == \"en\" and rgba(200, 230, 255, 255) or rgba(255, 240, 210, 255)\n    drawRoundedRect(rx, ry, c.w, c.h, 18, col, true)\n    drawRoundedRect(rx, ry, c.w, c.h, 18, rgba(0, 0, 0, 40), false, 2)\n\n    local tx = c.text\n    local tw, th = measureText(tx, 28)\n    drawText(tx, -tw / 2, -th / 2, \"#204020\", 28, \"monospace\")\n\n    if c.lang == \"en\" then\n      drawCircle(rx + 16, ry + 16, 10, rgb(60, 120, 200), true)\n      drawCircle(rx + 16, ry + 16, 10, rgba(0, 0, 0, 60), false, 1.5)\n    else\n      drawTriangle(rx + 8, ry + 6, rx + 28, ry + 6, rx + 18, ry + 24, rgb(220, 80, 80), true)\n      drawTriangle(rx + 8, ry + 6, rx + 28, ry + 6, rx + 18, ry + 24, rgba(0, 0, 0, 60), false, 1.2)\n    end\n\n    if c.matched then\n      setBlendMode(\"add\")\n      drawRoundedRect(rx, ry, c.w, c.h, 18, rgba(120, 255, 160, 30), true)\n      setBlendMode(\"normal\")\n      drawRoundedRect(rx, ry, c.w, c.h, 18, rgb(100, 200, 120), false, 3)\n    end\n  else\n    drawRoundedRect(rx, ry, c.w, c.h, 18, rgb(70, 140, 90), true)\n    drawRoundedRect(rx, ry, c.w, c.h, 18, rgba(0, 0, 0, 100), false, 2)\n    drawCircle(0, 0, 16, rgba(255, 255, 255, 35), true)\n    drawArc(0, 0, 24, 0.3, 2.4, rgba(255, 255, 255, 25), false, 3)\n    drawArc(0, 0, 18, -1.0, 1.0, rgba(255, 255, 255, 40), false, 2)\n  end\n\n  popTransform()\nend\n\nlocal function drawPrompt(p)\n  drawRoundedRect(p.x - 4, p.y - 4, p.w + 8, p.h + 8, 14, rgba(0, 0, 0, 60), true)\n  drawRoundedRect(p.x, p.y, p.w, p.h, 12, rgb(255, 255, 240), true)\n  drawRoundedRect(p.x, p.y, p.w, p.h, 12, rgba(0, 0, 0, 80), false, 2)\n  local twEs, thEs = measureText(p.es, 20)\n  local twEn, thEn = measureText(p.en, 14)\n  drawText(p.es, p.x + (p.w - twEs) / 2, p.y + 14, \"#305030\", 20, \"monospace\")\n  drawText(\"(\" .. p.en .. \")\", p.x + (p.w - twEn) / 2, p.y + 14 + thEs + 4, \"#608060\", 14, \"monospace\")\n\n  for _, btn in ipairs(p.buttons) do\n    local bg = rgb(220, 240, 220)\n    if btn.key == \"si\" then bg = rgb(200, 240, 210) else bg = rgb(240, 210, 210) end\n    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 10, bg, true)\n    drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 10, rgba(0, 0, 0, 70), false, 2)\n    local bt = btn.labelEs .. \" (\" .. btn.labelEn .. \")\"\n    local btw, bth = measureText(bt, 18)\n    drawText(bt, btn.x + (btn.w - btw) / 2, btn.y + (btn.h - bth) / 2, \"#203820\", 18, \"monospace\")\n  end\n\n  if p.result ~= nil then\n    if p.result == true then\n      local cx = p.x + p.w - 26\n      local cy = p.y + 26\n      drawCircle(cx, cy, 12, rgb(40, 170, 80), true)\n      drawCircle(cx, cy, 12, rgba(0, 0, 0, 90), false, 2)\n      drawLine(cx - 6, cy, cx - 1, cy + 5, \"#FFFFFF\", 3)\n      drawLine(cx - 1, cy + 5, cx + 7, cy - 5, \"#FFFFFF\", 3)\n    else\n      local cx = p.x + p.w - 26\n      local cy = p.y + 26\n      drawCircle(cx, cy, 12, rgb(200, 60, 60), true)\n      drawCircle(cx, cy, 12, rgba(0, 0, 0, 90), false, 2)\n      drawLine(cx - 6, cy - 6, cx + 6, cy + 6, \"#FFFFFF\", 3)\n      drawLine(cx + 6, cy - 6, cx - 6, cy + 6, \"#FFFFFF\", 3)\n    end\n  end\nend\n\nlocal function drawSparkles()\n  setBlendMode(\"add\")\n  for _, p in ipairs(sparkles) do\n    local a = 1 - (p.age / p.life)\n    local col = p.color\n    drawCircle(p.x, p.y, p.size, rgba(255, 255, 255, math.floor(255 * a)), true)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawEndOverlay()\n  local msg = endState == \"win\" and \"¡Gran memoria!\" or \"Inténtalo de nuevo.\"\n  local hint = endState == \"win\" and \"(Great memory!)\" or \"(Try again.)\"\n  drawRect(0, 0, screenW, screenH, rgba(0, 0, 0, 160), true)\n  local tw, th = measureText(msg, 36)\n  local twh, thh = measureText(hint, 18)\n  drawText(msg, (screenW - tw) / 2, screenH * 0.35, \"#FFFFFF\", 36, \"monospace\")\n  drawText(hint, (screenW - twh) / 2, screenH * 0.35 + th + 6, \"#C0FFC0\", 18, \"monospace\")\n  local info = \"Aciertos: \" .. tostring(matches) .. \"/3  •  Respuestas correctas: \" .. tostring(correctAnswers) .. \"/3  •  Movimientos: \" .. tostring(moves) .. \"/\" .. tostring(maxMoves)\n  local tiw, tih = measureText(info, 16)\n  drawText(info, (screenW - tiw) / 2, screenH * 0.35 + th + 36, \"#FFFFFF\", 16, \"monospace\")\nend\n\nfunction draw()\n  drawBackground()\n  drawHeader()\n\n  -- Table area outline\n  drawRoundedRect(16, uiTop - 8, screenW - 32, screenH - uiTop - 16, 16, rgba(0, 0, 0, 60), false, 2)\n\n  -- Draw cards\n  for _, c in ipairs(cards) do\n    drawCard(c)\n  end\n\n  -- Prompt\n  if activePrompt then\n    drawPrompt(activePrompt)\n  end\n\n  -- Sparkles\n  drawSparkles()\n\n  -- End overlay\n  if endState ~= nil then\n    drawEndOverlay()\n  end\nend",
      "id": "game_3_friend_stone_memory",
      "trigger_id": "npc_2_sofia",
      "trigger_type": "npc",
      "related_quest_id": "quest_13_amistad_en_el_parque"
    },
    {
      "name": {
        "native_language": "Gloria's Thirst",
        "target_language": "La sed de Gloria"
      },
      "description": {
        "native_language": "Fill in the missing word to help Gloria ask for water politely.",
        "target_language": "Completa la palabra que falta para ayudar a Gloria a pedir agua con cortesía."
      },
      "language_level": "A0",
      "target_vocabulary": [
        {
          "native_language": "water",
          "target_language": "agua"
        },
        {
          "native_language": "bottle",
          "target_language": "botella"
        },
        {
          "native_language": "I want",
          "target_language": "quiero"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Nouns: agua, botella",
          "target_language": "Sustantivos: agua, botella"
        },
        {
          "native_language": "Imperative basics for requests: Por favor (optional politeness)",
          "target_language": "Básicos del imperativo para pedir: Por favor (cortesía opcional)"
        }
      ],
      "game_prompt": "Game: Fill-the-blank at the fountain.\nMechanics:\n- Show Gloria (a simple stick figure next to a blue fountain shape). Display a sentence with a blank and 3 floating word choices. Player clicks the correct Spanish word to complete the sentence.\n- 3 rounds; choices shuffle each time.\nVisual design:\n- Blue fountain: stacked semicircles. Word choices: pill-shaped buttons.\nEducational content (sentences and options):\n- Round 1: Sentence: {\"native_language\":\"I want ____.\",\"target_language\":\"Quiero ____.\"} Options (Spanish): 'agua' (correct), 'botella', 'calle' (distractor from nearby quests).\n- Round 2: Sentence: {\"native_language\":\"A bottle of water, please.\",\"target_language\":\"Una botella de agua, por favor.\"} Task: click the word 'botella' when highlighted blanks cycle across the sentence.\n- Round 3: Sentence: {\"native_language\":\"I want a bottle.\",\"target_language\":\"Quiero una botella.\"} Options: 'quiero' (correct missing at start with gap), 'agua', 'parque'. The gap is at the start; user selects 'quiero' to fill it.\n- Feedback/UI:\n  - {\"native_language\":\"Choose the correct word\",\"target_language\":\"Elige la palabra correcta\"}\n  - {\"native_language\":\"Correct!\",\"target_language\":\"¡Correcto!\"}\n  - {\"native_language\":\"Not this one\",\"target_language\":\"Esta no\"}\n  - {\"native_language\":\"Next\",\"target_language\":\"Siguiente\"}\nWin/Lose:\n- Win by completing all 3 sentences with ≤2 mistakes. Lose if 3 mistakes occur; show {\"native_language\":\"Let's try again.\",\"target_language\":\"Vamos a intentarlo de nuevo.\"}\nAnimations:\n- Water drops fall gently from the fountain; correct word button pulses green, wrong pulses red.",
      "skill_points": 12,
      "lua_code": "local state = \"play\"\nlocal roundIndex = 1\nlocal correctCount = 0\nlocal mistakes = 0\nlocal t = 0\n\nlocal rounds = {}\nlocal buttons = {}\nlocal lastClickedButton = nil\nlocal pulse = {active=false, t=0, color=rgb(0,0,0), target=nil}\nlocal feedbackText = \"\"\nlocal nextBtn = {x=0,y=0,w=0,h=0}\nlocal sentenceTokens = {}\nlocal highlightIndex = 1\nlocal cycleTimer = 0\nlocal cycleTime = 0.7\nlocal sentenceRect = {x=0,y=0,w=0,h=0}\nlocal flash = {active=false, t=0, ok=false}\nlocal winTimer = 0\nlocal loseTimer = 0\n\nlocal skyTop = rgb(15,30,60)\nlocal skyBottom = rgb(30,60,120)\nlocal uiPanel = rgba(255,255,255,20)\nlocal textColor = rgb(245,245,245)\nlocal accent = rgb(50,180,255)\nlocal accent2 = rgb(30,120,220)\nlocal green = rgb(0,200,110)\nlocal red = rgb(230,60,80)\nlocal gold = rgb(255,200,80)\nlocal pillBase = rgb(255,255,255)\nlocal pillText = rgb(30,40,60)\nlocal pillShadow = rgba(0,0,0,60)\n\nlocal fontTitle = 30\nlocal fontLarge = 28\nlocal fontMedium = 22\nlocal fontSmall = 16\n\nlocal drops = {}\nlocal fountain = {x=0,y=0,w=0,h=0}\n\nlocal function shuffle(a)\n  for i=#a,2,-1 do\n    local j = randomInt(1,i)\n    a[i],a[j] = a[j],a[i]\n  end\nend\n\nlocal function pointInRect(px,py,rx,ry,rw,rh)\n  return px>=rx and px<=rx+rw and py>=ry and py<=ry+rh\nend\n\nlocal function sanitizeWord(w)\n  w = string.lower(w)\n  w = string.gsub(w,\"[%.,;:!%?]\",\"\")\n  return w\nend\n\nlocal function setNextButton()\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  local label = \"Siguiente\"\n  local tw, th = measureText(label, fontMedium)\n  local padX, padY = 24, 12\n  nextBtn.w = tw + padX*2\n  nextBtn.h = th + padY*2\n  nextBtn.x = sw*0.5 - nextBtn.w*0.5\n  nextBtn.y = sh - nextBtn.h - 20\nend\n\nlocal function createButtons(options)\n  buttons = {}\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  local padX, padY = 20, 12\n  local gap = 18\n  local totalWidth = 0\n  local widths = {}\n  for i=1,#options do\n    local tw, th = measureText(options[i], fontMedium)\n    local w = tw + padX*2\n    widths[i] = w\n    totalWidth = totalWidth + w\n  end\n  totalWidth = totalWidth + gap*(#options-1)\n  local startX = sw*0.5 - totalWidth*0.5\n  local baseY = sh*0.66\n  for i=1,#options do\n    local w = widths[i]\n    local h = 44\n    local x = startX\n    local phase = random(0, 6.28)\n    startX = startX + w + gap\n    table.insert(buttons, {text=options[i], x=x, y=baseY, w=w, h=h, baseY=baseY, phase=phase})\n  end\nend\n\nlocal function layoutSentenceTokens(sentence, fontSize)\n  sentenceTokens = {}\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  local words = {}\n  for word in string.gmatch(sentence, \"%S+\") do\n    table.insert(words, word)\n  end\n  local spaceW = measureText(\" \", fontSize)\n  local totalW = 0\n  local widths = {}\n  for i=1,#words do\n    local w = measureText(words[i], fontSize)\n    widths[i] = w\n    totalW = totalW + w\n    if i < #words then totalW = totalW + spaceW end\n  end\n  local x = sw*0.5 - totalW*0.5\n  local y = sh*0.45\n  sentenceRect.x = x - 12\n  sentenceRect.y = y - 8\n  sentenceRect.w = totalW + 24\n  local th = select(2, measureText(\"Ay\", fontSize))\n  sentenceRect.h = th + 16\n  for i=1,#words do\n    table.insert(sentenceTokens, {text=words[i], x=x, y=y, w=widths[i], h=th})\n    x = x + widths[i]\n    if i < #words then x = x + spaceW end\n  end\nend\n\nlocal function startRound(i)\n  roundIndex = i\n  state = \"play\"\n  pulse.active = false\n  pulse.t = 0\n  flash.active = false\n  flash.t = 0\n  lastClickedButton = nil\n  if rounds[i].type == \"buttons\" then\n    local opts = {}\n    for _,v in ipairs(rounds[i].options) do table.insert(opts, v) end\n    shuffle(opts)\n    createButtons(opts)\n  elseif rounds[i].type == \"cycle\" then\n    layoutSentenceTokens(rounds[i].sentenceEs, fontLarge)\n    highlightIndex = 1\n    cycleTimer = 0\n  end\nend\n\nlocal function checkAnswerButtons(selected)\n  local correct = sanitizeWord(selected) == sanitizeWord(rounds[roundIndex].correct)\n  if correct then\n    correctCount = correctCount + 1\n    feedbackText = \"¡Correcto!\"\n    pulse.active = true\n    pulse.t = 0\n    pulse.color = green\n  else\n    mistakes = mistakes + 1\n    feedbackText = \"Esta no\"\n    pulse.active = true\n    pulse.t = 0\n    pulse.color = red\n  end\n  state = \"feedback\"\n  setNextButton()\nend\n\nlocal function checkAnswerCycle()\n  local token = sentenceTokens[highlightIndex]\n  local correctTarget = sanitizeWord(rounds[roundIndex].targetWord)\n  local currentWord = sanitizeWord(token.text)\n  local correct = currentWord == correctTarget\n  if correct then\n    correctCount = correctCount + 1\n    feedbackText = \"¡Correcto!\"\n    flash.active = true\n    flash.t = 0\n    flash.ok = true\n    playSound(\"ok\")\n  else\n    mistakes = mistakes + 1\n    feedbackText = \"Esta no\"\n    flash.active = true\n    flash.t = 0\n    flash.ok = false\n    playSound(\"bad\")\n  end\n  state = \"feedback\"\n  setNextButton()\nend\n\nlocal function proceedNext()\n  if mistakes >= 3 then\n    state = \"lose\"\n    loseTimer = 0\n    return\n  end\n  if roundIndex < #rounds then\n    startRound(roundIndex + 1)\n  else\n    if mistakes <= 2 then\n      state = \"win\"\n      winTimer = 0\n    else\n      state = \"lose\"\n      loseTimer = 0\n    end\n  end\nend\n\nlocal function drawPill(x,y,w,h, bg, outline)\n  pushTransform()\n  drawRoundedRect(x+3, y+4, w, h, h*0.5, pillShadow, true)\n  drawRoundedRect(x, y, w, h, h*0.5, bg, true)\n  drawRoundedRect(x, y, w, h, h*0.5, outline, false, 2)\n  popTransform()\nend\n\nlocal function drawButton(btn, isActive, scalePulse, colorPulse)\n  local bob = math.sin(t*2.2 + btn.phase) * 4\n  local cx = btn.x + btn.w*0.5\n  local cy = btn.baseY + bob + btn.h*0.5\n  pushTransform()\n  translate(cx, cy)\n  if isActive and scalePulse then\n    local s = 1.0 + 0.12 * math.sin(math.min(pulse.t*8, math.pi/2))\n    scale(s, s)\n  end\n  translate(-btn.w*0.5, -btn.h*0.5)\n  drawPill(0, 0, btn.w, btn.h, pillBase, rgba(0,0,0,40))\n  if isActive and colorPulse then\n    setBlendMode(\"add\")\n    drawRoundedRect(-4, -4, btn.w+8, btn.h+8, (btn.h+8)*0.5, rgba((colorPulse>>16)&255,(colorPulse>>8)&255,colorPulse&255,40), false, 6)\n    setBlendMode(\"normal\")\n  end\n  local tw, th = measureText(btn.text, fontMedium)\n  drawText(btn.text, btn.w*0.5 - tw*0.5, btn.h*0.5 - th*0.5, pillText, fontMedium, \"sans\")\n  popTransform()\nend\n\nlocal function setupFountain()\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  fountain.w = math.min(sw*0.18, 220)\n  fountain.h = math.min(sh*0.5, 320)\n  fountain.x = sw*0.7 - fountain.w*0.5\n  fountain.y = sh*0.55 - fountain.h*0.5\nend\n\nlocal function spawnDrops(n)\n  drops = {}\n  local cx = fountain.x + fountain.w*0.5\n  local topY = fountain.y - 10\n  for i=1,n do\n    local dx = random(-fountain.w*0.12, fountain.w*0.12)\n    local y = topY + random(-30, 60)\n    local r = random(2,4)\n    local vy = random(50, 90)\n    table.insert(drops, {x=cx+dx, y=y, vy=vy, r=r, phase=random(0,6.28)})\n  end\nend\n\nlocal function drawFountain()\n  local x, y, w, h = fountain.x, fountain.y, fountain.w, fountain.h\n  local cx = x + w*0.5\n  local bowlColor = rgb(80,170,255)\n  local bowlDark = rgb(40,120,210)\n  drawRoundedRect(x+w*0.42, y-40, w*0.16, 40, 10, bowlDark, true)\n  drawEllipse(cx, y-50, w*0.05, 8, bowlColor, true)\n  setBlendMode(\"add\")\n  drawRadialGradient(cx, y-50, 10, rgba(120,200,255,180), rgba(0,0,0,0))\n  setBlendMode(\"normal\")\n  local levels = 3\n  for i=1,levels do\n    local r = w*0.35 + (i-1)*w*0.1\n    local cy = y + (i-1)*h/(levels+2)\n    setClipRect(cx - r, cy - r, r*2, r)\n    drawEllipse(cx, cy, r, r, (i%2==1) and bowlColor or bowlDark, true)\n    clearClip()\n  end\n  drawRoundedRect(x+w*0.25, y+h*0.35, w*0.5, h*0.4, 16, bowlDark, true)\n  drawRoundedRect(x+w*0.15, y+h*0.7, w*0.7, h*0.18, 14, bowlColor, true)\n  drawRoundedRect(x, y+h*0.85, w, h*0.15, 10, bowlDark, true)\nend\n\nlocal function updateDrops(dt)\n  local cx = fountain.x + fountain.w*0.5\n  local topY = fountain.y - 50\n  local bottomY = fountain.y + fountain.h*0.9\n  for _,d in ipairs(drops) do\n    d.y = d.y + d.vy*dt\n    d.x = d.x + math.sin(t*2 + d.phase) * 12 * dt\n    if d.y > bottomY then\n      d.y = topY + random(-10, 10)\n      d.x = cx + random(-fountain.w*0.14, fountain.w*0.14)\n    end\n  end\nend\n\nlocal function drawDrops()\n  setBlendMode(\"add\")\n  for _,d in ipairs(drops) do\n    drawCircle(d.x, d.y, d.r, rgba(140,220,255,160), true)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawGloria()\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  local baseX = sw*0.25\n  local baseY = fountain.y + fountain.h*0.9\n  local headR = 16\n  drawCircle(baseX, baseY - 120, headR, rgb(250,230,200), true)\n  drawLine(baseX, baseY - 104, baseX, baseY - 56, rgb(40,40,50), 3)\n  drawLine(baseX, baseY - 92, baseX - 22, baseY - 70, rgb(40,40,50), 3)\n  drawLine(baseX, baseY - 92, baseX + 22, baseY - 70, rgb(40,40,50), 3)\n  drawLine(baseX, baseY - 56, baseX - 16, baseY - 24, rgb(40,40,50), 3)\n  drawLine(baseX, baseY - 56, baseX + 16, baseY - 24, rgb(40,40,50), 3)\n  drawRoundedRect(baseX - 30, baseY - 18, 60, 10, 5, rgba(0,0,0,20), true)\nend\n\nlocal function drawHeader()\n  local sw = getScreenWidth()\n  local title = \"La sed de Gloria  •  Gloria's Thirst\"\n  local tw, th = measureText(title, fontTitle)\n  drawText(title, sw*0.5 - tw*0.5, 12, textColor, fontTitle, \"sans\")\n  local inst1 = \"Elige la palabra correcta\"\n  local inst2 = \"Choose the correct word\"\n  local w1, _ = measureText(inst1, fontMedium)\n  local w2, _ = measureText(inst2, fontSmall)\n  drawText(inst1, sw*0.5 - w1*0.5, 50, textColor, fontMedium, \"sans\")\n  drawText(inst2, sw*0.5 - w2*0.5, 74, rgba(255,255,255,160), fontSmall, \"sans\")\nend\n\nlocal function drawScore()\n  local sw = getScreenWidth()\n  local s = \"Aciertos: \"..tostring(correctCount)..\"   Errores: \"..tostring(mistakes)..\"/3\"\n  local tw, th = measureText(s, fontMedium)\n  drawRoundedRect(sw - tw - 34, 10, tw+24, th+14, 10, rgba(255,255,255,30), true)\n  drawText(s, sw - tw - 22, 16, textColor, fontMedium, \"sans\")\nend\n\nlocal function drawSentence()\n  local es = rounds[roundIndex].sentenceEs\n  local en = rounds[roundIndex].sentenceEn\n  local sw = getScreenWidth()\n  local esw,_ = measureText(es, fontLarge)\n  drawText(es, sw*0.5 - esw*0.5, 122, textColor, fontLarge, \"sans\")\n  local enw,_ = measureText(en, fontSmall)\n  drawText(en, sw*0.5 - enw*0.5, 152, rgba(255,255,255,160), fontSmall, \"sans\")\nend\n\nlocal function drawVocabulary()\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  local boxW, boxH = 260, 100\n  drawRoundedRect(16, sh - boxH - 16, boxW, boxH, 12, rgba(255,255,255,24), true)\n  drawText(\"Vocabulario / Vocabulary\", 26, sh - boxH - 6 + 20, textColor, fontSmall, \"sans\")\n  drawText(\"agua = water\", 26, sh - boxH - 6 + 40, rgba(255,255,255,200), fontSmall, \"sans\")\n  drawText(\"botella = bottle\", 26, sh - boxH - 6 + 58, rgba(255,255,255,200), fontSmall, \"sans\")\n  drawText(\"quiero = I want\", 26, sh - boxH - 6 + 76, rgba(255,255,255,200), fontSmall, \"sans\")\n  local box2W, box2H = 300, 84\n  drawRoundedRect(16+boxW+12, sh - box2H - 16, box2W, box2H, 12, rgba(255,255,255,24), true)\n  drawText(\"Gramática / Grammar\", 26+boxW+12, sh - box2H - 6 + 20, textColor, fontSmall, \"sans\")\n  drawText(\"Sustantivos: agua, botella\", 26+boxW+12, sh - box2H - 6 + 40, rgba(255,255,255,200), fontSmall, \"sans\")\n  drawText(\"Por favor = politeness\", 26+boxW+12, sh - box2H - 6 + 58, rgba(255,255,255,200), fontSmall, \"sans\")\nend\n\nfunction init()\n  randomSeed(os.time())\n  rounds = {\n    {type=\"buttons\", sentenceEs=\"Quiero ____.\", sentenceEn=\"I want ____.\", options={\"agua\",\"botella\",\"calle\"}, correct=\"agua\"},\n    {type=\"cycle\", sentenceEs=\"Una botella de agua, por favor.\", sentenceEn=\"A bottle of water, please.\", targetWord=\"botella\"},\n    {type=\"buttons\", sentenceEs=\"____ una botella.\", sentenceEn=\"I want a bottle.\", options={\"quiero\",\"agua\",\"parque\"}, correct=\"quiero\"}\n  }\n  setupFountain()\n  spawnDrops(28)\n  createSound(\"ok\", 880, 0.12, 0.45, \"sine\")\n  createSound(\"bad\", 220, 0.18, 0.45, \"sawtooth\")\n  startRound(1)\nend\n\nfunction update(dt)\n  t = t + dt\n  updateDrops(dt)\n  if pulse.active then\n    pulse.t = pulse.t + dt\n    if pulse.t > 1.0 then pulse.active = false end\n  end\n  if flash.active then\n    flash.t = flash.t + dt\n    if flash.t > 0.6 then flash.active = false end\n  end\n  if state == \"play\" and rounds[roundIndex].type == \"cycle\" then\n    cycleTimer = cycleTimer + dt\n    if cycleTimer >= cycleTime then\n      cycleTimer = cycleTimer - cycleTime\n      highlightIndex = highlightIndex + 1\n      if highlightIndex > #sentenceTokens then highlightIndex = 1 end\n    end\n  end\n  if state == \"win\" then\n    winTimer = winTimer + dt\n    if winTimer > 2.0 then\n      halt(2)\n    end\n  elseif state == \"lose\" then\n    loseTimer = loseTimer + dt\n    if loseTimer > 2.0 then\n      halt(1)\n    end\n  end\n\n  if isMouseJustPressed() then\n    local mx, my = getMouseX(), getMouseY()\n    if state == \"play\" then\n      if rounds[roundIndex].type == \"buttons\" then\n        for _,btn in ipairs(buttons) do\n          local bob = math.sin(t*2.2 + btn.phase) * 4\n          local rectX = btn.x\n          local rectY = btn.baseY + bob\n          if pointInRect(mx,my, rectX, rectY, btn.w, btn.h) then\n            lastClickedButton = btn\n            if sanitizeWord(btn.text) == sanitizeWord(rounds[roundIndex].correct) then\n              playSound(\"ok\")\n            else\n              playSound(\"bad\")\n            end\n            checkAnswerButtons(btn.text)\n            break\n          end\n        end\n      else\n        if pointInRect(mx, my, sentenceRect.x, sentenceRect.y, sentenceRect.w, sentenceRect.h) then\n          checkAnswerCycle()\n        end\n      end\n    elseif state == \"feedback\" then\n      if pointInRect(mx,my, nextBtn.x, nextBtn.y, nextBtn.w, nextBtn.h) then\n        proceedNext()\n      end\n    elseif state == \"win\" then\n      halt(2)\n    elseif state == \"lose\" then\n      halt(1)\n    end\n  end\nend\n\nfunction draw()\n  local sw, sh = getScreenWidth(), getScreenHeight()\n  drawGradientRect(0,0,sw,sh, skyTop, skyBottom, true)\n  drawRadialGradient(sw*0.75, sh*0.2, 220, rgba(255,255,255,20), rgba(0,0,0,0))\n  drawHeader()\n  drawScore()\n\n  drawFountain()\n  drawDrops()\n  drawGloria()\n\n  drawRoundedRect(12, 96, sw-24, 120, 12, uiPanel, true)\n  if rounds[roundIndex].type == \"buttons\" then\n    drawSentence()\n    for _,btn in ipairs(buttons) do\n      local isActive = (state==\"feedback\" and lastClickedButton==btn)\n      local colorPulse = (pulse.active and pulse.color) or nil\n      drawButton(btn, isActive, pulse.active and lastClickedButton==btn, colorPulse)\n    end\n  else\n    local es, en = rounds[roundIndex].sentenceEs, rounds[roundIndex].sentenceEn\n    local highlightClr = rgba(255,230,140,160)\n    local wordClr = textColor\n    local underscoreClr = gold\n    for i,tk in ipairs(sentenceTokens) do\n      if i == highlightIndex and state==\"play\" then\n        drawRoundedRect(tk.x-6, tk.y-4, tk.w+12, tk.h+8, 10, rgba(255,255,255,20), true)\n        local underscores = math.max(3, math.floor(tk.w/10))\n        local us = \"\"\n        for u=1,underscores do us = us..\"_\" end\n        local usw, ush = measureText(us, fontLarge)\n        drawText(us, tk.x + tk.w*0.5 - usw*0.5, tk.y + tk.h - 4, underscoreClr, fontLarge, \"sans\")\n      end\n      local alpha = 255\n      if i == highlightIndex and state==\"play\" then alpha = 170 end\n      drawText(tk.text, tk.x, tk.y, rgba(255,255,255,alpha), fontLarge, \"sans\")\n    end\n    drawRoundedRect(sentenceRect.x, sentenceRect.y, sentenceRect.w, sentenceRect.h, 12, rgba(255,255,255,16), false, 2)\n    local hint = \"Haz clic cuando 'botella' esté resaltada • Click when 'botella' is highlighted\"\n    local hw,_ = measureText(hint, fontSmall)\n    drawText(hint, sw*0.5 - hw*0.5, sentenceRect.y + sentenceRect.h + 8, rgba(255,255,255,180), fontSmall, \"sans\")\n    if state==\"feedback\" then\n      local clr = flash.ok and rgba(0,200,110,120) or rgba(230,60,80,120)\n      local alpha = math.floor(120 * math.max(0, 1 - flash.t/0.6))\n      drawRoundedRect(sentenceRect.x-6, sentenceRect.y-6, sentenceRect.w+12, sentenceRect.h+12, 14, rgba((clr>>16)&255,(clr>>8)&255,clr&255,alpha), true)\n    else\n      local tk = sentenceTokens[highlightIndex]\n      drawRoundedRect(tk.x-6, tk.y-4, tk.w+12, tk.h+8, 10, highlightClr, false, 2)\n    end\n  end\n\n  if state == \"feedback\" then\n    local msg = feedbackText\n    local mw,_ = measureText(msg, fontLarge)\n    drawText(msg, sw*0.5 - mw*0.5, sh*0.78, (feedbackText==\"¡Correcto!\") and green or red, fontLarge, \"sans\")\n    drawPill(nextBtn.x, nextBtn.y, nextBtn.w, nextBtn.h, pillBase, rgba(0,0,0,40))\n    local tw, th = measureText(\"Siguiente\", fontMedium)\n    drawText(\"Siguiente\", nextBtn.x + nextBtn.w*0.5 - tw*0.5, nextBtn.y + nextBtn.h*0.5 - th*0.5, pillText, fontMedium, \"sans\")\n  end\n\n  if state == \"win\" then\n    local msg = \"¡Ganaste! • You win\"\n    local mw,_ = measureText(msg, fontTitle)\n    setBlendMode(\"add\")\n    drawRadialGradient(sw*0.5, sh*0.4, 200, rgba(120,220,120,180), rgba(0,0,0,0))\n    setBlendMode(\"normal\")\n    drawText(msg, sw*0.5 - mw*0.5, sh*0.4, green, fontTitle, \"sans\")\n  elseif state == \"lose\" then\n    local msg = \"Vamos a intentarlo de nuevo. • Let's try again.\"\n    local mw,_ = measureText(msg, fontMedium)\n    drawText(\"Juego terminado\", sw*0.5 - measureText(\"Juego terminado\", fontTitle)*0.5, sh*0.4 - 30, red, fontTitle, \"sans\")\n    drawText(msg, sw*0.5 - mw*0.5, sh*0.4 + 10, rgba(255,255,255,220), fontMedium, \"sans\")\n  end\n\n  drawVocabulary()\nend",
      "id": "game_4_gloria_s_thirst",
      "trigger_id": "npc_3_gloria",
      "trigger_type": "npc",
      "related_quest_id": "quest_22_gloria_s_request"
    },
    {
      "name": {
        "native_language": "Sweet Fruit Pop",
        "target_language": "Explosión de fruta dulce"
      },
      "description": {
        "native_language": "Pop the bubbles that match the customer's buy requests at the fruit stand.",
        "target_language": "Revienta las burbujas que coinciden con las compras del cliente en el puesto de fruta."
      },
      "language_level": "A0+",
      "target_vocabulary": [
        {
          "native_language": "banana",
          "target_language": "plátano"
        },
        {
          "native_language": "fruit",
          "target_language": "fruta"
        },
        {
          "native_language": "buy",
          "target_language": "comprar"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Transactions: comprar (to buy)",
          "target_language": "Transacciones: comprar"
        },
        {
          "native_language": "Imperative: Compra...",
          "target_language": "Imperativo: Compra..."
        }
      ],
      "game_prompt": "Game: Bubble-pop at the fruit stand.\nMechanics:\n- A customer speech bubble shows a short bilingual request. Bubbles float up with Spanish words; pop the ones that fulfill the request. Each round lasts ~15 seconds.\n- Requests escalate slightly from single-word to short imperative phrases.\nVisual design:\n- Background: yellow-orange stall awning (triangles). Bubbles: translucent circles with Spanish words.\nEducational content (requests and valid targets):\n- Requests (randomized):\n  - {\"native_language\":\"Buy fruit.\",\"target_language\":\"Compra fruta.\"} -> valid pops: 'fruta'.\n  - {\"native_language\":\"Buy a banana.\",\"target_language\":\"Compra un plátano.\"} -> valid pops: 'plátano'.\n  - {\"native_language\":\"I want to buy fruit.\",\"target_language\":\"Quiero comprar fruta.\"} -> valid pops: 'comprar' and 'fruta' (both must be popped in time).\n- Bubble word pool (Spanish): 'plátano', 'fruta', 'comprar', plus distractors 'calle', 'parque'.\n- UI text:\n  - {\"native_language\":\"Pop the correct words\",\"target_language\":\"Revienta las palabras correctas\"}\n  - {\"native_language\":\"Round\",\"target_language\":\"Ronda\"}\n  - {\"native_language\":\"Time\",\"target_language\":\"Tiempo\"}\n  - {\"native_language\":\"Well done!\",\"target_language\":\"¡Bien hecho!\"}\nWin/Lose:\n- 5 rounds. Score 1 point per correct pop; -1 for wrong pop. Need 6 points to win. If score <6 at the end, show {\"native_language\":\"Order not complete.\",\"target_language\":\"Pedido incompleto.\"}\nAnimations:\n- Bubbles wobble gently; popping triggers a splash ring effect; customer bubble nods when round is cleared.",
      "skill_points": 17,
      "lua_code": "local w, h\nlocal score = 0\nlocal round = 1\nlocal totalRounds = 5\nlocal roundTime = 15.0\nlocal timeLeft = roundTime\nlocal gameOver = false\nlocal endTimer = 0\nlocal endWin = false\n\nlocal bubbles = {}\nlocal effects = {}\nlocal floatTexts = {}\n\nlocal requests = {}\nlocal roundPlan = {}\n\nlocal wordPool = {\"plátano\", \"fruta\", \"comprar\", \"calle\", \"parque\"}\nlocal targetColors = {\n  [\"plátano\"] = rgba(255, 230, 120, 180),\n  [\"fruta\"]   = rgba(255, 140, 180, 180),\n  [\"comprar\"] = rgba(120, 220, 220, 180)\n}\nlocal distractorColor = rgba(200, 200, 220, 150)\n\nlocal outlineColor = rgba(255, 255, 255, 180)\nlocal goodRingColor = rgba(60, 220, 140, 220)\nlocal badRingColor = rgba(240, 70, 90, 220)\n\nlocal nodTimer = 0\nlocal clearedShown = false\nlocal clearedFlashTimer = 0\nlocal requiredSet = {}\nlocal countedSet = {}\nlocal reqCurrent = nil\n\nlocal bannerTitle = \"Revienta las palabras correctas\"\nlocal bannerSubtitle = \"(Pop the correct words)\"\nlocal uiRound = \"Ronda\"\nlocal uiTime = \"Tiempo\"\nlocal winText = \"¡Bien hecho!\"\nlocal loseText = \"Pedido incompleto.\"\nlocal reqBubbleX, reqBubbleY, reqBubbleW, reqBubbleH = 0,0,0,0\n\nfunction init()\n  w = getScreenWidth()\n  h = getScreenHeight()\n  randomSeed(os.time())\n\n  createSound(\"good\", 880, 0.08, 0.5, \"sine\")\n  createSound(\"bad\", 220, 0.12, 0.5, \"square\")\n  createSound(\"tick\", 1000, 0.02, 0.3, \"triangle\")\n\n  requests = {\n    {en = \"Buy fruit.\", es = \"Compra fruta.\", targets = {\"fruta\"}},\n    {en = \"Buy a banana.\", es = \"Compra un plátano.\", targets = {\"plátano\"}},\n    {en = \"I want to buy fruit.\", es = \"Quiero comprar fruta.\", targets = {\"comprar\", \"fruta\"}}\n  }\n\n  roundPlan = {\n    randomInt(1,2),\n    randomInt(1,2),\n    3,\n    randomInt(1,3),\n    randomInt(1,3)\n  }\n\n  startRound(1)\nend\n\nlocal function pickColorForWord(word)\n  local c = targetColors[word]\n  if c then return c else return distractorColor end\nend\n\nlocal function spawnBubble(word, delay)\n  local r = random(28, 40)\n  local x = random(r + 10, w - r - 10)\n  local y = random(h * 0.55, h * 0.90)\n  local speedY = random(24, 48)\n  local wobbleAmp = random(6, 14)\n  local wobbleFreq = random(0.8, 1.4)\n  local phase = random(0, math.pi * 2)\n  local c = pickColorForWord(word)\n  table.insert(bubbles, {\n    word = word,\n    x = x, y = y,\n    baseX = x,\n    r = r,\n    speedY = speedY,\n    wobbleAmp = wobbleAmp,\n    wobbleFreq = wobbleFreq,\n    phase = phase,\n    color = c,\n    active = false,\n    spawnDelay = delay or 0,\n    popped = false,\n    popTime = 0\n  })\nend\n\nlocal function ensureTargets(targets)\n  for i=1,#targets do\n    spawnBubble(targets[i], random(0, 3))\n  end\nend\n\nlocal function fillWithRandom(total)\n  while #bubbles < total do\n    local word = wordPool[randomInt(1, #wordPool)]\n    spawnBubble(word, random(0, 4))\n  end\nend\n\nlocal function resetRoundState(req)\n  bubbles = {}\n  effects = {}\n  floatTexts = {}\n  requiredSet = {}\n  countedSet = {}\n  for i=1,#req.targets do\n    requiredSet[req.targets[i]] = true\n  end\n  clearedShown = false\n  clearedFlashTimer = 0\n  nodTimer = 0\nend\n\nfunction startRound(rn)\n  round = rn\n  timeLeft = roundTime\n  reqCurrent = requests[roundPlan[rn]]\n  resetRoundState(reqCurrent)\n  ensureTargets(reqCurrent.targets)\n  local baseCount = 6\n  local total = math.max(#bubbles + 3, baseCount + randomInt(0,1))\n  fillWithRandom(total)\nend\n\nlocal function allTargetsPopped()\n  for t,_ in pairs(requiredSet) do\n    if not countedSet[t] then return false end\n  end\n  return true\nend\n\nlocal function addEffect(x, y, good)\n  table.insert(effects, {\n    x = x, y = y, age = 0, good = good, maxAge = 0.5\n  })\nend\n\nlocal function addFloatText(text, x, y, color)\n  table.insert(floatTexts, {\n    text = text, x = x, y = y, vy = -24, age = 0, life = 0.8, color = color\n  })\nend\n\nlocal function playTickOnSecond(dt)\n  local prev = math.ceil(timeLeft + dt)\n  local curr = math.ceil(timeLeft)\n  if curr < prev and curr <= 5 and curr > 0 then\n    playSound(\"tick\")\n  end\nend\n\nlocal function tryPopAt(mx, my)\n  local hitIndex = nil\n  local hitDist = 1e9\n  for i = #bubbles, 1, -1 do\n    local b = bubbles[i]\n    if b.active and not b.popped then\n      local dx = mx - b.x\n      local dy = my - b.y\n      local d2 = dx*dx + dy*dy\n      if d2 <= (b.r * b.r) then\n        local d = math.sqrt(d2)\n        if d < hitDist then\n          hitDist = d\n          hitIndex = i\n        end\n      end\n    end\n  end\n  if hitIndex then\n    local b = bubbles[hitIndex]\n    b.popped = true\n    b.popTime = 0\n    local good = requiredSet[b.word] and not countedSet[b.word]\n    addEffect(b.x, b.y, good)\n    if good then\n      score = score + 1\n      countedSet[b.word] = true\n      addFloatText(\"+1\", b.x, b.y - b.r, rgba(40, 230, 140, 255))\n      playSound(\"good\")\n      if allTargetsPopped() and not clearedShown then\n        clearedShown = true\n        clearedFlashTimer = 1.0\n        nodTimer = 0.7\n      end\n    else\n      score = score - 1\n      addFloatText(\"-1\", b.x, b.y - b.r, rgba(250, 90, 90, 255))\n      playSound(\"bad\")\n    end\n  end\nend\n\nlocal function spawnOccasional(dt)\n  if timeLeft <= 2.0 then return end\n  local activeCount = 0\n  for i=1,#bubbles do\n    if bubbles[i].active and not bubbles[i].popped then activeCount = activeCount + 1 end\n  end\n  if activeCount < 5 and random() < 0.02 then\n    local word\n    if random() < 0.35 then\n      word = reqCurrent.targets[randomInt(1, #reqCurrent.targets)]\n    else\n      word = wordPool[randomInt(1, #wordPool)]\n    end\n    spawnBubble(word, 0)\n    bubbles[#bubbles].active = true\n  end\nend\n\nfunction update(dt)\n  if gameOver then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      if endWin then halt(2) else halt(1) end\n    end\n    return\n  end\n\n  playTickOnSecond(dt)\n  timeLeft = math.max(0, timeLeft - dt)\n\n  if isMouseJustPressed() then\n    tryPopAt(getMouseX(), getMouseY())\n  end\n\n  for i=#bubbles,1,-1 do\n    local b = bubbles[i]\n    if not b.active then\n      b.spawnDelay = b.spawnDelay - dt\n      if b.spawnDelay <= 0 then b.active = true end\n    else\n      if not b.popped then\n        local t = getTime()\n        b.y = b.y - b.speedY * dt\n        b.x = b.baseX + math.sin(t * b.wobbleFreq + b.phase) * b.wobbleAmp\n        if b.y + b.r < -10 then\n          table.remove(bubbles, i)\n        end\n      else\n        b.popTime = b.popTime + dt\n        b.r = b.r * (1 - dt * 4.5)\n        if b.popTime >= 0.3 or b.r < 5 then\n          table.remove(bubbles, i)\n        end\n      end\n    end\n  end\n\n  for i=#effects,1,-1 do\n    local e = effects[i]\n    e.age = e.age + dt\n    if e.age >= e.maxAge then\n      table.remove(effects, i)\n    end\n  end\n\n  for i=#floatTexts,1,-1 do\n    local f = floatTexts[i]\n    f.age = f.age + dt\n    f.y = f.y + f.vy * dt\n    if f.age >= f.life then\n      table.remove(floatTexts, i)\n    end\n  end\n\n  if nodTimer > 0 then\n    nodTimer = math.max(0, nodTimer - dt)\n  end\n  if clearedFlashTimer > 0 then\n    clearedFlashTimer = math.max(0, clearedFlashTimer - dt)\n  end\n\n  spawnOccasional(dt)\n\n  if timeLeft <= 0 then\n    if round < totalRounds then\n      startRound(round + 1)\n    else\n      endWin = score >= 6\n      gameOver = true\n      endTimer = 3.0\n    end\n  end\nend\n\nlocal function drawBackground()\n  clear(rgb(250, 245, 230))\n  local awH = math.max(100, math.floor(h * 0.18))\n  drawGradientRect(0, 0, w, awH, rgb(255, 200, 90), rgb(255, 150, 60), true)\n  local scallops = math.floor(w / 50)\n  local triW = w / scallops\n  local yTop = awH - 1\n  local yBottom = awH + 20\n  for i=0,scallops do\n    local x0 = i * triW\n    drawTriangle(x0, yTop, x0 + triW/2, yBottom, x0 + triW, yTop, rgba(255, 230, 120, 255), true)\n  end\n  drawRect(0, awH + 20, w, 6, rgba(200, 120, 40, 200), true)\n  drawRect(0, h - 40, w, 40, rgba(255, 220, 180, 255), true)\nend\n\nlocal function drawSpeechBubble(textES, textEN)\n  local pad = 16\n  local bw = math.min(w * 0.8, 520)\n  local bh = 86\n  local bx = 20\n  local by = 22\n  reqBubbleX, reqBubbleY, reqBubbleW, reqBubbleH = bx, by, bw, bh\n  local scaleY = 1.0\n  if nodTimer > 0 then\n    local p = (1 - nodTimer / 0.7)\n    scaleY = 1.0 + math.sin(p * math.pi) * 0.06\n  end\n  pushTransform()\n  translate(bx + bw/2, by + bh/2)\n  scale(1.0, scaleY)\n  translate(-(bx + bw/2), -(by + bh/2))\n  drawRoundedRect(bx, by, bw, bh, 16, rgba(255, 255, 255, 230), true)\n  drawRoundedRect(bx, by, bw, bh, 16, rgba(255, 180, 60, 255), false, 2)\n  local tx = bx + pad\n  local ty = by + pad\n  drawText(textES, tx, ty, rgb(60, 50, 30), 22, \"monospace\")\n  drawText(\"(\"..textEN..\")\", tx, ty + 28, rgba(80,80,80,255), 16, \"monospace\")\n  popTransform()\n  local tailX = bx + 36\n  drawTriangle(tailX, by + bh, tailX + 18, by + bh, tailX + 6, by + bh + 16, rgba(255,255,255,230), true)\n  drawTriangle(tailX, by + bh, tailX + 18, by + bh, tailX + 6, by + bh + 16, rgba(255,180,60,255), false, 2)\n  if clearedFlashTimer > 0 then\n    local alpha = math.floor(255 * (clearedFlashTimer))\n    drawText(winText, bx + bw - 150, by + 10, rgba(60, 180, 90, alpha), 20, \"monospace\")\n  end\nend\n\nlocal function drawHUD()\n  local titleX = w * 0.5\n  drawText(bannerTitle, titleX - 160, 8 + 100, rgb(80, 60, 40), 18, \"monospace\")\n  drawText(bannerSubtitle, titleX - 110, 8 + 120, rgba(90, 90, 90, 255), 14, \"monospace\")\n\n  local boxW = 130\n  local boxH = 60\n  local bx = w - boxW - 16\n  local by = 16\n  drawRoundedRect(bx, by, boxW, boxH, 10, rgba(255,255,255,230), true)\n  drawRoundedRect(bx, by, boxW, boxH, 10, rgba(200,150,90,255), false, 2)\n  drawText(uiRound..\": \"..round..\"/\"..totalRounds, bx + 10, by + 8, rgb(70,50,30), 16, \"monospace\")\n  drawText(\"Puntos: \"..score, bx + 10, by + 28, rgb(70,50,30), 16, \"monospace\")\n\n  local timeX = w - boxW - 16\n  local timeY = by + boxH + 8\n  local tw = boxW\n  local th = 50\n  drawRoundedRect(timeX, timeY, tw, th, 10, rgba(255,255,255,230), true)\n  drawRoundedRect(timeX, timeY, tw, th, 10, rgba(200,150,90,255), false, 2)\n  drawText(uiTime..\": \"..math.ceil(timeLeft)..\"s\", timeX + 10, timeY + 8, rgb(70,50,30), 16, \"monospace\")\n  local barW = tw - 20\n  local frac = timeLeft / roundTime\n  local bw = math.max(0, math.floor(barW * frac))\n  drawRect(timeX + 10, timeY + 28, barW, 12, rgba(220, 200, 180, 180), true)\n  drawRect(timeX + 10, timeY + 28, bw, 12, rgba(90, 200, 140, 220), true)\n\n  local foot = \"Vocabulario: plátano, fruta, comprar   |   Gramática: Imperativo: Compra... • Transacciones: comprar\"\n  drawText(foot, 18, h - 28, rgba(70,70,70,255), 14, \"monospace\")\nend\n\nlocal function drawBubbles()\n  for i=1,#bubbles do\n    local b = bubbles[i]\n    if b.active then\n      local c = b.color\n      local outline = outlineColor\n      if b.popped then\n        c = rgba(200, 200, 200, 120)\n        outline = rgba(160, 160, 160, 160)\n      end\n      setBlendMode(\"normal\")\n      drawCircle(b.x, b.y, b.r, c, true)\n      drawCircle(b.x, b.y, b.r, rgba(255,255,255,200), false, 2)\n      drawCircle(b.x - b.r*0.3, b.y - b.r*0.3, b.r*0.15, rgba(255,255,255,120), true)\n      local tw, th = measureText(b.word, 18)\n      drawText(b.word, b.x - tw/2, b.y - th/2, rgb(40,40,40), 18, \"monospace\")\n    end\n  end\nend\n\nlocal function drawEffects()\n  for i=1,#effects do\n    local e = effects[i]\n    local t = e.age / e.maxAge\n    local r = 10 + 80 * t\n    local alpha = math.floor((1 - t) * 200)\n    local col = e.good and rgba(60, 220, 140, alpha) or rgba(240, 70, 90, alpha)\n    setBlendMode(\"add\")\n    drawCircle(e.x, e.y, r, col, false, 3)\n    drawCircle(e.x, e.y, r * 0.65, col, false, 2)\n  end\n  setBlendMode(\"normal\")\n  for i=1,#floatTexts do\n    local f = floatTexts[i]\n    drawText(f.text, f.x - 8, f.y, f.color, 20, \"monospace\")\n  end\nend\n\nlocal function drawEndOverlay()\n  local overlay = rgba(0, 0, 0, 140)\n  drawRect(0, 0, w, h, overlay, true)\n  local msg = endWin and winText or loseText\n  local msgEN = endWin and \"(Well done!)\" or \"(Order not complete.)\"\n  local tw, th = measureText(msg, 36)\n  drawText(msg, (w - tw)/2, h*0.4, rgba(255,255,255,255), 36, \"monospace\")\n  local tw2, th2 = measureText(msgEN, 20)\n  drawText(msgEN, (w - tw2)/2, h*0.4 + th + 8, rgba(230,230,230,255), 20, \"monospace\")\n  local tw3, th3 = measureText(\"Puntuación: \"..score, 22)\n  drawText(\"Puntuación: \"..score, (w - tw3)/2, h*0.4 + th + 8 + th2 + 10, rgba(230,230,230,255), 22, \"monospace\")\nend\n\nfunction draw()\n  drawBackground()\n  drawSpeechBubble(reqCurrent.es, reqCurrent.en)\n  drawBubbles()\n  drawEffects()\n  drawHUD()\n  if gameOver then\n    drawEndOverlay()\n  end\nend",
      "id": "game_5_sweet_fruit_pop",
      "trigger_id": "npc_9_carlos",
      "trigger_type": "npc",
      "related_quest_id": "quest_23_sweet_fruit_delivery"
    },
    {
      "name": {
        "native_language": "Welcome Gift Builder",
        "target_language": "Creador del regalo de bienvenida"
      },
      "description": {
        "native_language": "Arrange words to form simple questions and commands about a gift for a friend.",
        "target_language": "Ordena palabras para formar preguntas y mandatos sencillos sobre un regalo para un amigo."
      },
      "language_level": "A0",
      "target_vocabulary": [
        {
          "native_language": "apple",
          "target_language": "manzana"
        },
        {
          "native_language": "gift",
          "target_language": "regalo"
        },
        {
          "native_language": "friend",
          "target_language": "amigo"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Imperative: Da ...",
          "target_language": "Imperativo: Da ..."
        },
        {
          "native_language": "Yes/No question with ¿...?",
          "target_language": "Pregunta de sí/no con ¿...?"
        }
      ],
      "game_prompt": "Game: Word-order jigsaw.\nMechanics:\n- Drag word tiles to build the sentence shown in a bilingual prompt. Tiles snap into a row at the bottom. Punctuation is also a draggable tile when needed.\n- Two sentences: one question and one command.\nVisual design:\n- Welcome fountain plaza: pale blue circle. Word tiles: rounded rectangles with Spanish words in bold and tiny English hint below.\nEducational content (prompts and tiles):\n- Sentence 1 (question):\n  - Prompt: {\"native_language\":\"Is it a gift?\",\"target_language\":\"¿Es un regalo?\"}\n  - Tiles shown (Spanish): '¿', 'Es', 'un', 'regalo', '?'. Correct order: ¿ Es un regalo ? (engine can ignore extra spaces when rendering).\n- Sentence 2 (command):\n  - Prompt: {\"native_language\":\"Give the apple to the friend.\",\"target_language\":\"Da la manzana al amigo.\"}\n  - Tiles (Spanish): 'Da', 'la', 'manzana', 'al', 'amigo', '.' Correct order as above.\n- Vocabulary labels (reference sidebar):\n  - {\"native_language\":\"apple\",\"target_language\":\"manzana\"}\n  - {\"native_language\":\"gift\",\"target_language\":\"regalo\"}\n  - {\"native_language\":\"friend\",\"target_language\":\"amigo\"}\n- UI text:\n  - {\"native_language\":\"Drag to arrange\",\"target_language\":\"Arrastra para ordenar\"}\n  - {\"native_language\":\"Check\",\"target_language\":\"Comprobar\"}\n  - {\"native_language\":\"Correct!\",\"target_language\":\"¡Correcto!\"}\n  - {\"native_language\":\"Try again\",\"target_language\":\"Inténtalo de nuevo\"}\nWin/Lose:\n- Win by completing both sentences with ≤2 total mistakes. Otherwise show {\"native_language\":\"Keep practicing!\",\"target_language\":\"¡Sigue practicando!\"}\nAnimations:\n- Tiles gently rotate on pickup; upon correct sentence, tiles glow and confetti dots fall.",
      "skill_points": 12,
      "lua_code": "local screenW, screenH\nlocal sideW = 220\nlocal game = {}\nlocal t = 0\nlocal cursor = {x=0,y=0}\nlocal ui = {}\nlocal colors = {\n  bg1 = \"#E8F6FF\",\n  bg2 = \"#BFE5FF\",\n  plazaInner = \"#CDEBFF\",\n  plazaOuter = \"#A7D4FF\",\n  slot = \"#E6F2FA\",\n  slotOutline = \"#9BC6E6\",\n  tile = \"#FFFFFF\",\n  tileStroke = \"#5BA8D9\",\n  tileText = \"#20455E\",\n  hintText = \"#4A6B80\",\n  btn = \"#2BB673\",\n  btnDisabled = \"#A4C7B5\",\n  btnText = \"#FFFFFF\",\n  warn = \"#FF6B6B\",\n  ok = \"#39E27D\",\n  panel = \"#F6FBFF\",\n  panelStroke = \"#B8DAF0\"\n}\n\nlocal sentences = {\n  {\n    promptNative = \"Is it a gift?\",\n    promptTarget = \"¿Es un regalo?\",\n    tiles = {\"¿\",\"Es\",\"un\",\"regalo\",\"?\"},\n    hints = {\"¿\",\"is\",\"a\",\"gift\",\"?\"},\n    answer = {\"¿\",\"Es\",\"un\",\"regalo\",\"?\"}\n  },\n  {\n    promptNative = \"Give the apple to the friend.\",\n    promptTarget = \"Da la manzana al amigo.\",\n    tiles = {\"Da\",\"la\",\"manzana\",\"al\",\"amigo\",\".\"},\n    hints = {\"Give (imp.)\",\"the\",\"apple\",\"to the\",\"friend\",\".\"},\n    answer = {\"Da\",\"la\",\"manzana\",\"al\",\"amigo\",\".\"}\n  }\n}\n\nlocal vocab = {\n  {native=\"apple\", target=\"manzana\"},\n  {native=\"gift\", target=\"regalo\"},\n  {native=\"friend\", target=\"amigo\"}\n}\n\nlocal grammar = {\n  {native=\"Imperative: Da ...\", target=\"Imperativo: Da ...\"},\n  {native=\"Yes/No question with ¿...?\", target=\"Pregunta de sí/no con ¿...?\"}\n}\n\nlocal function clamp(v,a,b) if v<a then return a elseif v>b then return b else return v end end\nlocal function lerp(a,b,tv) return a + (b-a)*tv end\nlocal function pointInRect(px,py,x,y,w,h) return px>=x and px<=x+w and py>=y and py<=y+h end\n\nlocal function measureTextCentered(text, size, cx, cy, color, font)\n  local w,h = measureText(text, size or 16)\n  drawText(text, cx - w/2, cy - h/2, color or \"#000000\", size or 16, font or \"monospace\")\n  return w,h\nend\n\nlocal function createSounds()\n  createSound(\"sCorrect\", 880, 0.12, 0.5, \"sine\")\n  createSound(\"sCorrect2\", 1320, 0.10, 0.4, \"sine\")\n  createSound(\"sWrong\", 120, 0.20, 0.5, \"square\")\nend\n\nlocal function slotStartX()\n  local margin = 24\n  local playW = screenW - sideW - margin*2\n  local totalW = game.N * game.slotCellW\n  return margin + (playW - totalW)/2\nend\n\nlocal function slotLeft(i)\n  return slotStartX() + (i-1)*game.slotCellW\nend\n\nlocal function slotTop()\n  return screenH - 120\nend\n\nlocal function slotIndexFromX(x)\n  local startX = slotStartX()\n  local i = math.floor((x - startX)/game.slotCellW + 0.5) + 1\n  return clamp(i, 1, game.N)\nend\n\nlocal function insideRowArea(x,y)\n  local sx = slotStartX()\n  local sy = slotTop()\n  local w = game.N * game.slotCellW\n  local h = game.tileH + 20\n  return pointInRect(x,y,sx,sy-10,w,h)\nend\n\nlocal function allSlotsFilled()\n  for i=1,game.N do\n    if not game.slots[i] then return false end\n  end\n  return true\nend\n\nlocal function currentSequence()\n  local seq = {}\n  for i=1,game.N do\n    if not game.slots[i] then return nil end\n    seq[i] = game.slots[i].text\n  end\n  return seq\nend\n\nlocal function sequencesEqual(a,b)\n  if not a or not b then return false end\n  if #a ~= #b then return false end\n  for i=1,#a do\n    if a[i] ~= b[i] then return false end\n  end\n  return true\nend\n\nlocal function spawnConfetti()\n  game.confetti = {}\n  local colorsConf = {\n    rgb(255,99,132), rgb(54,162,235), rgb(255,206,86),\n    rgb(75,192,192), rgb(153,102,255), rgb(255,159,64)\n  }\n  local countPerTile = 12\n  for _,tile in ipairs(game.tiles) do\n    if tile.slot then\n      for k=1,countPerTile do\n        local p = {}\n        p.x = tile.x + tile.w/2 + random(-tile.w/2, tile.w/2)\n        p.y = tile.y + tile.h/2 + random(-tile.h/2, tile.h/2)\n        local angle = random(0, 2*math.pi)\n        local speed = random(50, 180)\n        p.vx = math.cos(angle)*speed\n        p.vy = -math.abs(math.sin(angle))*speed\n        p.life = random(0.9, 1.6)\n        p.maxLife = p.life\n        p.size = random(2,4)\n        p.color = colorsConf[randomInt(1,#colorsConf)]\n        table.insert(game.confetti, p)\n      end\n    end\n  end\nend\n\nlocal function createTilesForSentence(idx)\n  game.tiles = {}\n  game.slots = {}\n  game.N = #sentences[idx].tiles\n  game.tileH = 56\n  game.slotCellW = 150\n  local margin = 24\n  local playW = screenW - sideW - margin*2\n  local centerX = margin + playW/2\n  local topY = 140\n  local rowCount = 2\n  local perRow = math.ceil(game.N/rowCount)\n  local spacingX = playW / (math.max(perRow,1)+1)\n  local spacingY = 76\n  local k = 1\n  for i,word in ipairs(sentences[idx].tiles) do\n    local hint = sentences[idx].hints[i] or \"\"\n    local w = math.max(60, select(1, measureText(word, 28)) + 28)\n    local row = math.floor((k-1)/perRow)\n    local col = (k-1)%perRow\n    local homeX = margin + spacingX*(col+1) + random(-12,12)\n    local homeY = topY + row*spacingY + random(-6,6)\n    local tile = {\n      text = word,\n      hint = hint,\n      x = homeX,\n      y = homeY,\n      tx = homeX,\n      ty = homeY,\n      homeX = homeX,\n      homeY = homeY,\n      w = w,\n      h = game.tileH,\n      angle = 0,\n      targetAngle = 0,\n      dragging = false,\n      slot = nil,\n      pulse = 0\n    }\n    table.insert(game.tiles, tile)\n    k = k + 1\n  end\nend\n\nlocal function placeInSlot(tile, i)\n  local prev = tile.slot\n  if prev == i then\n    tile.tx = slotLeft(i) + (game.slotCellW - tile.w)/2\n    tile.ty = slotTop()\n    return\n  end\n  if prev then\n    game.slots[prev] = nil\n  end\n  local other = game.slots[i]\n  game.slots[i] = tile\n  tile.slot = i\n  tile.tx = slotLeft(i) + (game.slotCellW - tile.w)/2\n  tile.ty = slotTop()\n  if other then\n    if prev then\n      game.slots[prev] = other\n      other.slot = prev\n      other.tx = slotLeft(prev) + (game.slotCellW - other.w)/2\n      other.ty = slotTop()\n    else\n      other.slot = nil\n      other.tx = other.homeX\n      other.ty = other.homeY\n    end\n  end\nend\n\nlocal function removeFromSlot(tile)\n  if tile.slot then\n    game.slots[tile.slot] = nil\n    tile.slot = nil\n  end\n  tile.tx = tile.homeX\n  tile.ty = tile.homeY\nend\n\nlocal function resetForSentence(idx)\n  game.currentIndex = idx\n  game.state = \"play\"\n  game.feedbackTimer = 0\n  game.celebrateTimer = 0\n  game.glowPhase = 0\n  game.confetti = {}\n  createTilesForSentence(idx)\nend\n\nlocal function checkSentence()\n  if not allSlotsFilled() then\n    game.feedback = \"incomplete\"\n    game.feedbackTimer = 1.0\n    return\n  end\n  local seq = currentSequence()\n  local ans = sentences[game.currentIndex].answer\n  if sequencesEqual(seq, ans) then\n    game.state = \"celebrate\"\n    game.celebrateTimer = 1.5\n    game.correctCount = game.correctCount + 1\n    game.feedback = \"correct\"\n    game.feedbackTimer = 1.0\n    playSound(\"sCorrect\")\n    playSound(\"sCorrect2\")\n    spawnConfetti()\n    for _,tile in ipairs(game.tiles) do\n      tile.pulse = 1\n    end\n  else\n    game.mistakes = game.mistakes + 1\n    game.feedback = \"wrong\"\n    game.feedbackTimer = 1.2\n    playSound(\"sWrong\")\n  end\nend\n\nlocal function drawTile(tile)\n  pushTransform()\n  translate(tile.x + tile.w/2, tile.y + tile.h/2)\n  rotate(tile.angle)\n  local x = -tile.w/2\n  local y = -tile.h/2\n  drawRoundedRect(x, y, tile.w, tile.h, 14, colors.tile, true)\n  drawRoundedRect(x, y, tile.w, tile.h, 14, colors.tileStroke, false, 2)\n  local wordSize = 28\n  local hintSize = 12\n  local wordW, wordH = measureText(tile.text, wordSize)\n  drawText(tile.text, x + (tile.w - wordW)/2, y + 8, colors.tileText, wordSize, \"monospace\")\n  if tile.hint and tile.hint ~= \"\" then\n    local hintW, hintH = measureText(tile.hint, hintSize)\n    drawText(tile.hint, x + (tile.w - hintW)/2, y + tile.h - hintH - 6, colors.hintText, hintSize, \"monospace\")\n  end\n  popTransform()\n  if game.state == \"celebrate\" then\n    setBlendMode(\"add\")\n    local gx = tile.x + tile.w/2\n    local gy = tile.y + tile.h/2\n    local r = math.max(tile.w, tile.h)*0.8 + 8*math.sin(t*6)\n    drawRadialGradient(gx, gy, r, rgba(80,200,255,120), rgba(80,200,255,0))\n    setBlendMode(\"normal\")\n  end\nend\n\nlocal function drawSlots()\n  local sy = slotTop()\n  local sx = slotStartX()\n  for i=1,game.N do\n    local lx = slotLeft(i)\n    drawRoundedRect(lx+6, sy+6, game.slotCellW-12, game.tileH-12, 10, rgba(0,0,0,15), true)\n    drawRoundedRect(lx, sy, game.slotCellW, game.tileH, 12, colors.slot, true)\n    drawRoundedRect(lx, sy, game.slotCellW, game.tileH, 12, colors.slotOutline, false, 2)\n  end\nend\n\nlocal function drawButton()\n  local w,h = 220, 48\n  local x = (screenW - sideW - w)/2\n  local y = slotTop() + game.tileH + 18\n  ui.btn = {x=x, y=y, w=w, h=h}\n  local enabled = (game.state == \"play\" and allSlotsFilled())\n  local col = enabled and colors.btn or colors.btnDisabled\n  drawRoundedRect(x, y, w, h, 12, col, true)\n  drawRoundedRect(x, y, w, h, 12, rgba(0,0,0,50), false, 2)\n  local label = \"Comprobar\"\n  local wtxt, htxt = measureText(label, 22)\n  drawText(label, x + (w - wtxt)/2, y + (h - htxt)/2, colors.btnText, 22, \"monospace\")\n  if enabled and pointInRect(cursor.x, cursor.y, x, y, w, h) then\n    setBlendMode(\"add\")\n    drawRadialGradient(x+w/2, y+h/2, 90, rgba(255,255,255,60), rgba(255,255,255,0))\n    setBlendMode(\"normal\")\n  end\nend\n\nlocal function drawSidebar()\n  local x = screenW - sideW + 8\n  local y = 8\n  drawRoundedRect(x, y, sideW-16, screenH-16, 16, colors.panel, true)\n  drawRoundedRect(x, y, sideW-16, screenH-16, 16, colors.panelStroke, false, 2)\n  local tx = x + 12\n  local ty = y + 14\n  drawText(\"Vocabulario\", tx, ty, colors.tileText, 20, \"monospace\")\n  ty = ty + 28\n  for _,v in ipairs(vocab) do\n    local line = v.target..\"  (\"..v.native..\")\"\n    drawText(\"- \"..line, tx, ty, colors.tileText, 16, \"monospace\")\n    ty = ty + 22\n  end\n  ty = ty + 10\n  drawText(\"Gramática\", tx, ty, colors.tileText, 20, \"monospace\")\n  ty = ty + 28\n  for _,g in ipairs(grammar) do\n    drawText(\"- \"..g.target, tx, ty, colors.tileText, 16, \"monospace\")\n    ty = ty + 20\n  end\nend\n\nlocal function drawHUD()\n  local margin = 16\n  local ax = margin\n  local ay = margin\n  local txt1 = \"Aciertos: \"..game.correctCount..\"/\"..#sentences\n  local txt2 = \"Errores: \"..game.mistakes..\"  (≤2 para ganar)\"\n  drawText(txt1, ax, ay, colors.tileText, 18, \"monospace\")\n  drawText(txt2, ax, ay+22, colors.tileText, 16, \"monospace\")\n  local instr = \"Arrastra para ordenar (Drag to arrange)\"\n  drawText(instr, ax, ay+46, colors.hintText, 14, \"monospace\")\nend\n\nlocal function drawPrompts()\n  local native = sentences[game.currentIndex].promptNative\n  local target = sentences[game.currentIndex].promptTarget\n  local margin = 24\n  local playW = screenW - sideW - margin*2\n  local cx = margin + playW/2\n  local top = 82\n  measureTextCentered(\"EN: \"..native, 18, cx, top, colors.hintText, \"monospace\")\n  measureTextCentered(\"ES: \"..target, 26, cx, top+28, colors.tileText, \"monospace\")\nend\n\nlocal function drawFeedback()\n  if game.feedbackTimer > 0 then\n    local msg = \"\"\n    local col = colors.tileText\n    if game.feedback == \"correct\" then\n      msg = \"¡Correcto! (Correct!)\"\n      col = colors.ok\n    elseif game.feedback == \"wrong\" then\n      msg = \"Inténtalo de nuevo (Try again)\"\n      col = colors.warn\n    elseif game.feedback == \"incomplete\" then\n      msg = \"Completa la frase\"\n      col = colors.warn\n    end\n    local margin = 24\n    local playW = screenW - sideW - margin*2\n    local cx = margin + playW/2\n    local cy = slotTop() - 24\n    measureTextCentered(msg, 20, cx, cy, col, \"monospace\")\n  end\nend\n\nlocal function updateTiles(dt)\n  for _,tile in ipairs(game.tiles) do\n    if tile.dragging then\n      tile.angle = lerp(tile.angle, math.sin(t*8)*0.12, dt*10)\n    else\n      tile.angle = lerp(tile.angle, 0, dt*8)\n      tile.x = lerp(tile.x, tile.tx, dt*12)\n      tile.y = lerp(tile.y, tile.ty, dt*12)\n    end\n  end\nend\n\nlocal function drawPlaza()\n  drawGradientRect(0, 0, screenW, screenH, colors.bg1, colors.bg2, true)\n  local margin = 24\n  local playW = screenW - sideW - margin*2\n  local cx = margin + playW/2\n  local cy = screenH*0.5 - 40\n  local radius = math.min(playW, screenH)*0.30\n  drawRadialGradient(cx, cy, radius, colors.plazaInner, colors.plazaOuter)\n  drawCircle(cx, cy, radius, rgba(0,0,0,40), false, 2)\n  drawCircle(cx, cy, radius*0.65, rgba(0,0,0,25), false, 1.5)\n  setBlendMode(\"add\")\n  drawRadialGradient(cx, cy, radius*0.5 + 10*math.sin(t*2), rgba(180,220,255,60), rgba(180,220,255,0))\n  setBlendMode(\"normal\")\nend\n\nlocal function updateConfetti(dt)\n  for i=#game.confetti,1,-1 do\n    local p = game.confetti[i]\n    p.vy = p.vy + 300*dt\n    p.x = p.x + p.vx*dt\n    p.y = p.y + p.vy*dt\n    p.life = p.life - dt\n    if p.life <= 0 or p.y > screenH + 20 then\n      table.remove(game.confetti, i)\n    end\n  end\nend\n\nlocal function drawConfetti()\n  for _,p in ipairs(game.confetti) do\n    local alpha = clamp(math.floor(255 * (p.life/p.maxLife)),0,255)\n    drawPoint(p.x, p.y, rgba((p.color>>16)&255, (p.color>>8)&255, p.color&255, alpha), p.size)\n  end\nend\n\nlocal function nextSentenceOrEnd()\n  if game.currentIndex < #sentences then\n    resetForSentence(game.currentIndex + 1)\n  else\n    game.state = \"end\"\n    game.endTimer = 2.6\n    game.win = (game.mistakes <= 2 and game.correctCount == #sentences)\n  end\nend\n\nfunction init()\n  screenW = getScreenWidth()\n  screenH = getScreenHeight()\n  randomSeed(os.time())\n  createSounds()\n  game.mistakes = 0\n  game.correctCount = 0\n  resetForSentence(1)\nend\n\nfunction update(dt)\n  t = t + dt\n  cursor.x = getMouseX()\n  cursor.y = getMouseY()\n\n  if game.state == \"play\" or game.state == \"celebrate\" then\n    updateTiles(dt)\n  end\n\n  if game.state == \"celebrate\" then\n    game.celebrateTimer = game.celebrateTimer - dt\n    updateConfetti(dt)\n    if game.celebrateTimer <= 0 then\n      nextSentenceOrEnd()\n    end\n  end\n\n  if game.feedbackTimer and game.feedbackTimer > 0 then\n    game.feedbackTimer = game.feedbackTimer - dt\n  end\n\n  if game.state == \"end\" then\n    updateConfetti(dt)\n    game.endTimer = game.endTimer - dt\n    if game.endTimer <= 0 then\n      if game.win then halt(2) else halt(1) end\n    end\n  end\n\n  if game.state == \"play\" then\n    if isMouseJustPressed() then\n      local mx,my = cursor.x, cursor.y\n      for i=#game.tiles,1,-1 do\n        local tile = game.tiles[i]\n        if pointInRect(mx, my, tile.x, tile.y, tile.w, tile.h) then\n          tile.dragging = true\n          ui.dragTile = tile\n          ui.dragOffsetX = mx - tile.x\n          ui.dragOffsetY = my - tile.y\n          if tile.slot then\n            game.slots[tile.slot] = nil\n            tile.slot = nil\n          end\n          table.remove(game.tiles, i)\n          table.insert(game.tiles, tile)\n          break\n        end\n      end\n      local b = ui.btn\n      if b then\n        local enabled = allSlotsFilled()\n        if enabled and pointInRect(mx, my, b.x, b.y, b.w, b.h) then\n          checkSentence()\n        end\n      end\n    elseif isMouseDown() then\n      local tile = ui.dragTile\n      if tile and tile.dragging then\n        tile.x = cursor.x - ui.dragOffsetX\n        tile.y = cursor.y - ui.dragOffsetY\n      end\n    elseif isMouseJustReleased() then\n      local tile = ui.dragTile\n      if tile and tile.dragging then\n        tile.dragging = false\n        if insideRowArea(cursor.x, cursor.y) then\n          local idx = slotIndexFromX(cursor.x)\n          placeInSlot(tile, idx)\n        else\n          removeFromSlot(tile)\n        end\n        ui.dragTile = nil\n      end\n    end\n  end\nend\n\nfunction draw()\n  clear(\"#EAF7FF\")\n  drawPlaza()\n  drawSidebar()\n  drawHUD()\n  drawPrompts()\n  drawSlots()\n\n  for _,tile in ipairs(game.tiles) do\n    drawTile(tile)\n  end\n\n  drawButton()\n  drawFeedback()\n\n  if game.state == \"celebrate\" or game.state == \"end\" then\n    setBlendMode(\"add\")\n    drawConfetti()\n    setBlendMode(\"normal\")\n  end\n\n  if game.state == \"end\" then\n    local msg = game.win and \"¡Regalo de bienvenida listo! (Correct!)\" or \"¡Sigue practicando! (Keep practicing!)\"\n    local sub = \"Aciertos: \"..game.correctCount..\"/\"..#sentences..\"   Errores: \"..game.mistakes\n    local w1,h1 = measureText(msg, 26)\n    local w2,h2 = measureText(sub, 18)\n    local cx = (screenW - sideW)/2\n    local cy = screenH*0.35\n    drawRoundedRect(cx - w1/2 - 20, cy - h1/2 - 16, w1 + 40, h1 + 60, 14, rgba(255,255,255,230), true)\n    drawRoundedRect(cx - w1/2 - 20, cy - h1/2 - 16, w1 + 40, h1 + 60, 14, rgba(0,0,0,60), false, 2)\n    drawText(msg, cx - w1/2, cy - h1/2, game.win and colors.ok or colors.warn, 26, \"monospace\")\n    drawText(sub, cx - w2/2, cy - h1/2 + 34, colors.tileText, 18, \"monospace\")\n  end\nend",
      "id": "game_6_welcome_gift_builder",
      "trigger_id": "loc_1_fuente_de_bienvenida",
      "trigger_type": "location",
      "related_quest_id": "quest_31_welcome_gift"
    },
    {
      "name": {
        "native_language": "Nature Scanner",
        "target_language": "Escáner de la naturaleza"
      },
      "description": {
        "native_language": "Click parts of a simple park scene and label them with short sentences using hay/es and color.",
        "target_language": "Haz clic en partes de una escena simple del parque y etiquétalas con oraciones cortas usando hay/es y color."
      },
      "language_level": "A0",
      "target_vocabulary": [
        {
          "native_language": "park",
          "target_language": "parque"
        },
        {
          "native_language": "stone",
          "target_language": "piedra"
        },
        {
          "native_language": "blue",
          "target_language": "azul"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Existential: hay",
          "target_language": "Existencial: hay"
        },
        {
          "native_language": "Descriptions: es",
          "target_language": "Descripciones: es"
        }
      ],
      "game_prompt": "Game: Picture-label with sentence buttons.\nMechanics:\n- Show a simple park scene: a large green rectangle (grass, labeled 'parque'), a grey circle (stone), and a small blue square (pond/blue item). When player clicks an object, a small menu appears with 2-3 Spanish sentence buttons; the player chooses the correct one that matches the object.\n- Each correct label adds a checkmark tag near the object.\nVisual design:\n- Minimal shapes; selected object outlined in yellow. Sentence buttons appear in a white panel near the click.\nEducational content (object -> choices):\n- Object: green area\n  - Correct: {\"native_language\":\"There is a park.\",\"target_language\":\"Hay un parque.\"}\n  - Wrong options: {\"native_language\":\"It is blue.\",\"target_language\":\"Es azul.\"}, {\"native_language\":\"It is a stone.\",\"target_language\":\"Es una piedra.\"}\n- Object: grey circle\n  - Correct: {\"native_language\":\"It is a stone.\",\"target_language\":\"Es una piedra.\"}\n  - Wrong: {\"native_language\":\"There is a park.\",\"target_language\":\"Hay un parque.\"}, {\"native_language\":\"It is blue.\",\"target_language\":\"Es azul.\"}\n- Object: blue square\n  - Correct: {\"native_language\":\"It is blue.\",\"target_language\":\"Es azul.\"}\n  - Wrong: {\"native_language\":\"It is a stone.\",\"target_language\":\"Es una piedra.\"}, {\"native_language\":\"There is a park.\",\"target_language\":\"Hay un parque.\"}\n- UI text:\n  - {\"native_language\":\"Label the scene\",\"target_language\":\"Etiqueta la escena\"}\n  - {\"native_language\":\"Correct!\",\"target_language\":\"¡Correcto!\"}\n  - {\"native_language\":\"Choose one\",\"target_language\":\"Elige una\"}\nWin/Lose:\n- Win by correctly labeling all 3 objects. If 3 mistakes occur before finishing, show {\"native_language\":\"Look carefully and try again.\",\"target_language\":\"Mira con atención e inténtalo de nuevo.\"}\nAnimations:\n- On correct, a small checkmark appears and the object briefly glows; on wrong, the button shakes.",
      "skill_points": 11,
      "lua_code": "local objects = {}\nlocal menu = nil\nlocal selectedObject = nil\nlocal score = 0\nlocal mistakes = 0\nlocal totalTargets = 3\nlocal gameState = \"active\"\nlocal endTimer = 0\nlocal correctToastTimer = 0\nlocal titlePulse = 0\nlocal colors = {\n  sky1 = \"#A0D8FF\",\n  sky2 = \"#E0F7FF\",\n  grass = \"#6ECF5D\",\n  stone = \"#9AA0A6\",\n  pond = \"#4AA3FF\",\n  uiPanel = \"#FFFFFFFF\",\n  uiBorder = \"#222222\",\n  text = \"#102027\",\n  subtext = \"#556A73\",\n  accent = \"#FFD54F\",\n  good = \"#2ECC71\",\n  bad = \"#E74C3C\",\n  button = \"#FAFAFA\",\n  buttonHover = \"#F0F7FF\"\n}\nlocal soundsCreated = false\n\nlocal function createSounds()\n  if soundsCreated then return end\n  createSound(\"correct1\", 880, 0.10, 0.45, \"sine\")\n  createSound(\"correct2\", 1320, 0.08, 0.40, \"sine\")\n  createSound(\"wrong\", 140, 0.20, 0.45, \"square\")\n  soundsCreated = true\nend\n\nlocal function playCorrect()\n  playSound(\"correct1\")\n  playSound(\"correct2\")\nend\n\nlocal function playWrong()\n  playSound(\"wrong\")\nend\n\nlocal function clamp(v, a, b)\n  if v < a then return a end\n  if v > b then return b end\n  return v\nend\n\nlocal function pointInRect(px, py, x, y, w, h)\n  return px >= x and px <= x + w and py >= y and py <= y + h\nend\n\nlocal function pointInCircle(px, py, cx, cy, r)\n  local dx = px - cx\n  local dy = py - cy\n  return dx * dx + dy * dy <= r * r\nend\n\nlocal function makeOptionsFor(id)\n  if id == \"park\" then\n    return {\n      {span = \"Hay un parque.\", eng = \"There is a park.\", correct = true, shake = 0},\n      {span = \"Es azul.\", eng = \"It is blue.\", correct = false, shake = 0},\n      {span = \"Es una piedra.\", eng = \"It is a stone.\", correct = false, shake = 0}\n    }\n  elseif id == \"stone\" then\n    return {\n      {span = \"Es una piedra.\", eng = \"It is a stone.\", correct = true, shake = 0},\n      {span = \"Hay un parque.\", eng = \"There is a park.\", correct = false, shake = 0},\n      {span = \"Es azul.\", eng = \"It is blue.\", correct = false, shake = 0}\n    }\n  else\n    return {\n      {span = \"Es azul.\", eng = \"It is blue.\", correct = true, shake = 0},\n      {span = \"Es una piedra.\", eng = \"It is a stone.\", correct = false, shake = 0},\n      {span = \"Hay un parque.\", eng = \"There is a park.\", correct = false, shake = 0}\n    }\n  end\nend\n\nlocal function openMenuFor(obj, clickX, clickY)\n  local w = getScreenWidth()\n  local h = getScreenHeight()\n  local options = makeOptionsFor(obj.id)\n  local padding = 10\n  local btnSpacing = 8\n  local spanSize = 18\n  local engSize = 12\n  local headerSize = 16\n  local header = \"Elige una (Choose one)\"\n  local headerW = measureText(header, headerSize)\n  local maxW = headerW\n  for i = 1, #options do\n    local sw = measureText(options[i].span, spanSize)\n    local ew = measureText(options[i].eng, engSize)\n    local bw = math.max(sw, ew)\n    if bw > maxW then maxW = bw end\n    options[i].shake = 0\n  end\n  local btnHeight = 40\n  local panelW = maxW + padding * 2\n  local panelH = padding * 2 + headerSize + 6 + (#options * btnHeight) + ((#options - 1) * btnSpacing)\n  local panelX = clickX + 16\n  local panelY = clickY + 16\n  if panelX + panelW > w - 8 then panelX = clickX - panelW - 16 end\n  if panelY + panelH > h - 8 then panelY = clickY - panelH - 16 end\n  panelX = clamp(panelX, 8, w - panelW - 8)\n  panelY = clamp(panelY, 8, h - panelH - 8)\n  local buttons = {}\n  local y = panelY + padding + headerSize + 6\n  for i = 1, #options do\n    table.insert(buttons, {x = panelX + padding, y = y, w = panelW - padding * 2, h = btnHeight})\n    y = y + btnHeight + btnSpacing\n  end\n  menu = {\n    x = panelX, y = panelY, w = panelW, h = panelH,\n    options = options, buttons = buttons, header = header,\n    obj = obj\n  }\n  selectedObject = obj\nend\n\nlocal function closeMenu()\n  menu = nil\n  selectedObject = nil\nend\n\nlocal function drawObject(obj)\n  if obj.type == \"rect\" then\n    drawRect(obj.x, obj.y, obj.w, obj.h, obj.color, true)\n  elseif obj.type == \"circle\" then\n    drawCircle(obj.x, obj.y, obj.r, obj.color, true)\n  elseif obj.type == \"square\" then\n    drawRect(obj.x, obj.y, obj.s, obj.s, obj.color, true)\n  end\nend\n\nlocal function drawObjectOutline(obj, color, stroke)\n  if obj.type == \"rect\" then\n    drawRect(obj.x, obj.y, obj.w, obj.h, color, false, stroke)\n  elseif obj.type == \"circle\" then\n    drawCircle(obj.x, obj.y, obj.r + stroke * 0.5, color, false, stroke)\n  elseif obj.type == \"square\" then\n    drawRect(obj.x, obj.y, obj.s, obj.s, color, false, stroke)\n  end\nend\n\nlocal function pointHitObject(mx, my, obj)\n  if obj.type == \"rect\" then\n    return pointInRect(mx, my, obj.x, obj.y, obj.w, obj.h)\n  elseif obj.type == \"circle\" then\n    return pointInCircle(mx, my, obj.x, obj.y, obj.r)\n  elseif obj.type == \"square\" then\n    return pointInRect(mx, my, obj.x, obj.y, obj.s, obj.s)\n  end\n  return false\nend\n\nlocal function drawGlow(obj, t)\n  local a = clamp(t / 0.6, 0, 1)\n  local pulse = 0.5 + 0.5 * math.sin(getTime() * 10)\n  local glowColor = rgba(255, 255, 140, math.floor(160 * a * (0.7 + 0.3 * pulse)))\n  setBlendMode(\"add\")\n  for i = 1, 3 do\n    local s = i * 2\n    drawObjectOutline(obj, glowColor, 2 + s)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawCheckmarkAt(x, y, scale)\n  local s = scale or 1\n  local c = colors.good\n  local x1 = x\n  local y1 = y + 4 * s\n  local x2 = x + 6 * s\n  local y2 = y + 10 * s\n  local x3 = x + 16 * s\n  local y3 = y - 2 * s\n  drawLine(x1, y1, x2, y2, c, 3)\n  drawLine(x2, y2, x3, y3, c, 3)\nend\n\nlocal function drawCheckForObject(obj)\n  if not obj.completed then return end\n  local cx, cy = 0, 0\n  if obj.type == \"rect\" then\n    cx = obj.x + 10\n    cy = obj.y + 10\n  elseif obj.type == \"circle\" then\n    cx = obj.x + obj.r - 18\n    cy = obj.y - obj.r + 18\n  elseif obj.type == \"square\" then\n    cx = obj.x + 6\n    cy = obj.y + 6\n  end\n  drawCheckmarkAt(cx, cy, 1)\nend\n\nlocal function drawSceneBackground()\n  local w = getScreenWidth()\n  local h = getScreenHeight()\n  drawGradientRect(0, 0, w, h, colors.sky2, colors.sky1, true)\nend\n\nlocal function drawGrassLabel(obj)\n  local label = \"parque\"\n  local tw = measureText(label, 20)\n  drawRoundedRect(obj.x + 10, obj.y - 30, tw + 16, 26, 8, rgba(255,255,255,200), true)\n  drawText(label, obj.x + 18, obj.y - 12, colors.text, 20, \"monospace\")\n}\n\nfunction init()\n  createSounds()\n  local w = getScreenWidth()\n  local h = getScreenHeight()\n  local grassY = math.floor(h * 0.58)\n  local grassH = h - grassY\n  objects = {\n    {\n      id = \"park\",\n      type = \"rect\",\n      x = 0,\n      y = grassY,\n      w = w,\n      h = grassH,\n      color = colors.grass,\n      completed = false,\n      glow = 0\n    },\n    {\n      id = \"stone\",\n      type = \"circle\",\n      x = math.floor(w * 0.28),\n      y = grassY - 30,\n      r = 28,\n      color = colors.stone,\n      completed = false,\n      glow = 0\n    },\n    {\n      id = \"blue\",\n      type = \"square\",\n      x = math.floor(w * 0.70),\n      y = grassY - 42,\n      s = 34,\n      color = colors.pond,\n      completed = false,\n      glow = 0\n    }\n  }\n  score = 0\n  mistakes = 0\n  gameState = \"active\"\n  endTimer = 0\n  correctToastTimer = 0\n  titlePulse = 0\n  menu = nil\n  selectedObject = nil\nend\n\nfunction update(dt)\n  titlePulse = titlePulse + dt\n  if correctToastTimer > 0 then\n    correctToastTimer = correctToastTimer - dt\n  end\n  for i = 1, #objects do\n    if objects[i].glow and objects[i].glow > 0 then\n      objects[i].glow = objects[i].glow - dt\n      if objects[i].glow < 0 then objects[i].glow = 0 end\n    end\n  end\n  if menu then\n    for i = 1, #menu.options do\n      if menu.options[i].shake and menu.options[i].shake > 0 then\n        menu.options[i].shake = menu.options[i].shake - dt\n        if menu.options[i].shake < 0 then menu.options[i].shake = 0 end\n      end\n    end\n  end\n  if gameState ~= \"active\" then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      if gameState == \"won\" then\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n    return\n  end\n  if isMouseJustPressed() then\n    local mx = getMouseX()\n    local my = getMouseY()\n    local clickedButton = false\n    if menu then\n      for i = 1, #menu.buttons do\n        local b = menu.buttons[i]\n        local shakeOffset = 0\n        if menu.options[i].shake and menu.options[i].shake > 0 then\n          local t = menu.options[i].shake\n          shakeOffset = math.sin(getTime() * 40) * 6 * (t / 0.4)\n        end\n        if pointInRect(mx, my, b.x + shakeOffset, b.y, b.w, b.h) then\n          clickedButton = true\n          local opt = menu.options[i]\n          if opt.correct then\n            if not menu.obj.completed then\n              menu.obj.completed = true\n              menu.obj.glow = 0.6\n              score = score + 1\n              correctToastTimer = 0.9\n              playCorrect()\n              if score >= totalTargets then\n                gameState = \"won\"\n                endTimer = 1.6\n              end\n            end\n            closeMenu()\n          else\n            opt.shake = 0.4\n            mistakes = mistakes + 1\n            playWrong()\n            if mistakes >= 3 and score < totalTargets then\n              gameState = \"lost\"\n              endTimer = 2.0\n              closeMenu()\n            end\n          end\n          break\n        end\n      end\n      if not clickedButton then\n        -- If click is outside menu and not on another object, close menu\n        if not pointInRect(mx, my, menu.x, menu.y, menu.w, menu.h) then\n          closeMenu()\n        end\n      end\n      if clickedButton then return end\n    end\n    if gameState ~= \"active\" then return end\n    -- Check objects for selection (small first)\n    local order = {2, 3, 1} -- stone, blue, park\n    local opened = false\n    for idx = 1, #order do\n      local i = order[idx]\n      local obj = objects[i]\n      if pointHitObject(mx, my, obj) then\n        if not obj.completed then\n          openMenuFor(obj, mx, my)\n          opened = true\n        else\n          -- Completed: still show menu for reinforcement if desired\n          openMenuFor(obj, mx, my)\n          opened = true\n        end\n        break\n      end\n    end\n    if not opened then\n      closeMenu()\n    end\n  end\nend\n\nfunction draw()\n  clear(\"#FFFFFF\")\n  drawSceneBackground()\n  local w = getScreenWidth()\n  local h = getScreenHeight()\n\n  -- Draw title and info bar\n  local title = \"Etiqueta la escena\"\n  local sub = \"Label the scene\"\n  local pulse = 0.5 + 0.5 * math.sin(titlePulse * 2)\n  local titleColor = rgba(20, 60, 90, 255)\n  drawText(title, 18, 28, titleColor, 28 + pulse * 1.0, \"monospace\")\n  drawText(sub, 22, 50, colors.subtext, 14, \"monospace\")\n\n  -- Vocabulary and grammar panel\n  local infoX = w - 220\n  local infoY = 14\n  drawRoundedRect(infoX, infoY, 206, 110, 10, rgba(255,255,255,200), true)\n  drawRect(infoX, infoY, 206, 110, rgba(0,0,0,30), false, 1)\n  drawText(\"Vocabulario (A0)\", infoX + 10, infoY + 18, colors.text, 16, \"monospace\")\n  drawText(\"park → parque\", infoX + 10, infoY + 36, colors.subtext, 14, \"monospace\")\n  drawText(\"stone → piedra\", infoX + 10, infoY + 54, colors.subtext, 14, \"monospace\")\n  drawText(\"blue → azul\", infoX + 10, infoY + 72, colors.subtext, 14, \"monospace\")\n  drawText(\"Gramática: hay / es\", infoX + 10, infoY + 94, colors.text, 14, \"monospace\")\n\n  -- Draw grass (park) first (background object)\n  for i = 1, #objects do\n    if objects[i].id == \"park\" then\n      drawObject(objects[i])\n    end\n  end\n  -- Draw other objects\n  for i = 1, #objects do\n    if objects[i].id ~= \"park\" then\n      -- soft shadow\n      if objects[i].type == \"circle\" then\n        drawEllipse(objects[i].x + 4, objects[i].y + 8, objects[i].r * 0.9, objects[i].r * 0.45, rgba(0,0,0,40), true)\n      elseif objects[i].type == \"square\" then\n        drawEllipse(objects[i].x + objects[i].s * 0.5 + 4, objects[i].y + objects[i].s + 6, objects[i].s * 0.45, objects[i].s * 0.18, rgba(0,0,0,40), true)\n      end\n      drawObject(objects[i])\n    end\n  end\n\n  -- Label \"parque\" near grass\n  for i = 1, #objects do\n    if objects[i].id == \"park\" then\n      drawGrassLabel(objects[i])\n    end\n  end\n\n  -- Selected outline\n  if selectedObject then\n    drawObjectOutline(selectedObject, colors.accent, 3)\n  end\n\n  -- Glow effects and checkmarks\n  for i = 1, #objects do\n    if objects[i].glow and objects[i].glow > 0 then\n      drawGlow(objects[i], objects[i].glow)\n    end\n    drawCheckForObject(objects[i])\n  end\n\n  -- Score UI\n  local scoreText = \"Puntos: \" .. tostring(score) .. \"/\" .. tostring(totalTargets)\n  local errText = \"Errores: \" .. tostring(mistakes) .. \"/3\"\n  drawRoundedRect(14, h - 56, 200, 44, 10, rgba(255,255,255,220), true)\n  drawRect(14, h - 56, 200, 44, rgba(0,0,0,30), false, 1)\n  drawText(scoreText, 24, h - 36, colors.text, 16, \"monospace\")\n  drawText(errText, 24, h - 18, mistakes >= 3 and colors.bad or colors.subtext, 14, \"monospace\")\n\n  -- Menu panel\n  if menu then\n    drawRoundedRect(menu.x, menu.y, menu.w, menu.h, 12, colors.uiPanel, true)\n    drawRect(menu.x, menu.y, menu.w, menu.h, rgba(0,0,0,40), false, 1.2)\n    drawText(menu.header, menu.x + 10, menu.y + 14, colors.text, 16, \"monospace\")\n    for i = 1, #menu.buttons do\n      local b = menu.buttons[i]\n      local opt = menu.options[i]\n      local shakeOffset = 0\n      if opt.shake and opt.shake > 0 then\n        shakeOffset = math.sin(getTime() * 40) * 6 * (opt.shake / 0.4)\n      end\n      local mx = getMouseX()\n      local my = getMouseY()\n      local hovered = pointInRect(mx, my, b.x + shakeOffset, b.y, b.w, b.h)\n      local btnColor = hovered and rgba(230,240,255,255) or colors.button\n      drawRoundedRect(b.x + shakeOffset, b.y, b.w, b.h, 8, btnColor, true)\n      drawRect(b.x + shakeOffset, b.y, b.w, b.h, rgba(0,0,0,25), false, 1)\n      drawText(opt.span, b.x + 10 + shakeOffset, b.y + 16, colors.text, 18, \"monospace\")\n      drawText(opt.eng, b.x + 10 + shakeOffset, b.y + 32, colors.subtext, 12, \"monospace\")\n    end\n  end\n\n  -- Correct toast\n  if correctToastTimer > 0 then\n    local alpha = math.floor(255 * math.min(1, correctToastTimer / 0.9))\n    local toastColor = rgba(46, 204, 113, alpha)\n    local textColor = rgba(255, 255, 255, alpha)\n    local tx = w * 0.5\n    local ty = 80\n    pushTransform()\n    translate(tx, ty)\n    drawRoundedRect(-90, -22, 180, 44, 12, toastColor, true)\n    drawText(\"¡Correcto!\", -58, 6, textColor, 20, \"monospace\")\n    popTransform()\n  end\n\n  -- Win/Lose overlay\n  if gameState ~= \"active\" then\n    local overlayA = 200\n    drawRect(0, 0, w, h, rgba(0,0,0,overlayA), true)\n    if gameState == \"won\" then\n      local msg = \"¡Muy bien! Todo etiquetado.\"\n      drawText(msg, w * 0.5 - measureText(msg, 26) * 0.5, h * 0.5 - 10, \"#FFFFFF\", 26, \"monospace\")\n      local hint = \"Success! Great job.\"\n      drawText(hint, w * 0.5 - measureText(hint, 16) * 0.5, h * 0.5 + 14, \"#DDFFDD\", 16, \"monospace\")\n    else\n      local msg = \"Mira con atención e inténtalo de nuevo.\"\n      drawText(msg, w * 0.5 - measureText(msg, 24) * 0.5, h * 0.5 - 6, \"#FFFFFF\", 24, \"monospace\")\n      local hint = \"Look carefully and try again.\"\n      drawText(hint, w * 0.5 - measureText(hint, 16) * 0.5, h * 0.5 + 16, \"#FFDDDD\", 16, \"monospace\")\n    end\n  end\n\n  -- Yellow outline for currently selected object\n  if selectedObject then\n    drawObjectOutline(selectedObject, colors.accent, 3)\n  end\n\n  -- Small captions near objects to guide\n  for i = 1, #objects do\n    local obj = objects[i]\n    if obj.id == \"stone\" then\n      drawRoundedRect(obj.x - 28, obj.y - obj.r - 30, 66, 22, 8, rgba(255,255,255,200), true)\n      drawText(\"piedra\", obj.x - 18, obj.y - obj.r - 14, colors.text, 16, \"monospace\")\n    elseif obj.id == \"blue\" then\n      drawRoundedRect(obj.x - 4, obj.y - 26, 60, 22, 8, rgba(255,255,255,200), true)\n      drawText(\"azul\", obj.x + 6, obj.y - 10, colors.text, 16, \"monospace\")\n    end\n  end\nend",
      "id": "game_7_nature_scanner",
      "trigger_id": "loc_3_parque_de_la_amistad",
      "trigger_type": "location",
      "related_quest_id": "quest_32_nature_s_colors"
    },
    {
      "name": {
        "native_language": "Fruit Catch Command",
        "target_language": "Atrapa fruta por comando"
      },
      "description": {
        "native_language": "Move a basket to catch words that match the command, like 'Recoge plátano'.",
        "target_language": "Mueve una canasta para atrapar palabras que coincidan con el comando, como 'Recoge plátano'."
      },
      "language_level": "A0+",
      "target_vocabulary": [
        {
          "native_language": "banana",
          "target_language": "plátano"
        },
        {
          "native_language": "fruit stand",
          "target_language": "puesto de fruta"
        },
        {
          "native_language": "collect",
          "target_language": "recoger"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Imperative: Recoge...",
          "target_language": "Imperativo: Recoge..."
        },
        {
          "native_language": "Present tense recognition: recojo/recoges (visual only, optional)",
          "target_language": "Reconocimiento del presente: recojo/recoges (solo visual, opcional)"
        }
      ],
      "game_prompt": "Game: Gravity-drop catching.\nMechanics:\n- Player controls a basket (rectangle) at the bottom with mouse movement. Words fall from the top. At the top, a bilingual command tells what to catch.\n- Catching a correct word adds points; catching a wrong word loses a life.\nVisual design:\n- Background: simple stall canopy stripes. Falling items are word blocks with Spanish text. Basket labeled 'canasta'.\nEducational content:\n- Commands (randomized):\n  - {\"native_language\":\"Collect banana.\",\"target_language\":\"Recoge plátano.\"}\n  - {\"native_language\":\"Collect fruit at the fruit stand.\",\"target_language\":\"Recoge fruta en el puesto de fruta.\"}\n- Falling word pool (Spanish): 'plátano', 'fruta', 'puesto de fruta', 'recoger' (bonus word), plus distractors 'pan', 'café'.\n- Bonus mechanic: catching 'recoger' when the command contains 'Recoge...' grants extra points.\n- UI text:\n  - {\"native_language\":\"Lives\",\"target_language\":\"Vidas\"}\n  - {\"native_language\":\"Score\",\"target_language\":\"Puntuación\"}\n  - {\"native_language\":\"Catch the correct words!\",\"target_language\":\"¡Atrapa las palabras correctas!\"}\n  - {\"native_language\":\"Nice catch!\",\"target_language\":\"¡Buen atrapado!\"}\nWin/Lose:\n- 3 lives, 60-second timer. Win by scoring 10+ points. Lose if lives reach 0 or time ends with <10.\nAnimations:\n- Words fall with slight sway; basket squashes slightly when catching; correct catch sparkles.",
      "skill_points": 16,
      "lua_code": "local W, H\nlocal items = {}\nlocal particles = {}\nlocal messages = {}\n\nlocal spawnTimer = 0\nlocal spawnMin = 0.6\nlocal spawnMax = 1.1\n\nlocal basket = {x=0, y=0, w=150, h=28, squash=0, label=\"canasta\"}\n\nlocal score = 0\nlocal lives = 3\nlocal timeLeft = 60\n\nlocal state = \"play\"\nlocal endResult = nil\nlocal endTimer = 0\n\nlocal timeAcc = 0\n\nlocal commands = {\n  {en=\"Collect banana.\", es=\"Recoge plátano.\", correct={\"plátano\"}},\n  {en=\"Collect fruit at the fruit stand.\", es=\"Recoge fruta en el puesto de fruta.\", correct={\"fruta\",\"puesto de fruta\"}}\n}\nlocal currentCommandIndex = 1\n\nlocal poolWords = {\"plátano\",\"fruta\",\"puesto de fruta\",\"recoger\",\"pan\",\"café\"}\n\nlocal correctFlash = 0\nlocal wrongFlash = 0\n\nlocal goodSound = \"good\"\nlocal badSound = \"bad\"\nlocal bonusSound = \"bonus\"\n\nlocal function isInList(word, list)\n  for i=1,#list do\n    if list[i] == word then return true end\n  end\n  return false\nend\n\nlocal function currentCorrectSet()\n  return commands[currentCommandIndex].correct\nend\n\nlocal function nonTargetSet()\n  local set = {}\n  local correct = currentCorrectSet()\n  for i=1,#poolWords do\n    local w = poolWords[i]\n    if w ~= \"recoger\" and w ~= \"pan\" and w ~= \"café\" and not isInList(w, correct) then\n      table.insert(set, w)\n    end\n  end\n  return set\nend\n\nlocal function distractorSet()\n  return {\"pan\",\"café\"}\nend\n\nlocal function pickFromList(list)\n  if #list == 0 then return \"pan\" end\n  local idx = randomInt(1, #list)\n  return list[idx]\nend\n\nlocal function pickSpawnWord()\n  local r = random()\n  if r < 0.5 then\n    return pickFromList(currentCorrectSet())\n  elseif r < 0.65 then\n    return \"recoger\"\n  elseif r < 0.95 then\n    return pickFromList(nonTargetSet())\n  else\n    return pickFromList(distractorSet())\n  end\nend\n\nlocal function addMessage(text, x, y, color)\n  table.insert(messages, {text=text, x=x, y=y, vy=-40, life=1.0, color=color or rgb(255,255,255)})\nend\n\nlocal function addSparkles(x, y, baseColor)\n  for i=1,16 do\n    local ang = random(0, math.pi*2)\n    local spd = random(60, 140)\n    local vx = math.cos(ang)*spd\n    local vy = math.sin(ang)*spd\n    local life = random(0.4, 0.8)\n    local col = baseColor or rgba(255,255,180,200)\n    table.insert(particles, {x=x, y=y, vx=vx, vy=vy, life=life, maxLife=life, color=col, size=random(2,4)})\n  end\nend\n\nlocal function measureWord(text, fontSize)\n  local w,h = measureText(text, fontSize or 20)\n  return w,h\nend\n\nlocal function addItem(text)\n  local fontSize = 20\n  local tw, th = measureWord(text, fontSize)\n  local padX = 14\n  local padY = 10\n  local w = tw + padX*2\n  local h = th + padY*2\n  local baseX = random(40, W-40)\n  local y = -h - random(10, 80)\n  local speed = random(70, 120)\n  local swayAmp = random(20, 40)\n  local swayFreq = random(1.5, 3.5)\n  local phase = random(0, math.pi*2)\n\n  local color = rgba(255,255,255,230)\n  if text == \"recoger\" then\n    color = rgba(255,235,120,240)\n  elseif text == \"pan\" or text == \"café\" then\n    color = rgba(210,210,210,230)\n  else\n    color = rgba(200,230,255,235)\n  end\n\n  table.insert(items, {\n    text=text, fontSize=fontSize,\n    baseX=baseX, y=y, speed=speed,\n    swayAmp=swayAmp, swayFreq=swayFreq, phase=phase,\n    w=w, h=h, color=color, caught=false\n  })\nend\n\nlocal function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh)\n  return ax < bx + bw and bx < ax + aw and ay < by + bh and by < ay + ah\nend\n\nlocal function updateBasket(dt)\n  local mx = getMouseX()\n  basket.x = math.max(basket.w/2, math.min(W - basket.w/2, mx))\n  basket.y = H - 60\n  basket.w = 160\n  basket.h = 28\n  if basket.squash > 0 then\n    basket.squash = math.max(0, basket.squash - dt*2.2)\n  end\nend\n\nlocal function isCorrectCatch(word)\n  return isInList(word, currentCorrectSet())\nend\n\nlocal function canopy(y, h)\n  local stripeW = 40\n  for x=0, W, stripeW do\n    local idx = math.floor(x/stripeW)\n    local col = (idx % 2 == 0) and \"#E74C3C\" or \"#FFFFFF\"\n    drawRect(x, y, stripeW, h, col, true)\n  end\n  local scallopR = 18\n  for x=0, W, scallopR*2 do\n    drawArc(x+scallopR, y+h, scallopR, 0, math.pi, \"#FFFFFF\", true)\n  end\nend\n\nlocal function drawBackground()\n  drawGradientRect(0, 0, W, H, rgba(200,235,255,255), rgba(240,250,255,255), true)\n  canopy(0, 110)\n  drawGradientRect(0, H-30, W, 30, rgba(200,190,160,255), rgba(160,140,110,255), true)\nend\n\nlocal function drawHUD()\n  local pad = 10\n  local uiColor = rgb(30,30,30)\n  local accent = \"#2ECC71\"\n  drawText(\"Vidas / Lives:\", pad, 12, uiColor, 16, \"monospace\")\n  for i=1,3 do\n    local col = i <= lives and \"#E74C3C\" or rgba(230,230,230,180)\n    drawCircle(120 + i*18, 16, 7, col, true)\n  end\n  drawText(\"Puntuación / Score: \"..score, pad, 36, uiColor, 16, \"monospace\")\n  local t = math.max(0, math.ceil(timeLeft))\n  drawText(\"Tiempo: \"..t..\"s\", pad, 60, uiColor, 16, \"monospace\")\n  local es = commands[currentCommandIndex].es\n  local en = commands[currentCommandIndex].en\n  local cw, ch = measureText(es, 24)\n  drawRoundedRect(W/2 - cw/2 - 14, 10, cw+28, 44, 10, rgba(255,255,255,220), true)\n  drawText(es, W/2 - cw/2, 18, rgb(30,30,30), 24, \"monospace\")\n  local cw2 = select(1, measureText(en, 14))\n  drawText(en, W/2 - cw2/2, 58, rgba(50,50,50,200), 14, \"monospace\")\n  local hint = \"¡Atrapa las palabras correctas! / Catch the correct words!\"\n  local hw = select(1, measureText(hint, 14))\n  drawText(hint, W/2 - hw/2, 80, rgb(50,50,50), 14, \"monospace\")\n  local vocab = \"Vocab: plátano, puesto de fruta, recoger\"\n  drawText(vocab, W - select(1, measureText(vocab, 12)) - 10, H - 22, rgba(40,40,40,200), 12, \"monospace\")\n  local gram = \"Gramática: Imperativo - Recoge...\"\n  drawText(gram, W - select(1, measureText(gram, 12)) - 10, H - 38, rgba(40,40,40,200), 12, \"monospace\")\nend\n\nlocal function drawItems()\n  for i=1,#items do\n    local it = items[i]\n    local sway = math.sin(timeAcc*it.swayFreq + it.phase) * it.swayAmp\n    local x = it.baseX + sway - it.w/2\n    local y = it.y\n    local shadowCol = rgba(0,0,0,40)\n    drawRoundedRect(x+3, y+4, it.w, it.h, 10, shadowCol, true)\n    drawRoundedRect(x, y, it.w, it.h, 10, it.color, true)\n    drawRoundedRect(x, y, it.w, it.h, 10, rgba(0,0,0,60), false, 1)\n    local tw = select(1, measureText(it.text, it.fontSize))\n    drawText(it.text, x + (it.w - tw)/2, y + it.h/2 - it.fontSize/2, rgb(30,30,30), it.fontSize, \"monospace\")\n  end\nend\n\nlocal function drawBasket()\n  local x = basket.x - basket.w/2\n  local y = basket.y\n  local cx = basket.x\n  local cy = basket.y + basket.h/2\n  local scaleY = 1 - basket.squash*0.4\n  pushTransform()\n  translate(cx, cy)\n  scale(1, scaleY)\n  translate(-cx, -cy)\n  drawRoundedRect(x, y, basket.w, basket.h, 8, rgba(255,140,60,230), true)\n  drawRoundedRect(x, y, basket.w, basket.h, 8, rgba(130,70,30,200), false, 2)\n  local lw = select(1, measureText(basket.label, 14))\n  drawText(basket.label, cx - lw/2, y + basket.h/2 - 7, rgba(255,255,255,230), 14, \"monospace\")\n  popTransform()\nend\n\nlocal function drawParticles()\n  setBlendMode(\"add\")\n  for i=1,#particles do\n    local p = particles[i]\n    local a = math.max(0, p.life / p.maxLife)\n    local col = p.color\n    local r = (col >> 16) & 0xFF\n    local g = (col >> 8) & 0xFF\n    local b = col & 0xFF\n    local c = rgba(r, g, b, math.floor(255*a))\n    drawCircle(p.x, p.y, p.size, c, true)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawMessages()\n  for i=1,#messages do\n    local m = messages[i]\n    local a = math.max(0, m.life)\n    local col = m.color\n    local r = (col >> 16) & 0xFF\n    local g = (col >> 8) & 0xFF\n    local b = col & 0xFF\n    local c = rgba(r, g, b, math.floor(255*a))\n    local w = select(1, measureText(m.text, 16))\n    drawText(m.text, m.x - w/2, m.y, c, 16, \"monospace\")\n  end\nend\n\nlocal function updateParticles(dt)\n  for i=#particles,1,-1 do\n    local p = particles[i]\n    p.life = p.life - dt\n    p.x = p.x + p.vx*dt\n    p.y = p.y + p.vy*dt\n    p.vy = p.vy + 80*dt\n    if p.life <= 0 then table.remove(particles, i) end\n  end\n  for i=#messages,1,-1 do\n    local m = messages[i]\n    m.life = m.life - dt\n    m.y = m.y + m.vy*dt\n    if m.life <= 0 then table.remove(messages, i) end\n  end\nend\n\nlocal function chooseNewCommand()\n  currentCommandIndex = randomInt(1, #commands)\nend\n\nfunction init()\n  W = getScreenWidth()\n  H = getScreenHeight()\n  randomSeed(os.time())\n  chooseNewCommand()\n  basket.x = W/2\n  basket.y = H - 60\n  createSound(goodSound, 880, 0.1, 0.5, \"sine\")\n  createSound(badSound, 180, 0.2, 0.5, \"square\")\n  createSound(bonusSound, 1320, 0.15, 0.6, \"triangle\")\nend\n\nfunction update(dt)\n  if state ~= \"play\" then\n    endTimer = endTimer + dt\n    if endTimer >= 2 then\n      if endResult == \"win\" then halt(2) else halt(1) end\n    end\n    return\n  end\n\n  timeAcc = timeAcc + dt\n  timeLeft = timeLeft - dt\n  if timeLeft <= 0 then\n    if score >= 10 then\n      state = \"end\"\n      endResult = \"win\"\n      endTimer = 0\n    else\n      state = \"end\"\n      endResult = \"lose\"\n      endTimer = 0\n    end\n  end\n\n  if score >= 10 then\n    state = \"end\"\n    endResult = \"win\"\n    endTimer = 0\n  end\n\n  updateBasket(dt)\n\n  spawnTimer = spawnTimer - dt\n  if spawnTimer <= 0 then\n    addItem(pickSpawnWord())\n    spawnTimer = random(spawnMin, spawnMax)\n  end\n\n  for i=#items,1,-1 do\n    local it = items[i]\n    it.y = it.y + it.speed*dt\n    local sway = math.sin(timeAcc*it.swayFreq + it.phase) * it.swayAmp\n    local x = it.baseX + sway - it.w/2\n    local y = it.y\n    local bx = basket.x - basket.w/2\n    local by = basket.y\n    local bw = basket.w\n    local bh = basket.h\n\n    if rectsOverlap(x, y, it.w, it.h, bx, by, bw, bh) and not it.caught then\n      it.caught = true\n      local correct = isCorrectCatch(it.text)\n      local caughtX = x + it.w/2\n      local caughtY = y + it.h/2\n      basket.squash = 0.35\n      if correct then\n        score = score + 1\n        correctFlash = 0.25\n        playSound(goodSound)\n        addSparkles(caughtX, caughtY, rgba(180,255,180,220))\n        addMessage(\"¡Buen atrapado! / Nice catch!\", caughtX, caughtY - 20, rgb(60,160,60))\n        if string.find(commands[currentCommandIndex].es, \"Recoge\") and it.text == \"recoger\" then\n          score = score + 2\n          playSound(bonusSound)\n          addSparkles(caughtX, caughtY, rgba(255,230,120,230))\n          addMessage(\"+2 bonus: recoger\", caughtX, caughtY - 40, rgb(200,160,40))\n        end\n      else\n        lives = lives - 1\n        wrongFlash = 0.35\n        playSound(badSound)\n        addSparkles(caughtX, caughtY, rgba(255,80,80,180))\n        addMessage(\"¡Incorrecto! / Wrong\", caughtX, caughtY - 20, rgb(180,40,40))\n        if lives <= 0 then\n          state = \"end\"\n          endResult = \"lose\"\n          endTimer = 0\n        end\n      end\n      table.remove(items, i)\n    elseif it.y > H + 50 then\n      table.remove(items, i)\n    end\n  end\n\n  if correctFlash > 0 then correctFlash = correctFlash - dt end\n  if wrongFlash > 0 then wrongFlash = wrongFlash - dt end\n\n  updateParticles(dt)\nend\n\nfunction draw()\n  clear(\"#F8FCFF\")\n  drawBackground()\n  drawHUD()\n  drawItems()\n  drawBasket()\n  drawParticles()\n  drawMessages()\n\n  if correctFlash > 0 then\n    local a = math.floor(120 * (correctFlash/0.25))\n    drawRect(0,0,W,H, rgba(100,220,120, a), true)\n  end\n  if wrongFlash > 0 then\n    local a = math.floor(140 * (wrongFlash/0.35))\n    drawRect(0,0,W,H, rgba(255,60,60, a), true)\n  end\n\n  if state ~= \"play\" then\n    local overlay = rgba(255,255,255,210)\n    drawRect(0,0,W,H, overlay, true)\n    local title = endResult == \"win\" and \"¡Ganaste! / You Win!\" or \"¡Perdiste! / You Lose!\"\n    local info = \"Puntuación: \"..score..\"   Vidas: \"..lives\n    local tw = select(1, measureText(title, 36))\n    local iw = select(1, measureText(info, 20))\n    drawText(title, W/2 - tw/2, H/2 - 30, rgb(30,120,60), 36, \"monospace\")\n    drawText(info, W/2 - iw/2, H/2 + 10, rgb(50,50,50), 20, \"monospace\")\n    local hw = select(1, measureText(\"Saliendo... / Exiting...\", 14))\n    drawText(\"Saliendo... / Exiting...\", W/2 - hw/2, H/2 + 38, rgba(60,60,60,200), 14, \"monospace\")\n  end\nend",
      "id": "game_8_fruit_catch_command",
      "trigger_id": "loc_4_puesto_de_fruta",
      "trigger_type": "location",
      "related_quest_id": "quest_33_fruit_gathering"
    },
    {
      "name": {
        "native_language": "Bread Run Routes",
        "target_language": "Rutas de entrega de pan"
      },
      "description": {
        "native_language": "Choose the right preposition gates to build a sentence and deliver bread to the café.",
        "target_language": "Elige las puertas de preposición correctas para formar una oración y entregar pan al café."
      },
      "language_level": "A0+",
      "target_vocabulary": [
        {
          "native_language": "bread",
          "target_language": "pan"
        },
        {
          "native_language": "café (coffee shop)",
          "target_language": "café"
        },
        {
          "native_language": "deliver",
          "target_language": "entregar"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Present tense: entrego/entregas (recognition)",
          "target_language": "Presente: entrego/entregas (reconocimiento)"
        },
        {
          "native_language": "Prepositions: a, en",
          "target_language": "Preposiciones: a, en"
        }
      ],
      "game_prompt": "Game: Path selection with grammar gates.\nMechanics:\n- Top-down simple map: left node 'Panadería' (bakery), right node 'Café'. Between them, two forks with gate choices. Each gate is a rectangular arch labeled with a Spanish word (e.g., 'a', 'en', 'de').\n- A bilingual target sentence shows at the top. Player clicks the correct sequence of gates to match the sentence, then clicks 'Go' to send a bread cart along the path.\nVisual design:\n- Nodes are big circles with labels. Paths are lines. Gates are colored rectangles with text. The bread cart is a small square with a bread icon label 'pan'.\nEducational content (target sentences and correct gates):\n- Targets (randomized):\n  - {\"native_language\":\"I deliver bread to the café.\",\"target_language\":\"Entrego pan al café.\"} -> use 'a' gate at fork; avoid 'en'.\n  - {\"native_language\":\"I deliver bread at the café.\",\"target_language\":\"Entrego pan en el café.\"} -> use 'en' gate.\n- Vocabulary labels:\n  - {\"native_language\":\"bakery\",\"target_language\":\"panadería\"}\n  - {\"native_language\":\"café\",\"target_language\":\"café\"}\n  - {\"native_language\":\"deliver\",\"target_language\":\"entregar\"}\n- UI text:\n  - {\"native_language\":\"Go\",\"target_language\":\"Ir\"}\n  - {\"native_language\":\"Choose the gates\",\"target_language\":\"Elige las puertas\"}\n  - {\"native_language\":\"Correct route!\",\"target_language\":\"¡Ruta correcta!\"}\n  - {\"native_language\":\"Wrong gate. Try again.\",\"target_language\":\"Puerta incorrecta. Intenta de nuevo.\"}\nWin/Lose:\n- 4 routes to complete. Win if 3/4 routes are correct. On each attempt, wrong gate turns red and cart stops.\nAnimations:\n- Cart moves along path with a small trail; correct route makes the café node glow.",
      "skill_points": 18,
      "lua_code": "local W, H = 0, 0\nlocal cx, cy = 0, 0\n\nlocal nodes = {}\nlocal gates1 = {}\nlocal gates2 = {}\n\nlocal selected = {g1=nil, g2=nil}\nlocal hoverGate = nil\n\nlocal buttonGo = {x=0,y=0,w=0,h=0}\n\nlocal cart = {x=0,y=0,size=16,moving=false,points={},seg=1,segS=0,segLen=1,speed=240,trail={},stopAtPoint=nil}\nlocal wrongAt = nil\nlocal wrongGateFlash = 0\n\nlocal state = \"select\"\nlocal roundTotal = 4\nlocal roundIndex = 1\nlocal correctCount = 0\n\nlocal nextTimer = 0\nlocal endTimer = 0\nlocal successGlow = 0\n\nlocal msg = \"\"\nlocal msgTime = 0\n\nlocal targets = {\n  {en=\"I deliver bread to the café.\", es=\"Entrego pan al café.\", correct={\"a\",\"al\"}},\n  {en=\"I deliver bread at the café.\", es=\"Entrego pan en el café.\", correct={\"en\",\"el\"}},\n}\n\nlocal vocab = {\n  {en=\"bread\", es=\"pan\"},\n  {en=\"café (coffee shop)\", es=\"café\"},\n  {en=\"deliver\", es=\"entregar\"},\n}\n\nlocal grammar = {\n  {en=\"Present: entrego/entregas (recognition)\", es=\"Presente: entrego/entregas (reconocimiento)\"},\n  {en=\"Prepositions: a, en\", es=\"Preposiciones: a, en\"},\n}\n\nlocal currentTarget = nil\n\nlocal function clamp(v,a,b) if v<a then return a elseif v>b then return b else return v end end\nlocal function lerp(a,b,t) return a+(b-a)*t end\n\nlocal function pointInRect(px,py, rx,ry,rw,rh)\n  return px>=rx and px<=rx+rw and py>=ry and py<=ry+rh\nend\n\nlocal function pickTarget()\n  currentTarget = targets[ randomInt(1,#targets) ]\nend\n\nlocal function recalcLayout()\n  W = getScreenWidth()\n  H = getScreenHeight()\n  cx, cy = W*0.5, H*0.55\n\n  nodes.left = {x=W*0.15, y=cy, r=44}\n  nodes.right = {x=W*0.85, y=cy, r=48}\n\n  local gW, gH = 70, 90\n  local g1x = lerp(nodes.left.x, nodes.right.x, 0.38)\n  local g2x = lerp(nodes.left.x, nodes.right.x, 0.62)\n  local off1 = 90\n  local off2 = 70\n  gates1 = {\n    {label=\"a\",  x=g1x- gW*0.5, y=cy-off1-gH*0.5, w=gW, h=gH, fork=1, lane=\"up\"},\n    {label=\"en\", x=g1x- gW*0.5, y=cy+off1-gH*0.5, w=gW, h=gH, fork=1, lane=\"down\"},\n  }\n  gates2 = {\n    {label=\"al\", x=g2x- gW*0.5, y=cy-off2-gH*0.5, w=gW, h=gH, fork=2, lane=\"up\"},\n    {label=\"el\", x=g2x- gW*0.5, y=cy+off2-gH*0.5, w=gW, h=gH, fork=2, lane=\"down\"},\n  }\n\n  buttonGo.w, buttonGo.h = 140, 48\n  buttonGo.x = cx - buttonGo.w*0.5\n  buttonGo.y = H - 70\nend\n\nlocal function gateCenter(g)\n  return g.x + g.w*0.5, g.y + g.h*0.5\nend\n\nlocal function gateByLabel(label)\n  for _,g in ipairs(gates1) do if g.label==label then return g end end\n  for _,g in ipairs(gates2) do if g.label==label then return g end end\n  return nil\nend\n\nlocal function resetCartPath()\n  local p = {}\n  table.insert(p, {x=nodes.left.x, y=nodes.left.y})\n  if selected.g1 then\n    local g1 = selected.g1\n    local gx,gy = gateCenter(g1)\n    table.insert(p, {x=gx, y=gy})\n  end\n  if selected.g2 then\n    local g2 = selected.g2\n    local gx,gy = gateCenter(g2)\n    table.insert(p, {x=gx, y=gy})\n  end\n  table.insert(p, {x=nodes.right.x, y=nodes.right.y})\n\n  cart.points = p\n  cart.seg = 1\n  cart.segS = 0\n  cart.trail = {}\n  cart.stopAtPoint = nil\n\n  cart.x = p[1].x\n  cart.y = p[1].y\n\n  if wrongAt == 1 then cart.stopAtPoint = 2\n  elseif wrongAt == 2 then cart.stopAtPoint = 3\n  else cart.stopAtPoint = nil end\n\n  local a = p[1]; local b = p[2]\n  local dx,dy = b.x-a.x, b.y-a.y\n  cart.segLen = math.sqrt(dx*dx+dy*dy)\nend\n\nlocal function startRun()\n  if not selected.g1 or not selected.g2 then\n    msg = \"Elige las puertas (Choose the gates)\"\n    msgTime = 1.2\n    return\n  end\n\n  wrongAt = nil\n  local corr = currentTarget.correct\n  if selected.g1.label ~= corr[1] then\n    wrongAt = 1\n  elseif selected.g2.label ~= corr[2] then\n    wrongAt = 2\n  end\n\n  resetCartPath()\n  cart.moving = true\n  state = \"anim\"\n  wrongGateFlash = 0\n  msg = \"\"\n  msgTime = 0\nend\n\nlocal function finishRun(correct)\n  cart.moving = false\n  if correct then\n    correctCount = correctCount + 1\n    msg = \"¡Ruta correcta! (Correct route!)\"\n    msgTime = 1.4\n    successGlow = 0.9\n  else\n    msg = \"Puerta incorrecta. Intenta de nuevo. (Wrong gate)\"\n    msgTime = 1.6\n  end\n\n  roundIndex = roundIndex + 1\n  if roundIndex > roundTotal then\n    state = \"end\"\n    endTimer = 2.2\n  else\n    state = \"pauseBetween\"\n    nextTimer = 1.3\n  end\nend\n\nlocal function startRound()\n  pickTarget()\n  selected.g1 = nil\n  selected.g2 = nil\n  wrongAt = nil\n  cart.moving = false\n  cart.trail = {}\n  msg = \"Elige las puertas (Choose the gates)\"\n  msgTime = 2.0\nend\n\nfunction init()\n  randomSeed(os.time())\n  recalcLayout()\n  startRound()\nend\n\nlocal function updateCart(dt)\n  if not cart.moving then return end\n\n  wrongGateFlash = wrongGateFlash + dt*3.0\n\n  local p = cart.points\n  local a = p[cart.seg]\n  local b = p[cart.seg+1]\n  local dx,dy = b.x-a.x, b.y-a.y\n  local len = cart.segLen\n  if len < 0.0001 then\n    cart.segS = len\n  else\n    cart.segS = cart.segS + cart.speed*dt\n  end\n  local t = clamp(cart.segS/len, 0, 1)\n  cart.x = lerp(a.x, b.x, t)\n  cart.y = lerp(a.y, b.y, t)\n\n  table.insert(cart.trail, {x=cart.x, y=cart.y, life=1.0})\n  if #cart.trail > 60 then table.remove(cart.trail,1) end\n  for i=#cart.trail,1,-1 do\n    cart.trail[i].life = cart.trail[i].life - dt*2.8\n    if cart.trail[i].life <= 0 then table.remove(cart.trail,i) end\n  end\n\n  if cart.segS >= len - 0.0001 then\n    cart.seg = cart.seg + 1\n    if cart.stopAtPoint and cart.seg == cart.stopAtPoint then\n      finishRun(false)\n      return\n    end\n    if cart.seg >= #p then\n      finishRun(true)\n      return\n    else\n      local a2 = p[cart.seg]\n      local b2 = p[cart.seg+1]\n      local ddx,ddy = b2.x-a2.x, b2.y-a2.y\n      cart.segLen = math.sqrt(ddx*ddx+ddy*ddy)\n      cart.segS = 0\n    end\n  end\nend\n\nfunction update(dt)\n  recalcLayout()\n\n  if msgTime > 0 then\n    msgTime = msgTime - dt\n    if msgTime < 0 then msgTime = 0 end\n  end\n\n  if successGlow > 0 then\n    successGlow = successGlow - dt*0.7\n    if successGlow < 0 then successGlow = 0 end\n  end\n\n  if state == \"anim\" then\n    updateCart(dt)\n  elseif state == \"pauseBetween\" then\n    nextTimer = nextTimer - dt\n    if nextTimer <= 0 then\n      startRound()\n      state = \"select\"\n    end\n  elseif state == \"end\" then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      if correctCount >= 3 then\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n  end\n\n  hoverGate = nil\n  local mx, my = getMouseX(), getMouseY()\n\n  if state == \"select\" then\n    -- Hover detection\n    for _,g in ipairs(gates1) do\n      if pointInRect(mx,my,g.x,g.y,g.w,g.h) then hoverGate = g end\n    end\n    for _,g in ipairs(gates2) do\n      if pointInRect(mx,my,g.x,g.y,g.w,g.h) then hoverGate = g end\n    end\n\n    if isMouseJustPressed() then\n      local clicked = false\n      for _,g in ipairs(gates1) do\n        if pointInRect(mx,my,g.x,g.y,g.w,g.h) then\n          selected.g1 = g\n          clicked = true\n          break\n        end\n      end\n      for _,g in ipairs(gates2) do\n        if pointInRect(mx,my,g.x,g.y,g.w,g.h) then\n          selected.g2 = g\n          clicked = true\n          break\n        end\n      end\n      if not clicked and pointInRect(mx,my,buttonGo.x,buttonGo.y,buttonGo.w,buttonGo.h) then\n        startRun()\n      end\n    end\n  elseif state == \"anim\" then\n    -- allow no clicks\n  elseif state == \"pauseBetween\" then\n    -- no input\n  elseif state == \"end\" then\n    -- no input\n  end\nend\n\nlocal function drawGate(g, highlightColor, isSelected, isWrong)\n  local baseCol = isWrong and \"#FF4D4D\" or (isSelected and \"#7ED957\" or \"#88B4FF\")\n  local fillCol = isWrong and rgba(255,77,77,160) or (isSelected and rgba(126,217,87,160) or rgba(136,180,255,120))\n  local outline = isWrong and \"#FF0000\" or (highlightColor or \"#3A5FCD\")\n  drawRoundedRect(g.x, g.y, g.w, g.h, 12, fillCol, true)\n  drawRoundedRect(g.x, g.y, g.w, g.h, 12, outline, false, isSelected and 4 or 2)\n  -- top lintel line\n  drawLine(g.x+8, g.y+18, g.x+g.w-8, g.y+18, rgba(0,0,0,40), 2)\n  local tx, ty = g.x+g.w*0.5, g.y+g.h*0.5\n  drawText(g.label, tx-6, ty-10, \"#0A1A2F\", 26, \"monospace\")\nend\n\nlocal function drawNode(node, label, subtitle, glow)\n  local inner = \"#FFFFFF\"\n  local outer = \"#DCEBFF\"\n  if glow and glow > 0 then\n    setBlendMode(\"add\")\n    local pulses = 3\n    for i=1,pulses do\n      local r = node.r + i*8 + math.sin(getTime()*3 + i)*2\n      local a = clamp(180 - i*50, 0, 255)\n      drawRadialGradient(node.x, node.y, r, rgba(120,200,255, a), rgba(0,0,0,0))\n    end\n    setBlendMode(\"normal\")\n  end\n  drawRadialGradient(node.x, node.y, node.r, inner, outer)\n  drawCircle(node.x, node.y, node.r, rgba(0,0,0,40), false, 2)\n  local tw,th = measureText(label, 22)\n  drawText(label, node.x - tw*0.5, node.y - 12, \"#0B2545\", 22, \"monospace\")\n  if subtitle then\n    local tw2,th2 = measureText(subtitle, 14)\n    drawText(subtitle, node.x - tw2*0.5, node.y + 12, rgba(11,37,69,180), 14, \"monospace\")\n  end\n}\n\nlocal function drawPaths()\n  local col = rgba(50,80,120,70)\n  local thick = 3\n\n  -- From left to gates1\n  for _,g in ipairs(gates1) do\n    local gx,gy = gateCenter(g)\n    drawLine(nodes.left.x, nodes.left.y, gx, gy, col, thick)\n  end\n\n  -- From each gate1 to each gate2\n  for _,g1 in ipairs(gates1) do\n    local x1,y1 = gateCenter(g1)\n    for _,g2 in ipairs(gates2) do\n      local x2,y2 = gateCenter(g2)\n      drawLine(x1, y1, x2, y2, rgba(50,80,120,40), 2)\n    end\n  end\n\n  -- From gates2 to right\n  for _,g in ipairs(gates2) do\n    local gx,gy = gateCenter(g)\n    drawLine(gx, gy, nodes.right.x, nodes.right.y, col, thick)\n  end\nend\n\nlocal function drawTrail()\n  setBlendMode(\"add\")\n  for i=1,#cart.trail do\n    local p = cart.trail[i]\n    local a = clamp(math.floor(255*p.life), 0, 255)\n    local size = 3 + (1-p.life)*4\n    drawCircle(p.x, p.y, size, rgba(255,190,90, a), true)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawCart()\n  drawTrail()\n  local s = cart.size\n  local bx,by = cart.x, cart.y\n  local bodyCol = \"#F2C078\"\n  local edgeCol = \"#C2803D\"\n  drawRoundedRect(bx - s*0.7, by - s*0.45, s*1.4, s*0.9, 6, bodyCol, true)\n  drawRoundedRect(bx - s*0.7, by - s*0.45, s*1.4, s*0.9, 6, edgeCol, false, 2)\n  drawText(\"pan\", bx - 12, by - 8, \"#5A3B1E\", 16, \"monospace\")\n  drawCircle(bx - s*0.45, by + s*0.55, 4, \"#333333\", true)\n  drawCircle(bx + s*0.45, by + s*0.55, 4, \"#333333\", true)\nend\n\nfunction draw()\n  local bg1 = \"#F7FBFF\"\n  local bg2 = \"#E8F4FF\"\n  drawGradientRect(0,0,W,H,bg1,bg2,true)\n\n  -- Header and target sentence\n  local title = \"Rutas del Pan — Bread Run Routes\"\n  local tw, th = measureText(title, 22)\n  drawText(title, cx - tw*0.5, 14, \"#0B2545\", 22, \"monospace\")\n\n  local sub1 = currentTarget and (currentTarget.es) or \"\"\n  local sub2 = currentTarget and (\"(\"..currentTarget.en..\")\") or \"\"\n  local sw1,sh1 = measureText(sub1, 20)\n  drawText(sub1, cx - sw1*0.5, 44, \"#103B73\", 20, \"monospace\")\n  local sw2,sh2 = measureText(sub2, 14)\n  drawText(sub2, cx - sw2*0.5, 44+sh1+2, rgba(16,59,115,180), 14, \"monospace\")\n\n  -- Sidebar: instructions, score, vocab, grammar\n  local panelX, panelY, panelW, panelH = 18, 90, 260, 170\n  drawRoundedRect(panelX, panelY, panelW, panelH, 10, rgba(255,255,255,200), true)\n  drawRoundedRect(panelX, panelY, panelW, panelH, 10, rgba(16,59,115,40), false, 2)\n  drawText(\"Elige las puertas (Choose the gates)\", panelX+12, panelY+10, \"#0B2545\", 14, \"monospace\")\n  drawText(\"Ronda: \"..tostring(math.min(roundIndex, roundTotal))..\"/\"..tostring(roundTotal), panelX+12, panelY+34, \"#103B73\", 16, \"monospace\")\n  drawText(\"Aciertos: \"..tostring(correctCount), panelX+12, panelY+58, \"#0F7B3F\", 16, \"monospace\")\n\n  local yv = panelY+84\n  drawText(\"Vocabulario:\", panelX+12, yv, \"#0B2545\", 14, \"monospace\")\n  yv = yv + 18\n  for _,v in ipairs(vocab) do\n    drawText(\"- \"..v.es..\" (\"..v.en..\")\", panelX+18, yv, rgba(11,37,69,200), 13, \"monospace\")\n    yv = yv + 16\n  end\n\n  local yg = panelY + panelH + 8\n  local gh = 56\n  drawRoundedRect(panelX, yg, panelW, gh, 10, rgba(255,255,255,200), true)\n  drawRoundedRect(panelX, yg, panelW, gh, 10, rgba(16,59,115,40), false, 2)\n  drawText(\"Gramática:\", panelX+12, yg+8, \"#0B2545\", 14, \"monospace\")\n  drawText(\"- \"..grammar[1].es, panelX+18, yg+26, rgba(11,37,69,200), 12, \"monospace\")\n  drawText(\"- \"..grammar[2].es, panelX+18, yg+42, rgba(11,37,69,200), 12, \"monospace\")\n\n  -- Map: paths and nodes\n  drawPaths()\n  drawNode(nodes.left, \"Panadería\", \"(bakery)\", false)\n  local glowRight = (state==\"anim\" and wrongAt==nil) or (successGlow>0)\n  drawNode(nodes.right, \"Café\", \"(café)\", glowRight and (successGlow>0 and successGlow or 0.2) or 0)\n\n  -- Gates\n  for _,g in ipairs(gates1) do\n    local isSel = selected.g1 and selected.g1 == g\n    local isWrong = (state==\"anim\" or state==\"pauseBetween\") and wrongAt==1 and selected.g1==g\n    local hover = hoverGate==g\n    local hl = hover and \"#4F8EF7\" or \"#3A5FCD\"\n    if isWrong then\n      local pulse = 0.5 + 0.5*math.abs(math.sin(wrongGateFlash*3))\n      hl = rgba(255,80,80, 100 + math.floor(100*pulse))\n    end\n    drawGate(g, hl, isSel, isWrong)\n  end\n  for _,g in ipairs(gates2) do\n    local isSel = selected.g2 and selected.g2 == g\n    local isWrong = (state==\"anim\" or state==\"pauseBetween\") and wrongAt==2 and selected.g2==g\n    local hover = hoverGate==g\n    local hl = hover and \"#4F8EF7\" or \"#3A5FCD\"\n    if isWrong then\n      local pulse = 0.5 + 0.5*math.abs(math.sin(wrongGateFlash*3))\n      hl = rgba(255,80,80, 100 + math.floor(100*pulse))\n    end\n    drawGate(g, hl, isSel, isWrong)\n  end\n\n  -- Gate labels hints\n  local hintY = H*0.82\n  drawText(\"Puertas 1: a / en\", cx-120, hintY, rgba(11,37,69,200), 14, \"monospace\")\n  drawText(\"Puertas 2: al / el\", cx+20, hintY, rgba(11,37,69,200), 14, \"monospace\")\n\n  -- Button Go\n  local mx,my = getMouseX(),getMouseY()\n  local hoverGo = pointInRect(mx,my,buttonGo.x,buttonGo.y,buttonGo.w,buttonGo.h)\n  local btnCol = hoverGo and \"#49C773\" or \"#36B26A\"\n  drawRoundedRect(buttonGo.x, buttonGo.y, buttonGo.w, buttonGo.h, 10, btnCol, true)\n  drawRoundedRect(buttonGo.x, buttonGo.y, buttonGo.w, buttonGo.h, 10, rgba(0,0,0,60), false, 2)\n  local bt = \"Ir (Go)\"\n  local btw,bth = measureText(bt, 20)\n  drawText(bt, buttonGo.x + buttonGo.w*0.5 - btw*0.5, buttonGo.y + buttonGo.h*0.5 - bth*0.6, \"#FFFFFF\", 20, \"monospace\")\n\n  -- Cart\n  if state==\"select\" then\n    -- show idle cart at start\n    cart.x, cart.y = nodes.left.x, nodes.left.y\n    drawCart()\n  else\n    drawCart()\n  end\n\n  -- Feedback message\n  if msgTime > 0 then\n    local a = clamp(math.floor(255 * math.min(1, msgTime)), 0, 255)\n    local y = 100\n    local mw,mh = measureText(msg, 20)\n    drawRoundedRect(cx - mw*0.5 - 14, y-6, mw+28, 36, 10, rgba(255,255,255, 180), true)\n    drawRoundedRect(cx - mw*0.5 - 14, y-6, mw+28, 36, 10, rgba(16,59,115, 50), false, 2)\n    drawText(msg, cx - mw*0.5, y, rgba(16,59,115, a), 20, \"monospace\")\n  end\n\n  -- Final overlay\n  if state==\"end\" then\n    local win = correctCount >= 3\n    local overlay = win and rgba(40,180,80,200) or rgba(220,60,60,200)\n    drawGradientRect(0,0,W,H, rgba(0,0,0,60), rgba(0,0,0,120), true)\n    local bw,bh = W*0.7, 160\n    local bx,by = (W-bw)*0.5, (H-bh)*0.5\n    drawRoundedRect(bx,by,bw,bh,16, rgba(255,255,255,220), true)\n    drawRoundedRect(bx,by,bw,bh,16, overlay, false, 6)\n    local txt = win and \"¡Ganaste! 3/4 aciertos o más\" or \"Fin del juego. Menos de 3 aciertos\"\n    local txt2 = win and \"(You win!)\" or \"(You lose)\"\n    local t1w,t1h = measureText(txt, 28)\n    drawText(txt, cx - t1w*0.5, by + 40, \"#0B2545\", 28, \"monospace\")\n    local t2w,t2h = measureText(txt2, 18)\n    drawText(txt2, cx - t2w*0.5, by + 40 + t1h + 6, rgba(11,37,69,200), 18, \"monospace\")\n  end\n\n  -- Footer hints\n  drawText(\"Objetivo: combina preposiciones correctas para la ruta.\", 20, H-24, rgba(11,37,69,180), 14, \"monospace\")\nend",
      "id": "game_9_bread_run_routes",
      "trigger_id": "npc_10_ana",
      "trigger_type": "npc",
      "related_quest_id": "quest_34_bread_run"
    },
    {
      "name": {
        "native_language": "Stone-Blue Friend Flip",
        "target_language": "Voltea amigo piedra-azul"
      },
      "description": {
        "native_language": "A tiny twist on memory: match words to build the park message and read it aloud.",
        "target_language": "Un giro pequeño de memoria: empareja palabras para formar el mensaje del parque y léelo en voz alta."
      },
      "language_level": "A0",
      "target_vocabulary": [
        {
          "native_language": "water bottle",
          "target_language": "botella de agua"
        },
        {
          "native_language": "street",
          "target_language": "calle"
        },
        {
          "native_language": "park",
          "target_language": "parque"
        }
      ],
      "grammar_focus": [
        {
          "native_language": "Imperatives (review): Lee, Encuentra",
          "target_language": "Imperativos (repaso): Lee, Encuentra"
        },
        {
          "native_language": "Present tense tiny reading: es",
          "target_language": "Pequeña lectura en presente: es"
        }
      ],
      "game_prompt": "Note: This is an alternate street puzzle tied to the same quest setting, but ensure only one game per quest overall. Use this as a micro-variation ONLY if the engine requests a second mini-stage; otherwise, keep it disabled.\nMechanics (if used): simple 4-card flip to reveal the phrase {\"native_language\":\"The park is on this street.\",\"target_language\":\"El parque está en esta calle.\"}. However, by default, do not trigger this stage to preserve the 'exactly one game per quest' rule.",
      "skill_points": 0,
      "lua_code": "local cards = {}\nlocal selected = {}\nlocal score = 0\nlocal mistakes = 0\nlocal maxMistakes = 3\nlocal matches = 0\nlocal lockInput = false\nlocal flipBackTimer = 0\nlocal gameState = \"disabled\"\nlocal stageEnabled = false\nlocal winTimer = 0\nlocal loseTimer = 0\nlocal particles = {}\nlocal unlockTapCount = 0\nlocal lastTapTime = 0\nlocal unlockWindow = 1.25\nlocal demoActivated = false\nlocal title = \"Stone-Blue Friend Flip\"\nlocal vocabES = {\"botella de agua\",\"calle\",\"parque\"}\nlocal vocabEN = {\"water bottle\",\"street\",\"park\"}\nlocal phraseEN = \"The park is on this street.\"\nlocal phraseES = \"El parque está en esta calle.\"\nlocal instES = \"Lee y encuentra parejas EN↔ES\"\nlocal instEN = \"(Read and match: English ↔ Español)\"\nlocal width = 0\nlocal height = 0\nlocal cardW = 0\nlocal cardH = 0\nlocal cardSpacing = 0\nlocal gridOriginX = 0\nlocal gridOriginY = 0\nlocal timeSinceStart = 0\n\nlocal function shuffle(t)\n  for i = #t, 2, -1 do\n    local j = randomInt(1, i)\n    t[i], t[j] = t[j], t[i]\n  end\nend\n\nlocal function rectContains(x, y, w, h, px, py)\n  return px >= x and px <= x + w and py >= y and py <= y + h\nend\n\nlocal function drawCenteredText(text, cx, cy, color, size, font)\n  local w, h = measureText(text, size or 18)\n  drawText(text, cx - w / 2, cy - h / 2, color, size or 18, font or \"monospace\")\nend\n\nlocal function spawnParticles(x, y, colorBase)\n  for i = 1, 18 do\n    local angle = random(0, math.pi * 2)\n    local speed = random(40, 120)\n    local vx = math.cos(angle) * speed\n    local vy = math.sin(angle) * speed\n    local life = random(0.6, 1.0)\n    local col = colorBase\n    table.insert(particles, {x = x, y = y, vx = vx, vy = vy, life = life, age = 0, color = col, size = random(2, 4)})\n  end\nend\n\nlocal function updateParticles(dt)\n  for i = #particles, 1, -1 do\n    local p = particles[i]\n    p.age = p.age + dt\n    p.x = p.x + p.vx * dt\n    p.y = p.y + p.vy * dt\n    p.vy = p.vy + 40 * dt\n    if p.age >= p.life then\n      table.remove(particles, i)\n    end\n  end\nend\n\nlocal function drawParticles()\n  setBlendMode(\"add\")\n  for _, p in ipairs(particles) do\n    local t = 1 - (p.age / p.life)\n    local a = math.floor(255 * math.max(0, t))\n    local r = 255\n    local g = 255\n    local b = 200\n    local col = rgba(r, g, b, a)\n    drawCircle(p.x, p.y, p.size, col, true)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function layout()\n  width = getScreenWidth()\n  height = getScreenHeight()\n  local minD = math.min(width, height)\n  cardW = math.floor(minD * 0.28)\n  cardH = math.floor(cardW * 0.62)\n  cardSpacing = math.floor(cardW * 0.16)\n  local totalW = cardW * 2 + cardSpacing\n  local totalH = cardH * 2 + cardSpacing\n  gridOriginX = (width - totalW) * 0.5\n  gridOriginY = (height - totalH) * 0.5 + 10\nend\n\nlocal function createCards()\n  cards = {}\n  local defs = {\n    {pair = 1, lang = \"EN\", text = \"The park is\"},\n    {pair = 1, lang = \"ES\", text = \"El parque está\"},\n    {pair = 2, lang = \"EN\", text = \"on this street.\"},\n    {pair = 2, lang = \"ES\", text = \"en esta calle.\"}\n  }\n  local positions = {}\n  for r = 0, 1 do\n    for c = 0, 1 do\n      local x = gridOriginX + c * (cardW + cardSpacing)\n      local y = gridOriginY + r * (cardH + cardSpacing)\n      table.insert(positions, {x = x, y = y})\n    end\n  end\n  shuffle(positions)\n  shuffle(defs)\n  for i = 1, 4 do\n    local pos = positions[i]\n    local d = defs[i]\n    cards[i] = {\n      id = i,\n      pair = d.pair,\n      lang = d.lang,\n      text = d.text,\n      x = pos.x,\n      y = pos.y,\n      w = cardW,\n      h = cardH,\n      faceUp = false,\n      matched = false,\n      flipAnim = 0,\n      shake = 0,\n      glow = 0\n    }\n  end\nend\n\nlocal function resetGame()\n  score = 0\n  mistakes = 0\n  matches = 0\n  lockInput = false\n  flipBackTimer = 0\n  gameState = \"playing\"\n  winTimer = 0\n  loseTimer = 0\n  selected = {}\n  particles = {}\n  layout()\n  createCards()\nend\n\nfunction init()\n  randomSeed(os.time())\n  createSound(\"ok1\", 880, 0.08, 0.4, \"sine\")\n  createSound(\"ok2\", 1320, 0.08, 0.4, \"sine\")\n  createSound(\"bad\", 200, 0.2, 0.4, \"square\")\n  createSound(\"flip\", 520, 0.05, 0.3, \"triangle\")\n  layout()\n  createCards()\nend\n\nlocal function checkUnlock()\n  if isMouseJustPressed() then\n    local t = getTime()\n    if t - lastTapTime <= 0.35 then\n      unlockTapCount = unlockTapCount + 1\n    else\n      unlockTapCount = 1\n    end\n    lastTapTime = t\n    if unlockTapCount >= 5 then\n      stageEnabled = true\n      demoActivated = true\n      resetGame()\n    end\n  end\nend\n\nlocal function onCardClicked(c)\n  if c.matched or c.faceUp then return end\n  c.faceUp = true\n  playSound(\"flip\")\n  table.insert(selected, c)\n  if #selected == 2 then\n    lockInput = true\n    local a = selected[1]\n    local b = selected[2]\n    if a.pair == b.pair and a.lang ~= b.lang then\n      a.matched = true\n      b.matched = true\n      a.glow = 1\n      b.glow = 1\n      score = score + 1\n      matches = matches + 1\n      playSound(\"ok1\")\n      playSound(\"ok2\")\n      spawnParticles(a.x + a.w / 2, a.y + a.h / 2, rgb(180, 255, 200))\n      spawnParticles(b.x + b.w / 2, b.y + b.h / 2, rgb(180, 255, 200))\n      selected = {}\n      lockInput = false\n      if matches >= 2 then\n        gameState = \"won\"\n        winTimer = 0\n      end\n    else\n      score = score - 1\n      mistakes = mistakes + 1\n      a.shake = 0.5\n      b.shake = 0.5\n      playSound(\"bad\")\n      flipBackTimer = 0.75\n    end\n  end\nend\n\nlocal function updateCards(dt)\n  for _, c in ipairs(cards) do\n    local target = (c.faceUp or c.matched) and 1 or 0\n    c.flipAnim = c.flipAnim + (target - c.flipAnim) * math.min(1, dt * 10)\n    if c.shake > 0 then\n      c.shake = math.max(0, c.shake - dt)\n    end\n    if c.glow > 0 then\n      c.glow = math.max(0, c.glow - dt * 0.8)\n    end\n  end\nend\n\nlocal function handleFlipBack(dt)\n  if flipBackTimer > 0 then\n    flipBackTimer = flipBackTimer - dt\n    if flipBackTimer <= 0 then\n      if #selected == 2 then\n        selected[1].faceUp = false\n        selected[2].faceUp = false\n      end\n      selected = {}\n      lockInput = false\n      if mistakes >= maxMistakes then\n        gameState = \"lost\"\n        loseTimer = 0\n      end\n    end\n  end\nend\n\nfunction update(dt)\n  timeSinceStart = getTime()\n  layout()\n  if gameState == \"disabled\" then\n    checkUnlock()\n  elseif gameState == \"playing\" then\n    updateCards(dt)\n    updateParticles(dt)\n    handleFlipBack(dt)\n    if isMouseJustPressed() and not lockInput then\n      local mx = getMouseX()\n      local my = getMouseY()\n      for _, c in ipairs(cards) do\n        local sx = 0\n        if c.shake > 0 then\n          sx = math.sin(timeSinceStart * 40) * 6 * c.shake\n        end\n        if rectContains(c.x + sx, c.y, c.w, c.h, mx, my) then\n          onCardClicked(c)\n          break\n        end\n      end\n    end\n  elseif gameState == \"won\" then\n    updateParticles(dt)\n    winTimer = winTimer + dt\n    if winTimer > 0.5 and isMouseJustPressed() then\n      halt(2)\n    end\n    if winTimer > 2.2 then\n      halt(2)\n    end\n  elseif gameState == \"lost\" then\n    updateParticles(dt)\n    loseTimer = loseTimer + dt\n    if loseTimer > 0.5 and isMouseJustPressed() then\n      halt(1)\n    end\n    if loseTimer > 2.2 then\n      halt(1)\n    end\n  end\nend\n\nlocal function drawBackground()\n  drawGradientRect(0, 0, width, height, \"#0D223A\", \"#1C3C5D\", true)\n  setBlendMode(\"add\")\n  local cx = width * 0.5\n  local cy = height * 0.28\n  drawRadialGradient(cx - width * 0.18, cy - 20, math.min(width, height) * 0.35, rgba(120, 200, 255, 80), rgba(30, 80, 140, 0))\n  drawRadialGradient(cx + width * 0.18, cy + 10, math.min(width, height) * 0.35, rgba(160, 220, 200, 60), rgba(30, 80, 140, 0))\n  setBlendMode(\"normal\")\nend\n\nlocal function drawHeader()\n  local topY = 20\n  drawCenteredText(title, width * 0.5, topY + 10, \"#E6F2FF\", 28, \"monospace\")\n  drawCenteredText(instES .. \"  \" .. instEN, width * 0.5, topY + 42, \"#CDE6FF\", 16, \"monospace\")\n  local scoreText = \"Puntuación: \" .. tostring(score) .. \"   Fallos: \" .. tostring(mistakes) .. \"/\" .. tostring(maxMistakes)\n  drawText(scoreText, 16, 18, \"#FFFFFF\", 18, \"monospace\")\nend\n\nlocal function drawFooter()\n  local y = height - 82\n  local sub = \"Vocabulario: \" .. table.concat(vocabES, \", \") .. \"  |  Vocabulary: \" .. table.concat(vocabEN, \", \")\n  drawCenteredText(sub, width * 0.5, y, \"#C6ECFF\", 16, \"monospace\")\n  local gram = \"Gramática: Imperativos (repaso): Lee, Encuentra · Presente: es  |  Grammar: Imperatives (review): Read, Find · Present: is\"\n  drawCenteredText(gram, width * 0.5, y + 26, \"#C6ECFF\", 14, \"monospace\")\nend\n\nlocal function drawCard(c)\n  local cx = c.x + c.w / 2\n  local cy = c.y + c.h / 2\n  local sx = 1\n  local shakeOffset = 0\n  if c.shake > 0 then\n    shakeOffset = math.sin(timeSinceStart * 40) * 6 * c.shake\n  end\n  local pulse = 1 + 0.03 * math.sin(timeSinceStart * 6 + c.id)\n  sx = 0.96 + 0.04 * c.flipAnim\n  pushTransform()\n  translate(shakeOffset + cx, cy)\n  scale(sx * pulse, 1.0)\n  local backCol = \"#294C73\"\n  local frontColEN = \"#82B1FF\"\n  local frontColES = \"#A5D6A7\"\n  local frontCol = (c.lang == \"EN\") and frontColEN or frontColES\n  local fillCol = c.faceUp or c.matched and frontCol or backCol\n  drawRoundedRect(-c.w / 2, -c.h / 2, c.w, c.h, 18, fillCol, true)\n  local strokeCol = rgba(255, 255, 255, 40)\n  drawRoundedRect(-c.w / 2, -c.h / 2, c.w, c.h, 18, strokeCol, false, 2)\n  if c.glow > 0 then\n    setBlendMode(\"add\")\n    local a = math.floor(120 * c.glow)\n    drawRoundedRect(-c.w / 2 - 2, -c.h / 2 - 2, c.w + 4, c.h + 4, 22, rgba(100, 255, 180, a), false, 6)\n    setBlendMode(\"normal\")\n  end\n  if c.faceUp or c.matched then\n    local tA = math.floor(80 + 175 * c.flipAnim)\n    local txtCol = rgba(10, 25, 35, 255)\n    local label = (c.lang == \"EN\") and \"[EN]\" or \"[ES]\"\n    drawCenteredText(label, 0, -c.h * 0.32, rgba(255, 255, 255, tA), 14, \"monospace\")\n    drawCenteredText(c.text, 0, 0, txtCol, 18, \"monospace\")\n  else\n    setBlendMode(\"add\")\n    drawCircle(0, 0, 16, rgba(180, 220, 255, 60), true)\n    setBlendMode(\"normal\")\n    drawCenteredText(\"?\", 0, 0, \"#E8F6FF\", 26, \"monospace\")\n  end\n  popTransform()\nend\n\nlocal function drawCards()\n  for _, c in ipairs(cards) do\n    drawCard(c)\n  end\nend\n\nlocal function drawDisabledOverlay()\n  local boxW = math.min(width * 0.86, 620)\n  local boxH = 220\n  local x = (width - boxW) / 2\n  local y = height * 0.55 - boxH / 2\n  setBlendMode(\"multiply\")\n  drawRect(0, 0, width, height, rgba(0, 0, 0, 120), true)\n  setBlendMode(\"normal\")\n  drawRoundedRect(x, y, boxW, boxH, 16, \"#14324D\", true)\n  drawRoundedRect(x, y, boxW, boxH, 16, rgba(255, 255, 255, 40), false, 2)\n  drawCenteredText(\"Etapa alterna DESACTIVADA por defecto\", width * 0.5, y + 36, \"#FFFFFF\", 20, \"monospace\")\n  drawCenteredText(\"Se usa solo si el motor solicita un segundo mini-nivel.\", width * 0.5, y + 66, \"#D6EFFB\", 16, \"monospace\")\n  drawCenteredText(\"Demo manual: toca/click 5 veces rápidas para activar\", width * 0.5, y + 96, \"#C0F0FF\", 16, \"monospace\")\n  local barX = x + 40\n  local barY = y + boxH - 64\n  local barW = boxW - 80\n  local barH = 18\n  drawRoundedRect(barX, barY, barW, barH, 9, \"#0E2740\", true)\n  local pct = math.min(1, unlockTapCount / 5)\n  drawRoundedRect(barX, barY, barW * pct, barH, 9, \"#3DB4FF\", true)\n  drawCenteredText(\"Progreso: \" .. tostring(unlockTapCount) .. \"/5\", width * 0.5, barY + barH / 2, \"#FFFFFF\", 14, \"monospace\")\n  if demoActivated then\n    drawCenteredText(\"DEMO activada\", width * 0.5, y + boxH + 20, \"#9BE7C4\", 16, \"monospace\")\n  end\nend\n\nlocal function drawWinOverlay()\n  setBlendMode(\"multiply\")\n  drawRect(0, 0, width, height, rgba(0, 0, 0, 140), true)\n  setBlendMode(\"normal\")\n  local boxW = math.min(width * 0.9, 680)\n  local boxH = 260\n  local x = (width - boxW) / 2\n  local y = (height - boxH) / 2\n  drawRoundedRect(x, y, boxW, boxH, 18, \"#123A2A\", true)\n  drawRoundedRect(x, y, boxW, boxH, 18, rgba(255, 255, 255, 50), false, 2)\n  drawCenteredText(\"¡Bien hecho!\", width * 0.5, y + 34, \"#D6FFE6\", 26, \"monospace\")\n  drawCenteredText(\"Frase: \" .. phraseES, width * 0.5, y + 78, \"#E8FFF2\", 20, \"monospace\")\n  drawCenteredText(\"Hint: \" .. phraseEN, width * 0.5, y + 108, \"#D0FFE8\", 16, \"monospace\")\n  drawCenteredText(\"Puntuación final: \" .. tostring(score), width * 0.5, y + 142, \"#FFFFFF\", 18, \"monospace\")\n  drawCenteredText(\"Click/toca para terminar\", width * 0.5, y + 184, \"#B8FFDC\", 16, \"monospace\")\nend\n\nlocal function drawLoseOverlay()\n  setBlendMode(\"multiply\")\n  drawRect(0, 0, width, height, rgba(0, 0, 0, 140), true)\n  setBlendMode(\"normal\")\n  local boxW = math.min(width * 0.9, 680)\n  local boxH = 220\n  local x = (width - boxW) / 2\n  local y = (height - boxH) / 2\n  drawRoundedRect(x, y, boxW, boxH, 18, \"#3A1212\", true)\n  drawRoundedRect(x, y, boxW, boxH, 18, rgba(255, 255, 255, 50), false, 2)\n  drawCenteredText(\"¡Ánimo! Inténtalo de nuevo\", width * 0.5, y + 40, \"#FFE6E6\", 24, \"monospace\")\n  drawCenteredText(\"Has alcanzado el límite de fallos (\" .. tostring(maxMistakes) .. \")\", width * 0.5, y + 78, \"#FFECEC\", 18, \"monospace\")\n  drawCenteredText(\"La frase objetivo era:\", width * 0.5, y + 112, \"#FFF6F6\", 16, \"monospace\")\n  drawCenteredText(phraseES .. \"  (\" .. phraseEN .. \")\", width * 0.5, y + 140, \"#FFFFFF\", 16, \"monospace\")\n  drawCenteredText(\"Click/toca para salir\", width * 0.5, y + 172, \"#FFD6D6\", 16, \"monospace\")\nend\n\nfunction draw()\n  clear(\"#0A2036\")\n  drawBackground()\n  if gameState == \"disabled\" then\n    drawHeader()\n    drawCards()\n    drawFooter()\n    drawDisabledOverlay()\n  elseif gameState == \"playing\" then\n    drawHeader()\n    drawCards()\n    drawParticles()\n    drawFooter()\n  elseif gameState == \"won\" then\n    drawHeader()\n    drawCards()\n    drawParticles()\n    drawWinOverlay()\n  elseif gameState == \"lost\" then\n    drawHeader()\n    drawCards()\n    drawParticles()\n    drawLoseOverlay()\n  end\nend",
      "id": "game_10_stone_blue_friend_flip",
      "trigger_id": "loc_2_calle_principal",
      "trigger_type": "location",
      "related_quest_id": "quest_12_message_of_the_main_street"
    }
  ],
  "_games_by_location": {
    "loc_6_caf_de_los_susurros": [
      "game_1_breakfast_bridges"
    ],
    "loc_1_fuente_de_bienvenida": [
      "game_6_welcome_gift_builder"
    ],
    "loc_3_parque_de_la_amistad": [
      "game_7_nature_scanner"
    ],
    "loc_4_puesto_de_fruta": [
      "game_8_fruit_catch_command"
    ],
    "loc_2_calle_principal": [
      "game_10_stone_blue_friend_flip"
    ]
  },
  "_games_by_npc": {
    "npc_1_marcos": [
      "game_2_street_shouts"
    ],
    "npc_2_sofia": [
      "game_3_friend_stone_memory"
    ],
    "npc_3_gloria": [
      "game_4_gloria_s_thirst"
    ],
    "npc_9_carlos": [
      "game_5_sweet_fruit_pop"
    ],
    "npc_10_ana": [
      "game_9_bread_run_routes"
    ]
  },
  "_games_by_quest": {
    "quest_2_bread_for_breakfast": [
      "game_1_breakfast_bridges"
    ],
    "quest_12_message_of_the_main_street": [
      "game_2_street_shouts",
      "game_10_stone_blue_friend_flip"
    ],
    "quest_13_amistad_en_el_parque": [
      "game_3_friend_stone_memory"
    ],
    "quest_22_gloria_s_request": [
      "game_4_gloria_s_thirst"
    ],
    "quest_23_sweet_fruit_delivery": [
      "game_5_sweet_fruit_pop"
    ],
    "quest_31_welcome_gift": [
      "game_6_welcome_gift_builder"
    ],
    "quest_32_nature_s_colors": [
      "game_7_nature_scanner"
    ],
    "quest_33_fruit_gathering": [
      "game_8_fruit_catch_command"
    ],
    "quest_34_bread_run": [
      "game_9_bread_run_routes"
    ]
  }
}