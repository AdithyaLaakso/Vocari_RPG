{
  "games": [
    {
      "name": {
        "native_language": "Lost Apple: Quick Click!",
        "target_language": "La manzana perdida: ¡Clic rápido!"
      },
      "description": {
        "native_language": "Click the right word to find the apple in the town square. Practice simple imperatives and questions.",
        "target_language": "Haz clic en la palabra correcta para encontrar la manzana en la plaza del pueblo. Practica imperativos y preguntas simples."
      },
      "language_level": "A0",
      "target_vocabulary": [
        "manzana",
        "plaza del pueblo",
        "encontrar"
      ],
      "grammar_focus": [
        "imperatives (Encuentra)",
        "basic questions (¿Dónde está...? ¿Es...?)"
      ],
      "game_prompt": "Design a simple click-based game with floating word bubbles. Mechanics: 1) Show a big red circle (apple icon) outline in the center with a question banner above it. 2) Three word bubbles drift left-right at the bottom: 'manzana', 'plaza del pueblo', 'encontrar'. 3) Each round shows a bilingual instruction at the top and the player clicks the correct Spanish word bubble or answers a yes/no card. Use very large font and slow movement. Visual design: sky-blue background; center area has a pale plaza square (light gray rectangle). Bubbles are soft rounded rectangles with white fill and colored borders (green for correct answer after click, red for wrong). Simple sparkle animation (small yellow dots) when correct. Educational content: Use ONLY these on-screen words/phrases (all bilingual objects): Instructions: [{\"native_language\":\"Find the apple!\",\"target_language\":\"¡Encuentra la manzana!\"},{\"native_language\":\"Where is the apple?\",\"target_language\":\"¿Dónde está la manzana?\"},{\"native_language\":\"Is this 'apple'?\",\"target_language\":\"¿Es 'manzana'?\"}] Clickable word bubbles: [{\"native_language\":\"apple\",\"target_language\":\"manzana\"},{\"native_language\":\"town square\",\"target_language\":\"plaza del pueblo\"},{\"native_language\":\"find\",\"target_language\":\"encontrar\"}] Yes/No buttons: [{\"native_language\":\"Yes\",\"target_language\":\"Sí\"},{\"native_language\":\"No\",\"target_language\":\"No\"}] UI: [{\"native_language\":\"Start\",\"target_language\":\"Iniciar\"},{\"native_language\":\"Next\",\"target_language\":\"Siguiente\"},{\"native_language\":\"Retry\",\"target_language\":\"Reintentar\"},{\"native_language\":\"Score\",\"target_language\":\"Puntuación\"}] Rounds: - Round 1: Show instruction 'Find the apple! / ¡Encuentra la manzana!' The correct click is the bubble with 'manzana'. - Round 2: Show a card in the center with the Spanish word 'plaza del pueblo'. Ask 'Is this \"apple\"? / ¿Es \"manzana\"?' with Yes/No buttons. Correct: No. - Round 3: Show instruction 'Find the apple! / ¡Encuentra la manzana!' again, shuffle bubbles. Correct: 'manzana'. Scoring: +1 per correct click. Win/Lose: Win if score >= 2 out of 3. On win, display: [{\"native_language\":\"You found it!\",\"target_language\":\"¡La encontraste!\"}] On lose, display: [{\"native_language\":\"Try again.\",\"target_language\":\"Inténtalo de nuevo.\"}] Animations: When correct, the apple outline fills with red over 0.5s and sparkles float up. When wrong, bubble shakes for 0.3s.",
      "skill_points": 12,
      "lua_code": "local W, H = 0, 0\nlocal t = 0\nlocal state = \"start\"\nlocal roundIndex = 0\nlocal substate = \"await\"\nlocal score = 0\nlocal maxRounds = 3\nlocal readyToProceed = false\nlocal endTimer = 0\n\nlocal apple = {x=0,y=0,r=0,fillActive=false,fillProgress=0}\n\nlocal instructions = {\n  {en=\"Find the apple!\", es=\"¡Encuentra la manzana!\"},\n  {en=\"Where is the apple?\", es=\"¿Dónde está la manzana?\"},\n  {en=\"Is this 'apple'?\", es=\"¿Es 'manzana'?\"}\n}\n\nlocal words = {\n  {es=\"manzana\", en=\"apple\"},\n  {es=\"plaza del pueblo\", en=\"town square\"},\n  {es=\"encontrar\", en=\"find\"}\n}\n\nlocal yn = {\n  yes={es=\"Sí\", en=\"Yes\"},\n  no ={es=\"No\", en=\"No\"}\n}\n\nlocal ui = {\n  start={es=\"Iniciar\", en=\"Start\"},\n  next ={es=\"Siguiente\", en=\"Next\"},\n  retry={es=\"Reintentar\", en=\"Retry\"},\n  score={es=\"Puntuación\", en=\"Score\"}\n}\n\nlocal rounds = {\n  {type=\"click\", instructionIndex=1, correctEs=\"manzana\"},\n  {type=\"yn\"   , instructionIndex=3, cardEs=\"plaza del pueblo\", correctAnswer=\"No\"},\n  {type=\"click\", instructionIndex=1, correctEs=\"manzana\"}\n}\n\nlocal bubbles = {}\nlocal bubbleBaseY = 0\nlocal lastClickedBubble = nil\n\nlocal startButton = {x=0,y=0,w=0,h=0}\nlocal nextButton = {x=0,y=0,w=0,h=0}\nlocal retryButton = {x=0,y=0,w=0,h=0}\nlocal yesButton = {x=0,y=0,w=0,h=0}\nlocal noButton = {x=0,y=0,w=0,h=0}\nlocal ynHighlight = {yes=nil, no=nil} -- \"correct\",\"wrong\", or nil\n\nlocal sparkles = {}\n\nlocal function clamp(x,a,b) if x<a then return a elseif x>b then return b else return x end end\nlocal function shuffle(list)\n  for i = #list, 2, -1 do\n    local j = randomInt(1, i)\n    list[i], list[j] = list[j], list[i]\n  end\nend\n\nlocal function isInsideRect(mx,my,r)\n  return mx>=r.x and my>=r.y and mx<=r.x+r.w and my<=r.y+r.h\nend\n\nlocal function spawnSparkles(n)\n  for i=1,n do\n    local ang = random(0, 2*math.pi)\n    local rad = random(0, apple.r*0.5)\n    local px = apple.x + math.cos(ang)*rad\n    local py = apple.y + math.sin(ang)*rad\n    local spd = random(40, 120)\n    local vx = math.cos(ang)*spd*0.3\n    local vy = -math.abs(math.sin(ang))*spd - random(30,90)\n    local life = random(0.6, 1.0)\n    table.insert(sparkles, {x=px, y=py, vx=vx, vy=vy, life=life, age=0, size=random(2,4)})\n  end\nend\n\nlocal function resetBubbles()\n  bubbles = {}\n  local padX = 30\n  local padY = 18\n  local fontES = 32\n  local fontEN = 18\n  local widths = {}\n  for i=1,#words do\n    local w1,_ = measureText(words[i].es, fontES)\n    local w2,_ = measureText(words[i].en, fontEN)\n    local w = math.max(w1, w2) + padX*2\n    widths[i] = w\n  end\n  local heights = {}\n  local h1 = select(2, measureText(\"A\", fontES))\n  local h2 = select(2, measureText(\"A\", fontEN))\n  local bubbleH = h1 + h2 + padY*2 + 8\n  bubbleBaseY = H - bubbleH - 40\n  local totalW = widths[1]+widths[2]+widths[3] + 40*2\n  local startX = (W - totalW)/2\n  local phases = {0, 1.7, 3.1}\n  for i=1,#words do\n    local bx = startX\n    for j=1,i-1 do bx = bx + widths[j] + 40 end\n    table.insert(bubbles, {\n      es=words[i].es, en=words[i].en,\n      x=bx, y=bubbleBaseY, w=widths[i], h=bubbleH,\n      phase=phases[i], shakeT=0, result=nil\n    })\n  end\nend\n\nlocal function prepareRound()\n  lastClickedBubble = nil\n  ynHighlight.yes, ynHighlight.no = nil, nil\n  readyToProceed = false\n  apple.fillActive = false\n  apple.fillProgress = 0\n  sparkles = {}\n  for i=1,#bubbles do\n    bubbles[i].shakeT = 0\n    bubbles[i].result = nil\n  end\n  if rounds[roundIndex].type==\"click\" then\n    if roundIndex==3 then\n      local idxs = {1,2,3}\n      shuffle(idxs)\n      local newB = {}\n      for k=1,3 do\n        newB[k] = bubbles[idxs[k]]\n      end\n      bubbles = newB\n      -- recompute x positions evenly\n      local totalW = bubbles[1].w+bubbles[2].w+bubbles[3].w + 40*2\n      local startX = (W - totalW)/2\n      for i=1,3 do\n        local bx = startX\n        for j=1,i-1 do bx = bx + bubbles[j].w + 40 end\n        bubbles[i].x = bx\n        bubbles[i].y = bubbleBaseY\n      end\n    end\n  end\nend\n\nlocal function onCorrect()\n  score = score + 1\n  apple.fillActive = true\n  apple.fillProgress = 0\n  spawnSparkles(36)\nend\n\nlocal function onWrong(b)\n  if b then\n    b.shakeT = 0.3\n  end\nend\n\nlocal function currentInstruction()\n  local idx = rounds[roundIndex].instructionIndex\n  return instructions[idx]\nend\n\nfunction init()\n  W, H = getScreenWidth(), getScreenHeight()\n  t = 0\n  score = 0\n  roundIndex = 0\n  state = \"start\"\n  substate = \"await\"\n  readyToProceed = false\n  apple.x = W*0.5\n  apple.y = H*0.45\n  apple.r = math.min(W,H)*0.14\n  resetBubbles()\n  startButton.w, startButton.h = 260, 80\n  startButton.x = (W - startButton.w)/2\n  startButton.y = H*0.75\n  nextButton.w, nextButton.h = 260, 72\n  nextButton.x = W - nextButton.w - 30\n  nextButton.y = H - nextButton.h - 24\n  retryButton.w, retryButton.h = 280, 80\n  retryButton.x = (W - retryButton.w)/2\n  retryButton.y = H*0.70\n  local bw, bh = 220, 80\n  yesButton.w, yesButton.h = bw, bh\n  noButton.w, noButton.h = bw, bh\n  yesButton.x = W*0.5 - bw - 20\n  noButton.x  = W*0.5 + 20\n  yesButton.y = H*0.68\n  noButton.y  = H*0.68\nend\n\nlocal function startGame()\n  score = 0\n  roundIndex = 1\n  substate = \"await\"\n  state = \"playing\"\n  prepareRound()\nend\n\nlocal function proceedNext()\n  if roundIndex < maxRounds then\n    roundIndex = roundIndex + 1\n    substate = \"await\"\n    prepareRound()\n  else\n    state = \"end\"\n    endTimer = 0\n  end\nend\n\nfunction update(dt)\n  t = t + dt\n\n  for i=#sparkles,1,-1 do\n    local p = sparkles[i]\n    p.age = p.age + dt\n    p.x = p.x + p.vx*dt\n    p.y = p.y + p.vy*dt\n    p.vy = p.vy + 160*dt\n    if p.age >= p.life then\n      table.remove(sparkles, i)\n    end\n  end\n\n  if apple.fillActive then\n    apple.fillProgress = apple.fillProgress + dt/0.5\n    if apple.fillProgress >= 1 then\n      apple.fillProgress = 1\n      readyToProceed = true\n    end\n  end\n\n  for i=1,#bubbles do\n    if bubbles[i].shakeT and bubbles[i].shakeT > 0 then\n      bubbles[i].shakeT = bubbles[i].shakeT - dt\n      if bubbles[i].shakeT <= 0 then\n        bubbles[i].shakeT = 0\n        readyToProceed = true\n      end\n    end\n  end\n\n  if state == \"end\" then\n    endTimer = endTimer + dt\n    if endTimer > 3.2 then\n      if score >= 2 then\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n  end\n\n  local mx, my = getMouseX(), getMouseY()\n  if isMouseJustPressed() then\n    if state==\"start\" then\n      if isInsideRect(mx,my,startButton) then\n        startGame()\n      end\n    elseif state==\"playing\" then\n      if substate==\"await\" then\n        if rounds[roundIndex].type==\"click\" then\n          for i=1,#bubbles do\n            local amp = 12\n            local dx = amp*math.sin(t*0.6 + bubbles[i].phase)\n            local sx = bubbles[i].x + dx\n            local shake = 0\n            if bubbles[i].shakeT and bubbles[i].shakeT > 0 then\n              shake = 6*math.sin((0.3 - bubbles[i].shakeT)*60)\n            end\n            local rect = {x=sx+shake, y=bubbles[i].y, w=bubbles[i].w, h=bubbles[i].h}\n            if isInsideRect(mx,my,rect) then\n              lastClickedBubble = i\n              if bubbles[i].es == rounds[roundIndex].correctEs then\n                bubbles[i].result = \"correct\"\n                onCorrect()\n              else\n                bubbles[i].result = \"wrong\"\n                onWrong(bubbles[i])\n              end\n              substate = \"feedback\"\n              break\n            end\n          end\n        elseif rounds[roundIndex].type==\"yn\" then\n          if isInsideRect(mx,my,yesButton) then\n            lastClickedBubble = nil\n            if rounds[roundIndex].correctAnswer == \"Yes\" then\n              ynHighlight.yes = \"correct\"\n              onCorrect()\n            else\n              ynHighlight.yes = \"wrong\"\n              onWrong(nil)\n            end\n            substate = \"feedback\"\n          elseif isInsideRect(mx,my,noButton) then\n            lastClickedBubble = nil\n            if rounds[roundIndex].correctAnswer == \"No\" then\n              ynHighlight.no = \"correct\"\n              onCorrect()\n            else\n              ynHighlight.no = \"wrong\"\n              onWrong(nil)\n            end\n            substate = \"feedback\"\n          end\n        end\n      elseif substate==\"feedback\" then\n        if readyToProceed and isInsideRect(mx,my,nextButton) then\n          proceedNext()\n        end\n      end\n    elseif state==\"end\" then\n      if isInsideRect(mx,my,retryButton) then\n        startGame()\n      end\n    end\n  end\nend\n\nlocal function drawBackground()\n  clear(rgb(160, 215, 255))\n  drawGradientRect(0,0,W,H, rgba(160,215,255,255), rgba(130,200,255,255), true)\n  local plazaW, plazaH = W*0.72, H*0.44\n  local px, py = (W-plazaW)/2, (H-plazaH)/2\n  drawGradientRect(px, py, plazaW, plazaH, rgba(245,245,245,255), rgba(230,230,230,255), true)\n  drawRoundedRect(px, py, plazaW, plazaH, 18, rgba(200,200,200,200), false, 2)\nend\n\nlocal function drawApple()\n  if apple.fillActive or apple.fillProgress>0 then\n    local a = clamp(apple.fillProgress,0,1)\n    drawCircle(apple.x, apple.y, apple.r*0.98, rgba(220,20,60, math.floor(30 + a*205)), true)\n  end\n  drawCircle(apple.x, apple.y, apple.r, rgb(220,30,70), false, 6)\n  drawEllipse(apple.x - apple.r*0.2, apple.y - apple.r*0.9, apple.r*0.28, apple.r*0.16, rgba(40,180,90,220), true)\n  drawLine(apple.x, apple.y - apple.r*0.92, apple.x + apple.r*0.15, apple.y - apple.r*1.25, rgb(120,80,40), 5)\nend\n\nlocal function drawInstructionTop()\n  local inst = nil\n  if state==\"start\" then\n    inst = instructions[2]\n  elseif state==\"playing\" then\n    inst = currentInstruction()\n  elseif state==\"end\" then\n    inst = nil\n  end\n  if inst then\n    local es, en = inst.es, inst.en\n    local fES, fEN = 40, 22\n    local esW,_ = measureText(es, fES)\n    local enW,_ = measureText(en, fEN)\n    local y = 28\n    drawText(es, (W-esW)/2, y, rgb(20,40,70), fES, \"monospace\")\n    drawText(en, (W-enW)/2, y+38, rgba(20,40,70,200), fEN, \"monospace\")\n  end\nend\n\nlocal function drawScore()\n  local labelES = ui.score.es\n  local labelEN = ui.score.en\n  local sES = string.format(\"%s: %d\", labelES, score)\n  local sEN = string.format(\"%s: %d\", labelEN, score)\n  drawRoundedRect(16, 16, 190, 66, 10, rgba(255,255,255,180), true)\n  drawRoundedRect(16, 16, 190, 66, 10, rgba(80,120,160,180), false, 2)\n  drawText(sES, 26, 28, rgb(20,40,70), 20, \"monospace\")\n  drawText(sEN, 26, 50, rgba(20,40,70,200), 16, \"monospace\")\nend\n\nlocal function drawBubble(b)\n  local amp = 12\n  local dx = amp*math.sin(t*0.6 + b.phase)\n  local shake = 0\n  if b.shakeT and b.shakeT > 0 then\n    shake = 6*math.sin((0.3 - b.shakeT)*60)\n  end\n  local x = b.x + dx + shake\n  local y = b.y\n  local colorBorder = rgba(90,140,200,220)\n  if b.result==\"correct\" then colorBorder = rgb(40,200,120) end\n  if b.result==\"wrong\" then colorBorder = rgb(220,70,70) end\n  drawRoundedRect(x, y, b.w, b.h, 24, rgba(255,255,255,230), true)\n  drawRoundedRect(x, y, b.w, b.h, 24, colorBorder, false, 3)\n  local fES, fEN = 32, 18\n  local esW,_ = measureText(b.es, fES)\n  drawText(b.es, x + (b.w-esW)/2, y + 18, rgb(20,40,70), fES, \"monospace\")\n  local enW,_ = measureText(b.en, fEN)\n  drawText(b.en, x + (b.w-enW)/2, y + 18 + 34, rgba(20,40,70,200), fEN, \"monospace\")\nend\n\nlocal function drawBubbles()\n  for i=1,#bubbles do\n    drawBubble(bubbles[i])\n  end\nend\n\nlocal function drawButton(rect, es, en, accent, enabled)\n  local fillCol = rgba(255,255,255, enabled and 230 or 140)\n  local borderCol = enabled and accent or rgba(140,140,140,200)\n  drawRoundedRect(rect.x, rect.y, rect.w, rect.h, 18, fillCol, true)\n  drawRoundedRect(rect.x, rect.y, rect.w, rect.h, 18, borderCol, false, 3)\n  local fES, fEN = 26, 16\n  local esW,_ = measureText(es, fES)\n  local enW,_ = measureText(en, fEN)\n  drawText(es, rect.x + (rect.w-esW)/2, rect.y + 16, rgb(20,40,70), fES, \"monospace\")\n  drawText(en, rect.x + (rect.w-enW)/2, rect.y + 16 + 26, rgba(20,40,70,200), fEN, \"monospace\")\nend\n\nlocal function drawYesNoCard()\n  local cardW, cardH = W*0.64, H*0.36\n  local cx, cy = (W-cardW)/2, (H-cardH)/2\n  drawRoundedRect(cx, cy, cardW, cardH, 20, rgba(255,255,255,235), true)\n  drawRoundedRect(cx, cy, cardW, cardH, 20, rgba(80,120,160,220), false, 3)\n  local wordES = rounds[roundIndex].cardEs\n  local fES = 40\n  local wES,_ = measureText(wordES, fES)\n  drawText(wordES, cx + (cardW - wES)/2, cy + 24, rgb(20,40,70), fES, \"monospace\")\n\n  local askES = instructions[3].es\n  local askEN = instructions[3].en\n  local fAskES, fAskEN = 28, 18\n  local aESW,_ = measureText(askES, fAskES)\n  local aENW,_ = measureText(askEN, fAskEN)\n  drawText(askES, cx + (cardW-aESW)/2, cy + 24 + 48, rgb(20,40,70), fAskES, \"monospace\")\n  drawText(askEN, cx + (cardW-aENW)/2, cy + 24 + 48 + 26, rgba(20,40,70,200), fAskEN, \"monospace\")\n\n  local yesAccent = ynHighlight.yes==\"correct\" and rgb(40,200,120) or (ynHighlight.yes==\"wrong\" and rgb(220,70,70) or rgba(90,140,200,220))\n  local noAccent  = ynHighlight.no ==\"correct\" and rgb(40,200,120) or (ynHighlight.no ==\"wrong\" and rgb(220,70,70) or rgba(90,140,200,220))\n  local enabled = true\n  drawButton(yesButton, yn.yes.es, yn.yes.en, yesAccent, enabled)\n  drawButton(noButton , yn.no.es , yn.no.en ,  noAccent, enabled)\nend\n\nlocal function drawSparkles()\n  if #sparkles==0 then return end\n  setBlendMode(\"add\")\n  for i=1,#sparkles do\n    local p = sparkles[i]\n    local a = 1 - (p.age / p.life)\n    local col = rgba(255, 220, 80, math.floor(80 + 175*a))\n    drawPoint(p.x, p.y, col, p.size)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawTopBanner()\n  local bannerW, bannerH = W*0.80, 64\n  local bx, by = (W-bannerW)/2, 86\n  drawRoundedRect(bx, by, bannerW, bannerH, 16, rgba(255,255,255,220), true)\n  drawRoundedRect(bx, by, bannerW, bannerH, 16, rgba(80,120,160,220), false, 2)\nend\n\nlocal function drawWinLose()\n  local win = score>=2\n  local msgES = win and \"¡La encontraste!\" or \"Inténtalo de nuevo.\"\n  local msgEN = win and \"You found it!\" or \"Try again.\"\n  local fES, fEN = 44, 22\n  local wES,_ = measureText(msgES, fES)\n  local wEN,_ = measureText(msgEN, fEN)\n  local y = H*0.20\n  drawText(msgES, (W-wES)/2, y, win and rgb(30,170,100) or rgb(220,70,70), fES, \"monospace\")\n  drawText(msgEN, (W-wEN)/2, y+40, rgba(20,40,70,220), fEN, \"monospace\")\n  drawButton(retryButton, ui.retry.es, ui.retry.en, rgba(90,140,200,220), true)\nend\n\nfunction draw()\n  drawBackground()\n  drawInstructionTop()\n  drawTopBanner()\n  drawApple()\n  drawScore()\n\n  if state==\"start\" then\n    drawBubbles()\n    drawButton(startButton, ui.start.es, ui.start.en, rgba(90,140,200,220), true)\n  elseif state==\"playing\" then\n    if rounds[roundIndex].type==\"click\" then\n      drawBubbles()\n    elseif rounds[roundIndex].type==\"yn\" then\n      drawYesNoCard()\n    end\n    local showNext = (substate==\"feedback\" and readyToProceed)\n    drawButton(nextButton, ui.next.es, ui.next.en, rgba(90,140,200,220), showNext)\n  elseif state==\"end\" then\n    drawWinLose()\n  end\n\n  drawSparkles()\nend",
      "id": "game_1_lost_apple_quick_click",
      "trigger_id": "npc_1_lucas",
      "trigger_type": "npc",
      "related_quest_id": "quest_1_the_lost_apple"
    },
    {
      "name": {
        "native_language": "Bread Lines to Market",
        "target_language": "Líneas de pan al mercado"
      },
      "description": {
        "native_language": "Drag the bread to the marketplace and choose the right prepositions at each gate. Practice location words and 'going to' intent.",
        "target_language": "Arrastra el pan al mercado y elige las preposiciones correctas en cada puerta. Practica palabras de ubicación e intención con 'ir a'."
      },
      "language_level": "A0+",
      "target_vocabulary": [
        "pan",
        "entregar",
        "mercado"
      ],
      "grammar_focus": [
        "location prepositions (en, a, al lado de, delante de, detrás de, entre)",
        "future intent (ir a + infinitive: voy a entregar)"
      ],
      "game_prompt": "Create a top-down simple map made of nodes and gates using shapes only. Mechanics: - The player drags a brown rectangle (bread) from START (left) to GOAL (right). - The path has 3 gates. At each gate, a popup shows a Spanish sentence with a missing preposition and three answer buttons. The gate opens only if the player clicks the correct preposition button. Visual design: pastel map on pale yellow. START is a green circle labeled bilingual. GOAL is an orange house-shaped polygon with a small sign 'mercado'. Gates are gray bars that rise up when opened. Educational content: On-screen text must be these bilingual items: UI and labels: [{\"native_language\":\"Start\",\"target_language\":\"Iniciar\"},{\"native_language\":\"Goal: marketplace\",\"target_language\":\"Meta: mercado\"},{\"native_language\":\"Drag the bread\",\"target_language\":\"Arrastra el pan\"},{\"native_language\":\"Deliver bread\",\"target_language\":\"Entregar pan\"},{\"native_language\":\"I am going to deliver bread.\",\"target_language\":\"Voy a entregar pan.\"},{\"native_language\":\"Correct!\",\"target_language\":\"¡Correcto!\"},{\"native_language\":\"Try again\",\"target_language\":\"Inténtalo de nuevo\"}] Preposition choices (buttons): [{\"native_language\":\"in\",\"target_language\":\"en\"},{\"native_language\":\"to\",\"target_language\":\"a\"},{\"native_language\":\"next to\",\"target_language\":\"al lado de\"},{\"native_language\":\"in front of\",\"target_language\":\"delante de\"},{\"native_language\":\"behind\",\"target_language\":\"detrás de\"},{\"native_language\":\"between\",\"target_language\":\"entre\"}] Gate prompts (use letters as landmarks A/B/C to avoid extra nouns): - Gate 1: [{\"native_language\":\"The marketplace is ___ B.\",\"target_language\":\"El mercado está ___ B.\"}] Correct: 'al lado de'. - Gate 2: [{\"native_language\":\"Go ___ the gate.\",\"target_language\":\"Ve ___ la puerta.\"}] Correct: 'a'. - Gate 3: [{\"native_language\":\"Stop ___ A and C.\",\"target_language\":\"Para ___ A y C.\"}] Correct: 'entre'. When the player reaches GOAL, show: [{\"native_language\":\"Delivered!\",\"target_language\":\"¡Entregado!\"}] Win/Lose conditions: 3 total gates; 2 mistakes allowed. If mistakes > 2, show lose message: [{\"native_language\":\"The bread is late. Try again.\",\"target_language\":\"El pan llega tarde. Inténtalo de nuevo.\"}] Animations: - Bread leaves a faint breadcrumb trail (small dots). - Gate opens with a vertical slide and a soft 'glow' (yellow outline) on correct.",
      "skill_points": 16,
      "lua_code": "local w, h\nlocal pathY\nlocal bgColor\nlocal pathColor\nlocal pathEdge\nlocal startGreen\nlocal goalOrange\nlocal breadColor\nlocal gateGray\nlocal glowYellow\nlocal textDark\n\nlocal bread\nlocal dragging = false\nlocal dragOffsetX, dragOffsetY = 0, 0\nlocal prevX, prevY = 0, 0\n\nlocal sX, sY, sR\nlocal goal = {x=0, y=0, w=120, h=90, roofH=40}\n\nlocal gates = {}\nlocal currentGateIndex = nil\nlocal popupActive = false\nlocal popupButtons = {}\nlocal popupMessage = \"\"\nlocal popupFeedbackType = nil\nlocal popupTimer = 0\n\nlocal solvedCount = 0\nlocal mistakes = 0\nlocal maxMistakes = 2\n\nlocal state = \"play\"\nlocal endTimer = 0\n\nlocal trail = {}\nlocal trailTimer = 0\n\nlocal landmarks = {}\n\nlocal texts = {\n  startEs = \"Iniciar\",\n  startEn = \"Start\",\n  goalEs = \"Meta: mercado\",\n  goalEn = \"Goal: marketplace\",\n  dragEs = \"Arrastra el pan\",\n  dragEn = \"Drag the bread\",\n  deliverEs = \"Entregar pan\",\n  deliverEn = \"Deliver bread\",\n  voyEs = \"Voy a entregar pan.\",\n  voyEn = \"I am going to deliver bread.\",\n  correctEs = \"¡Correcto!\",\n  correctEn = \"Correct!\",\n  tryEs = \"Inténtalo de nuevo\",\n  tryEn = \"Try again\",\n  deliveredEs = \"¡Entregado!\",\n  deliveredEn = \"Delivered!\",\n  lateEs = \"El pan llega tarde. Inténtalo de nuevo.\",\n  lateEn = \"The bread is late. Try again.\"\n}\n\nlocal preps = {\n  {en=\"in\", es=\"en\"},\n  {en=\"to\", es=\"a\"},\n  {en=\"next to\", es=\"al lado de\"},\n  {en=\"in front of\", es=\"delante de\"},\n  {en=\"behind\", es=\"detrás de\"},\n  {en=\"between\", es=\"entre\"}\n}\n\nlocal sounds = {\n  correct = \"s_ok\",\n  wrong = \"s_bad\",\n  win = \"s_win\",\n  lose = \"s_lose\"\n}\n\nlocal function clamp(v, a, b)\n  if v < a then return a end\n  if v > b then return b end\n  return v\nend\n\nlocal function intersects(ax, ay, aw, ah, bx, by, bw, bh)\n  return ax < bx + bw and bx < ax + aw and ay < by + bh and by < ay + ah\nend\n\nlocal function shuffle(t)\n  for i = #t, 2, -1 do\n    local j = randomInt(1, i)\n    t[i], t[j] = t[j], t[i]\n  end\nend\n\nlocal function findPrepEn(es)\n  for i=1,#preps do\n    if preps[i].es == es then return preps[i].en end\n  end\n  return \"\"\nend\n\nlocal function buildChoices(correctEs)\n  local options = {}\n  for i=1,#preps do\n    if preps[i].es ~= correctEs then\n      table.insert(options, preps[i])\n    end\n  end\n  shuffle(options)\n  local choices = {\n    {es = correctEs, en = findPrepEn(correctEs)},\n    {es = options[1].es, en = options[1].en},\n    {es = options[2].es, en = options[2].en}\n  }\n  shuffle(choices)\n  return choices\nend\n\nlocal function prepareGate(i, x, promptEs, promptEn, correctEs)\n  local g = {\n    x = x,\n    y = pathY,\n    width = 18,\n    height = 120,\n    openProgress = 0,\n    opening = false,\n    locked = true,\n    glowTime = 0,\n    promptEs = promptEs,\n    promptEn = promptEn,\n    correctEs = correctEs,\n    choices = buildChoices(correctEs)\n  }\n  return g\nend\n\nlocal function openQuestion(i)\n  currentGateIndex = i\n  popupActive = true\n  popupFeedbackType = nil\n  popupTimer = 0\nend\n\nlocal function playSoundSafe(name)\n  playSound(name)\nend\n\nfunction init()\n  randomSeed(os.time())\n  w = getScreenWidth()\n  h = getScreenHeight()\n  pathY = math.floor(h * 0.62)\n\n  bgColor = rgb(255, 248, 210)\n  pathColor = rgb(242, 232, 206)\n  pathEdge = rgb(228, 214, 190)\n  startGreen = rgb(120, 200, 140)\n  goalOrange = rgb(255, 170, 90)\n  breadColor = rgb(166, 112, 58)\n  gateGray = rgb(160, 160, 170)\n  glowYellow = rgba(255, 220, 70, 160)\n  textDark = rgb(60, 60, 60)\n\n  sX, sY, sR = 80, pathY, 28\n\n  goal.x = w - 170\n  goal.y = pathY - 90\n  goal.w = 130\n  goal.h = 95\n  goal.roofH = 45\n\n  bread = {\n    x = sX - 20,\n    y = pathY - 16,\n    w = 48,\n    h = 28\n  }\n\n  landmarks = {\n    {label=\"A\", x = w*0.22, y = h*0.33, color = rgb(200,220,255)},\n    {label=\"B\", x = w*0.35, y = h*0.40, color = rgb(220,200,255)},\n    {label=\"C\", x = w*0.78, y = h*0.36, color = rgb(200,255,220)}\n  }\n\n  gates = {}\n  gates[1] = prepareGate(1, math.floor(w*0.35), \"El mercado está ___ B.\", \"The marketplace is ___ B.\", \"al lado de\")\n  gates[2] = prepareGate(2, math.floor(w*0.58), \"Ve ___ la puerta.\", \"Go ___ the gate.\", \"a\")\n  gates[3] = prepareGate(3, math.floor(w*0.78), \"Para ___ A y C.\", \"Stop ___ A and C.\", \"entre\")\n\n  createSound(sounds.correct, 880, 0.10, 0.5, \"sine\")\n  createSound(sounds.wrong, 140, 0.18, 0.5, \"square\")\n  createSound(sounds.win, 660, 0.25, 0.6, \"triangle\")\n  createSound(sounds.lose, 220, 0.4, 0.5, \"sawtooth\")\nend\n\nlocal function updateTrail(dt)\n  trailTimer = trailTimer + dt\n  local last = trail[#trail]\n  local cx = bread.x + bread.w/2\n  local cy = bread.y + bread.h/2\n  local add = false\n  if not last then add = true\n  else\n    local dx = cx - last.x\n    local dy = cy - last.y\n    if (dx*dx + dy*dy) > 25 or trailTimer > 0.05 then\n      add = true\n    end\n  end\n  if add then\n    trailTimer = 0\n    table.insert(trail, {x=cx, y=cy, life=1.0})\n    if #trail > 160 then\n      table.remove(trail, 1)\n    end\n  end\n  for i=1,#trail do\n    trail[i].life = math.max(0, trail[i].life - dt*0.25)\n  end\nend\n\nlocal function handleGateCollision()\n  for i=1,#gates do\n    local g = gates[i]\n    if g.locked then\n      local offset = -g.openProgress * (g.height + 16)\n      local gx = g.x - g.width/2\n      local gy = pathY - g.height/2 + offset\n      if intersects(bread.x, bread.y, bread.w, bread.h, gx, gy, g.width, g.height) then\n        bread.x = prevX\n        bread.y = prevY\n        if not popupActive then\n          openQuestion(i)\n        end\n        return\n      end\n    end\n  end\nend\n\nlocal function allGatesOpen()\n  for i=1,#gates do\n    if gates[i].locked then return false end\n  end\n  return true\nend\n\nlocal function breadAtGoal()\n  local bx, by, bw, bh = bread.x, bread.y, bread.w, bread.h\n  local gx, gy, gw, gh = goal.x, goal.y, goal.w, goal.h\n  return intersects(bx, by, bw, bh, gx, gy, gw, gh)\nend\n\nlocal function processPopupInput()\n  if not popupActive then return end\n  if not isMouseJustPressed() then return end\n  local mx, my = getMouseX(), getMouseY()\n  for i=1,#popupButtons do\n    local b = popupButtons[i]\n    if mx >= b.x and mx <= b.x + b.w and my >= b.y and my <= b.y + b.h then\n      local g = gates[currentGateIndex]\n      if b.es == g.correctEs then\n        g.locked = false\n        g.opening = true\n        g.glowTime = 1.2\n        solvedCount = solvedCount + 1\n        popupFeedbackType = \"correct\"\n        popupMessage = texts.correctEs .. \" / \" .. texts.correctEn\n        popupTimer = 0.8\n        popupButtons = {}\n        playSoundSafe(sounds.correct)\n      else\n        mistakes = mistakes + 1\n        popupFeedbackType = \"wrong\"\n        popupMessage = texts.tryEs .. \" / \" .. texts.tryEn\n        popupTimer = 1.0\n        playSoundSafe(sounds.wrong)\n        if mistakes > maxMistakes then\n          state = \"lose\"\n          endTimer = 1.5\n          playSoundSafe(sounds.lose)\n          popupActive = false\n          return\n        end\n      end\n      return\n    end\n  end\nend\n\nfunction update(dt)\n  if state == \"win\" or state == \"lose\" then\n    endTimer = endTimer - dt\n    if endTimer <= 0 then\n      if state == \"win\" then\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n    return\n  end\n\n  for i=1,#gates do\n    local g = gates[i]\n    if g.opening then\n      g.openProgress = math.min(1, g.openProgress + dt*1.4)\n      if g.openProgress >= 1 then\n        g.opening = false\n      end\n    end\n    if g.glowTime and g.glowTime > 0 then\n      g.glowTime = math.max(0, g.glowTime - dt)\n    end\n  end\n\n  if popupActive then\n    if popupFeedbackType then\n      popupTimer = popupTimer - dt\n      if popupTimer <= 0 then\n        if popupFeedbackType == \"correct\" then\n          popupActive = false\n          popupFeedbackType = nil\n          popupMessage = \"\"\n          currentGateIndex = nil\n        else\n          popupFeedbackType = nil\n          popupMessage = \"\"\n        end\n      end\n    else\n      processPopupInput()\n      if popupActive and not popupFeedbackType then\n        local g = gates[currentGateIndex]\n        popupButtons = {}\n        local pw, ph = math.floor(w*0.64), math.floor(h*0.45)\n        local px, py = math.floor((w - pw)/2), math.floor((h - ph)/2)\n        local bwid, bhei = pw - 60, 46\n        local bx = px + 30\n        local by = py + 120\n        for i=1,3 do\n          local ch = g.choices[i]\n          popupButtons[i] = {x=bx, y=by + (i-1)*(bhei+16), w=bwid, h=bhei, es=ch.es, en=ch.en}\n        end\n      end\n    end\n    updateTrail(dt)\n    return\n  end\n\n  prevX, prevY = bread.x, bread.y\n\n  if isMouseJustPressed() then\n    local mx, my = getMouseX(), getMouseY()\n    if mx >= bread.x and mx <= bread.x + bread.w and my >= bread.y and my <= bread.y + bread.h then\n      dragging = true\n      dragOffsetX = mx - bread.x\n      dragOffsetY = my - bread.y\n    end\n  end\n\n  if isMouseDown() and dragging then\n    local mx, my = getMouseX(), getMouseY()\n    bread.x = mx - dragOffsetX\n    bread.y = my - dragOffsetY\n    bread.y = clamp(bread.y, pathY - 26, pathY + 6)\n  end\n\n  if isMouseJustReleased() then\n    dragging = false\n  end\n\n  handleGateCollision()\n\n  if allGatesOpen() and breadAtGoal() then\n    state = \"win\"\n    endTimer = 1.6\n    playSoundSafe(sounds.win)\n  end\n\n  updateTrail(dt)\nend\n\nlocal function drawHouse()\n  local bx, by, bw, bh = goal.x, goal.y, goal.w, goal.h\n  drawRoundedRect(bx, by, bw, bh, 8, rgba(255, 180, 110, 230), true)\n  drawRoundedRect(bx, by, bw, bh, 8, rgba(200, 100, 50, 200), false, 2)\n  local rx1, ry1 = bx, by\n  local rx2, ry2 = bx + bw, by\n  local rx3, ry3 = bx + bw/2, by - goal.roofH\n  drawTriangle(rx1, ry1, rx2, ry2, rx3, ry3, rgba(255, 145, 80, 240), true)\n  drawTriangle(rx1, ry1, rx2, ry2, rx3, ry3, rgba(180, 90, 40, 220), false, 2)\n  local doorW, doorH = 26, 40\n  local doorX, doorY = bx + bw*0.2, by + bh - doorH\n  drawRoundedRect(doorX, doorY, doorW, doorH, 5, rgb(120, 90, 70), true)\n  drawCircle(doorX + doorW - 6, doorY + doorH/2, 2, rgb(230, 210, 180), true)\n  local signW, signH = 66, 28\n  local sx, sy = bx + bw + 8, by + 12\n  drawRoundedRect(sx, sy, signW, signH, 6, rgb(240, 230, 200), true)\n  drawRoundedRect(sx, sy, signW, signH, 6, rgb(160, 130, 90), false, 2)\n  drawText(\"mercado\", sx + 8, sy + 6, textDark, 16, \"monospace\")\nend\n\nlocal function drawStart()\n  drawCircle(sX, sY, sR, startGreen, true)\n  drawCircle(sX, sY, sR, rgb(80, 160, 110), false, 3)\n  drawText(texts.startEs..\" / \"..texts.startEn, sX - 40, sY + sR + 8, textDark, 14, \"monospace\")\nend\n\nlocal function drawPath()\n  local ph = 28\n  drawRoundedRect(0, pathY - ph/2, w, ph, 12, pathColor, true)\n  drawRoundedRect(0, pathY - ph/2, w, ph, 12, pathEdge, false, 2)\n  for i=1,6 do\n    local nx = w*(0.12*i)\n    drawCircle(nx, pathY, 6, rgb(220, 230, 220), true)\n    drawCircle(nx, pathY, 6, rgb(200, 210, 200), false, 1)\n  end\nend\n\nlocal function drawGates()\n  for i=1,#gates do\n    local g = gates[i]\n    local offset = -g.openProgress * (g.height + 16)\n    local gx = g.x - g.width/2\n    local gy = pathY - g.height/2 + offset\n    drawRoundedRect(gx, gy, g.width, g.height, 4, rgb(200,200,205), true)\n    drawRoundedRect(gx, gy, g.width, g.height, 4, gateGray, false, 2)\n    if g.glowTime and g.glowTime > 0 then\n      local t = getTime()\n      local pulse = (math.sin(t*8) + 1)*0.5\n      local a = math.floor(80 + 120*pulse)\n      setBlendMode(\"add\")\n      drawRoundedRect(gx-6, gy-6, g.width+12, g.height+12, 8, rgba(255, 230, 90, a), false, 6)\n      setBlendMode(\"normal\")\n    end\n  end\nend\n\nlocal function drawLandmarks()\n  for i=1,#landmarks do\n    local m = landmarks[i]\n    drawCircle(m.x, m.y, 16, m.color, true)\n    drawCircle(m.x, m.y, 16, rgba(80,80,80,120), false, 2)\n    drawText(m.label, m.x-6, m.y-10, textDark, 20, \"monospace\")\n  end\n  drawText(\"A / A\", landmarks[1].x - 14, landmarks[1].y + 22, textDark, 12, \"monospace\")\n  drawText(\"B / B\", landmarks[2].x - 14, landmarks[2].y + 22, textDark, 12, \"monospace\")\n  drawText(\"C / C\", landmarks[3].x - 14, landmarks[3].y + 22, textDark, 12, \"monospace\")\nend\n\nlocal function drawTrail()\n  for i=1,#trail do\n    local p = trail[i]\n    local alpha = math.floor(40 + 100 * p.life)\n    drawCircle(p.x, p.y, 2, rgba(150, 100, 60, alpha), true)\n  end\nend\n\nlocal function drawBread()\n  drawRoundedRect(bread.x, bread.y, bread.w, bread.h, 6, breadColor, true)\n  drawRoundedRect(bread.x, bread.y, bread.w, bread.h, 6, rgb(120, 80, 45), false, 2)\n  drawEllipse(bread.x + bread.w*0.25, bread.y + 6, 6, 3, rgba(255, 235, 200, 120), true)\n  drawEllipse(bread.x + bread.w*0.55, bread.y + 4, 5, 2, rgba(255, 235, 200, 120), true)\nend\n\nlocal function drawTopUI()\n  drawGradientRect(0, 0, w, 64, rgba(255,255,255,10), rgba(0,0,0,20), false)\n  drawText(texts.dragEs..\" / \"..texts.dragEn, 16, 12, textDark, 16, \"monospace\")\n  drawText(texts.deliverEs..\" / \"..texts.deliverEn, 16, 32, textDark, 16, \"monospace\")\n  drawText(texts.voyEs..\" / \"..texts.voyEn, 16, 50, textDark, 14, \"monospace\")\n  local scoreText = string.format(\"Puertas: %d/3  Fallos: %d/%d\", solvedCount, mistakes, maxMistakes)\n  drawText(scoreText, w - 260, 16, textDark, 16, \"monospace\")\nend\n\nlocal function drawGoalLabel()\n  drawText(texts.goalEs..\" / \"..texts.goalEn, goal.x - 10, goal.y + goal.h + 8, textDark, 16, \"monospace\")\nend\n\nlocal function drawPopup()\n  if not popupActive then return end\n  drawRect(0, 0, w, h, rgba(0,0,0,120), true)\n  local pw, ph = math.floor(w*0.64), math.floor(h*0.45)\n  local px, py = math.floor((w - pw)/2), math.floor((h - ph)/2)\n  drawRoundedRect(px, py, pw, ph, 12, rgb(255, 252, 235), true)\n  drawRoundedRect(px, py, pw, ph, 12, rgb(180, 160, 120), false, 3)\n  local g = gates[currentGateIndex]\n  if g then\n    drawText(g.promptEs, px + 24, py + 24, textDark, 20, \"monospace\")\n    drawText(\"(\"..g.promptEn..\")\", px + 24, py + 50, rgba(60,60,60,180), 14, \"monospace\")\n  end\n  if popupFeedbackType then\n    local color = popupFeedbackType == \"correct\" and rgb(30,160,80) or rgb(200,60,60)\n    drawText(popupMessage, px + 24, py + ph - 40, color, 22, \"monospace\")\n  else\n    for i=1,#popupButtons do\n      local b = popupButtons[i]\n      local mx, my = getMouseX(), getMouseY()\n      local hover = mx >= b.x and mx <= b.x + b.w and my >= b.y and my <= b.y + b.h\n      local c = hover and rgb(245, 238, 210) or rgb(250, 246, 226)\n      drawRoundedRect(b.x, b.y, b.w, b.h, 8, c, true)\n      drawRoundedRect(b.x, b.y, b.w, b.h, 8, rgb(180, 160, 120), false, 2)\n      drawText(b.es, b.x + 12, b.y + 10, textDark, 20, \"monospace\")\n      drawText(\"(\"..b.en..\")\", b.x + 12, b.y + 28, rgba(60,60,60,180), 14, \"monospace\")\n    end\n    drawText(texts.correctEs..\" / \"..texts.correctEn..\"  |  \"..texts.tryEs..\" / \"..texts.tryEn, px + 24, py + ph - 40, rgba(80,80,80,180), 14, \"monospace\")\n  end\nend\n\nfunction draw()\n  clear(bgColor)\n  drawPath()\n  drawLandmarks()\n  drawStart()\n  drawHouse()\n  drawGoalLabel()\n  drawGates()\n  drawTrail()\n  drawBread()\n  drawTopUI()\n\n  if state == \"win\" then\n    drawRect(0, 0, w, h, rgba(0,0,0,120), true)\n    drawRadialGradient(w/2, h/2, 200, rgba(255,255,200,180), rgba(255,255,200,0))\n    drawText(texts.deliveredEs..\" / \"..texts.deliveredEn, w/2 - 120, h/2 - 10, rgb(30,160,80), 28, \"monospace\")\n  elseif state == \"lose\" then\n    drawRect(0, 0, w, h, rgba(0,0,0,140), true)\n    drawText(texts.lateEs, w/2 - 220, h/2 - 12, rgb(200,60,60), 24, \"monospace\")\n    drawText(texts.lateEn, w/2 - 220, h/2 + 16, rgba(240,240,240,220), 18, \"monospace\")\n  end\n\n  drawPopup()\nend",
      "id": "game_2_bread_lines_to_market",
      "trigger_id": "npc_11_maria",
      "trigger_type": "npc",
      "related_quest_id": "quest_2_bread_delivery"
    },
    {
      "name": {
        "native_language": "Whispering Grove: There Is a Secret",
        "target_language": "Bosque susurrante: Hay un secreto"
      },
      "description": {
        "native_language": "Listen to simple clues with 'hay' and place the flower or secret in the right zone of the grove.",
        "target_language": "Lee pistas simples con 'hay' y coloca la flor o el secreto en la zona correcta del bosque."
      },
      "language_level": "A1",
      "target_vocabulary": [
        "secreto",
        "bosque",
        "flor"
      ],
      "grammar_focus": [
        "existential statements with 'hay'",
        "location descriptions with 'está en'"
      ],
      "game_prompt": "Board layout with three big zones labeled A, B, C in a green rectangle (the grove). Player has two draggable tokens: a pink circle labeled 'flor' and a purple star labeled 'secreto'. Mechanics: Show a bilingual clue at the top; player drags token to the correct zone. 4 rounds total, mixing 'hay' and 'está en'. Visual design: - Background: gradient green. Zones A/B/C are outlined white circles with letters inside. - Tokens have subtle pulsing scale animation while waiting. Educational content (display strings as bilingual): UI: [{\"native_language\":\"Place the token in the correct zone.\",\"target_language\":\"Coloca la ficha en la zona correcta.\"},{\"native_language\":\"Check\",\"target_language\":\"Comprobar\"},{\"native_language\":\"Next\",\"target_language\":\"Siguiente\"},{\"native_language\":\"Score\",\"target_language\":\"Puntuación\"}] Tokens: [{\"native_language\":\"flower\",\"target_language\":\"flor\"},{\"native_language\":\"secret\",\"target_language\":\"secreto\"}] Location words: [{\"native_language\":\"grove\",\"target_language\":\"bosque\"},{\"native_language\":\"there is/are\",\"target_language\":\"hay\"},{\"native_language\":\"is in\",\"target_language\":\"está en\"}] Clues (use exactly these four): 1) [{\"native_language\":\"In the grove there is a flower in A.\",\"target_language\":\"En el bosque hay una flor en A.\"}] 2) [{\"native_language\":\"The flower is in B.\",\"target_language\":\"La flor está en B.\"}] 3) [{\"native_language\":\"In the grove there is a secret in C.\",\"target_language\":\"En el bosque hay un secreto en C.\"}] 4) [{\"native_language\":\"The secret is in A.\",\"target_language\":\"El secreto está en A.\"}] Win condition: At least 3 correct placements. Show win: [{\"native_language\":\"You discovered the clue!\",\"target_language\":\"¡Descubriste la pista!\"}] Lose message: [{\"native_language\":\"Listen carefully and try again.\",\"target_language\":\"Lee con atención e inténtalo de nuevo.\"}] Animations: On correct, the zone gets a soft golden ring expanding outward. On incorrect, token returns to start with a gentle shake.",
      "skill_points": 20,
      "lua_code": "local w, h\nlocal timeElapsed = 0\n\nlocal grove = {x=0,y=0,w=0,h=0}\nlocal zones = {}\nlocal zoneR = 0\n\nlocal tokens = {}\nlocal tokenIndexByType = {}\n\nlocal draggingId = nil\nlocal dragOffsetX, dragOffsetY = 0, 0\n\nlocal score = 0\nlocal roundIndex = 1\nlocal rounds = {}\nlocal roundAnswered = false\nlocal roundCorrect = false\n\nlocal effects = {}\n\nlocal checkBtn = {x=0,y=0,w=0,h=0}\nlocal nextBtn = {x=0,y=0,w=0,h=0}\n\nlocal endState = false\nlocal endWin = false\nlocal endTimer = 0\n\nlocal ui = {\n  instruction_es = \"Coloca la ficha en la zona correcta.\",\n  instruction_en = \"Place the token in the correct zone.\",\n  check_es = \"Comprobar\",\n  check_en = \"Check\",\n  next_es = \"Siguiente\",\n  next_en = \"Next\",\n  score_es = \"Puntuación\",\n  score_en = \"Score\",\n  win_es = \"¡Descubriste la pista!\",\n  win_en = \"You discovered the clue!\",\n  lose_es = \"Lee con atención e inténtalo de nuevo.\",\n  lose_en = \"Listen carefully and try again.\"\n}\n\nlocal colors = {\n  bg1 = \"#0E5222\",\n  bg2 = \"#1B7A37\",\n  groveFill = \"#1E8E3E\",\n  groveBorder = \"#5CE083\",\n  zoneStroke = \"#FFFFFF\",\n  zoneHoverFill = rgba(255,255,255,35),\n  text = \"#FFFFFF\",\n  subtext = \"#D8FFD8\",\n  btnEnabled = \"#2ECC71\",\n  btnDisabled = \"#5A6B5F\",\n  btnText = \"#FFFFFF\",\n  pink = \"#FF69B4\",\n  purple = \"#8A2BE2\",\n  shadow = rgba(0,0,0,90),\n  gold = rgb(255,215,0),\n  red = \"#FF5C5C\",\n  green = \"#6CFF6C\"\n}\n\nlocal soundsReady = false\n\nlocal function lerp(a, b, t) return a + (b - a) * t end\nlocal function clamp(x, minv, maxv) if x < minv then return minv elseif x > maxv then return maxv else return x end end\nlocal function dist2(x1,y1,x2,y2) local dx,dy=x2-x1,y2-y1 return dx*dx+dy*dy end\nlocal function isPointInRect(px,py,rx,ry,rw,rh) return px>=rx and px<=rx+rw and py>=ry and py<=ry+rh end\n\nlocal function layout()\n  w, h = getScreenWidth(), getScreenHeight()\n  grove.w = math.floor(w*0.86)\n  grove.h = math.floor(h*0.46)\n  grove.x = math.floor((w - grove.w)/2)\n  grove.y = math.floor(h*0.18)\n\n  zoneR = math.min(grove.w/8, grove.h/2.8)\n  local zY = grove.y + grove.h*0.55\n  zones = {\n    {x = grove.x + grove.w*0.2, y = zY, r = zoneR, letter=\"A\"},\n    {x = grove.x + grove.w*0.5, y = zY, r = zoneR, letter=\"B\"},\n    {x = grove.x + grove.w*0.8, y = zY, r = zoneR, letter=\"C\"}\n  }\n\n  -- Buttons\n  local margin = 18\n  local bw = math.max(120, math.floor(w*0.18))\n  local bh = math.max(40, math.floor(h*0.07))\n  nextBtn.w, nextBtn.h = bw, bh\n  checkBtn.w, checkBtn.h = bw, bh\n  nextBtn.x = w - margin - bw\n  checkBtn.x = nextBtn.x - margin - bw\n  nextBtn.y = h - margin - bh\n  checkBtn.y = h - margin - bh\n\n  -- Tokens start positions (bottom area)\n  local tR = math.min(48, math.floor(h*0.06))\n  if not tokens[1] then\n    tokens = {\n      {\n        id=1, kind=\"flor\", label=\"flor\", color=colors.pink,\n        x= w*0.3, y= h - bh - 60, startX= w*0.3, startY= h - bh - 60,\n        r=tR, scale=1, dragging=false, pulse=0, locked=false,\n        tween=nil, shake=0, visible=true, phase=0.0\n      },\n      {\n        id=2, kind=\"secreto\", label=\"secreto\", color=colors.purple,\n        x= w*0.6, y= h - bh - 60, startX= w*0.6, startY= h - bh - 60,\n        r=tR, scale=1, dragging=false, pulse=0, locked=false,\n        tween=nil, shake=0, visible=true, phase=1.2\n      }\n    }\n    tokenIndexByType[\"flor\"]=1\n    tokenIndexByType[\"secreto\"]=2\n  else\n    for i=1,#tokens do\n      local t = tokens[i]\n      t.r = tR\n      if not t.locked and (not t.tween) and (not t.dragging) then\n        t.x, t.y = t.startX, t.startY\n      end\n    end\n  end\nend\n\nlocal function initRounds()\n  rounds = {\n    {es=\"En el bosque hay una flor en A.\", en=\"In the grove there is a flower in A.\", target=\"flor\", zone=\"A\"},\n    {es=\"La flor está en B.\", en=\"The flower is in B.\", target=\"flor\", zone=\"B\"},\n    {es=\"En el bosque hay un secreto en C.\", en=\"In the grove there is a secret in C.\", target=\"secreto\", zone=\"C\"},\n    {es=\"El secreto está en A.\", en=\"The secret is in A.\", target=\"secreto\", zone=\"A\"}\n  }\nend\n\nlocal function setupSounds()\n  if soundsReady then return end\n  createSound(\"correct_high\", 880, 0.18, 0.5, \"sine\")\n  createSound(\"correct_shimmer\", 1320, 0.14, 0.35, \"sine\")\n  createSound(\"wrong_low\", 200, 0.22, 0.5, \"square\")\n  soundsReady = true\nend\n\nlocal function resetRoundState()\n  roundAnswered = false\n  roundCorrect = false\n  draggingId = nil\n  for i=1,#tokens do\n    local t = tokens[i]\n    t.dragging = false\n    t.locked = false\n    t.tween = nil\n    t.shake = 0\n    t.x, t.y = t.startX, t.startY\n  end\nend\n\nlocal function getZoneAt(x, y)\n  for i=1,#zones do\n    local z = zones[i]\n    if dist2(x,y,z.x,z.y) <= (z.r*z.r) then\n      return z.letter, i\n    end\n  end\n  return nil, nil\nend\n\nlocal function tokenUnderMouse(mx, my)\n  -- Check in reverse order for top-most on overlap\n  for i=#tokens,1,-1 do\n    local t = tokens[i]\n    if t.visible and (not t.locked) and (not t.tween) then\n      if dist2(mx,my,t.x,t.y) <= (t.r * t.scale + 6)^2 then\n        return i\n      end\n    end\n  end\n  return nil\nend\n\nlocal function addRingEffect(x, y)\n  table.insert(effects, {x=x, y=y, t=0, dur=0.9})\nend\n\nlocal function startReturnTween(t)\n  t.tween = {\n    sx = t.x, sy = t.y,\n    ex = t.startX, ey = t.startY,\n    t = 0, dur = 0.55\n  }\n  t.shake = 0.45\nend\n\nlocal function evaluateRound()\n  local r = rounds[roundIndex]\n  local idx = tokenIndexByType[r.target]\n  local t = tokens[idx]\n  local letter, zi = getZoneAt(t.x, t.y)\n  roundAnswered = true\n  if letter == r.zone then\n    roundCorrect = true\n    score = score + 1\n    addRingEffect(zones[zi].x, zones[zi].y)\n    t.locked = true\n    -- Snap softly to center\n    t.tween = {sx=t.x, sy=t.y, ex=zones[zi].x, ey=zones[zi].y, t=0, dur=0.25}\n    playSound(\"correct_high\")\n    playSound(\"correct_shimmer\")\n  else\n    roundCorrect = false\n    startReturnTween(t)\n    playSound(\"wrong_low\")\n  end\nend\n\nlocal function drawStar(cx, cy, outerR, innerR, spikes, color, filled, strokeWidth)\n  local outers = {}\n  local inners = {}\n  local step = math.pi / spikes\n  local a = -math.pi/2\n  for i=1,spikes do\n    local ox = cx + math.cos(a) * outerR\n    local oy = cy + math.sin(a) * outerR\n    local ix = cx + math.cos(a + step) * innerR\n    local iy = cy + math.sin(a + step) * innerR\n    outers[i] = {x=ox, y=oy}\n    inners[i] = {x=ix, y=iy}\n    a = a + 2*step\n  end\n  for i=1,spikes do\n    local ip = (i % spikes) + 1\n    drawTriangle(outers[i].x, outers[i].y, inners[i].x, inners[i].y, inners[ip].x, inners[ip].y, color, true)\n  end\n  for i=1,spikes do\n    local ip = (i % spikes) + 1\n    drawLine(outers[i].x, outers[i].y, inners[i].x, inners[i].y, color, strokeWidth or 2)\n    drawLine(inners[i].x, inners[i].y, outers[ip].x, outers[ip].y, color, strokeWidth or 2)\n  end\nend\n\nlocal function drawToken(t, highlight)\n  local sx = 1\n  if not t.dragging and not t.tween and not t.locked then\n    local amp = highlight and 0.10 or 0.05\n    sx = 1 + amp * math.sin(timeElapsed*3.2 + t.phase)\n  else\n    sx = 1\n  end\n  t.scale = sx\n\n  local drawX, drawY = t.x, t.y\n  local shakeOffsetX, shakeOffsetY = 0,0\n  if t.shake > 0 then\n    local s = (math.sin(timeElapsed*45) + math.sin(timeElapsed*31))*0.5\n    local a = 6 * (t.shake / 0.45)\n    shakeOffsetX = s * a\n    shakeOffsetY = -s * a * 0.5\n  end\n  drawX = drawX + shakeOffsetX\n  drawY = drawY + shakeOffsetY\n\n  pushTransform()\n  translate(drawX, drawY)\n  scale(sx, sx)\n\n  -- Shadow\n  if t.kind == \"flor\" then\n    drawCircle(4, 6, t.r+1, colors.shadow, true)\n  else\n    drawStar(4, 6, t.r, t.r*0.45, 5, colors.shadow, true, 1)\n  end\n\n  if t.kind == \"flor\" then\n    drawCircle(0, 0, t.r, t.color, true)\n    -- simple petals\n    local petalR = t.r*0.35\n    local pr = t.r + petalR*0.2\n    for i=1,6 do\n      local ang = -math.pi/2 + (i-1)*(2*math.pi/6)\n      drawCircle(math.cos(ang)*pr*0.6, math.sin(ang)*pr*0.6, petalR, rgba(255,182,193,180), true)\n    end\n    drawCircle(0,0, t.r*0.55, rgba(255,255,255,180), true)\n  else\n    drawStar(0,0, t.r, t.r*0.45, 5, t.color, true, 2)\n  end\n\n  drawText(t.label, -measureText(t.label, math.max(14, math.floor(t.r*0.5)))/2, math.floor(t.r*0.2), colors.text, math.max(14, math.floor(t.r*0.5)), \"monospace\")\n  popTransform()\nend\n\nlocal function drawZone(z, hovered, locked)\n  if hovered then\n    drawCircle(z.x, z.y, z.r*1.08, colors.zoneHoverFill, true)\n  end\n  drawCircle(z.x, z.y, z.r, colors.zoneStroke, false, hovered and 5 or 3)\n  drawText(z.letter, z.x - 8, z.y - 12, colors.text, 28, \"monospace\")\nend\n\nlocal function drawEffects(dt)\n  for i=#effects,1,-1 do\n    local e = effects[i]\n    local t = e.t / e.dur\n    if t > 1 then\n      table.remove(effects, i)\n    else\n      local r = lerp(zoneR, zoneR*2.2, t)\n      local alpha = math.floor(220 * (1 - t))\n      setBlendMode(\"add\")\n      drawCircle(e.x, e.y, r, rgba(255,215,0, alpha), false, 6)\n      drawCircle(e.x, e.y, r*0.85, rgba(255,240,160, math.floor(alpha*0.6)), false, 4)\n      setBlendMode(\"normal\")\n    end\n  end\nend\n\nlocal function drawButton(b, text_es, text_en, enabled)\n  local col = enabled and colors.btnEnabled or colors.btnDisabled\n  drawRoundedRect(b.x, b.y, b.w, b.h, 12, col, true)\n  drawRoundedRect(b.x, b.y, b.w, b.h, 12, rgba(255,255,255,60), false, 2)\n  local fs = math.floor(b.h*0.42)\n  local fs2 = math.floor(b.h*0.28)\n  local tw = measureText(text_es, fs)\n  drawText(text_es, b.x + (b.w - tw)/2, b.y + b.h*0.22, colors.btnText, fs, \"monospace\")\n  local tw2 = measureText(text_en, fs2)\n  drawText(text_en, b.x + (b.w - tw2)/2, b.y + b.h*0.60, rgba(255,255,255,210), fs2, \"monospace\")\nend\n\nfunction init()\n  randomSeed(os.time())\n  layout()\n  initRounds()\n  setupSounds()\n  resetRoundState()\nend\n\nfunction update(dt)\n  timeElapsed = timeElapsed + dt\n  -- Update effects\n  for i=#effects,1,-1 do\n    local e = effects[i]\n    e.t = e.t + dt\n  end\n\n  -- Update tokens tween/shake/pulse\n  for i=1,#tokens do\n    local t = tokens[i]\n    if t.tween then\n      t.tween.t = t.tween.t + dt\n      local p = clamp(t.tween.t / t.tween.dur, 0, 1)\n      local s = (3 - 2*p)*p*p -- smoothstep-ish\n      t.x = lerp(t.tween.sx, t.tween.ex, s)\n      t.y = lerp(t.tween.sy, t.tween.ey, s)\n      if t.tween.t >= t.tween.dur then\n        t.tween = nil\n        t.shake = 0\n      end\n    end\n    if t.shake > 0 then\n      t.shake = t.shake - dt\n      if t.shake < 0 then t.shake = 0 end\n    end\n  end\n\n  if endState then\n    endTimer = endTimer + dt\n    if endTimer >= 2.5 then\n      halt(endWin and 2 or 1)\n    end\n    return\n  end\n\n  local mx, my = getMouseX(), getMouseY()\n  if isMouseJustPressed() then\n    -- Start dragging\n    if not roundAnswered then\n      local idx = tokenUnderMouse(mx, my)\n      if idx then\n        local t = tokens[idx]\n        t.dragging = true\n        draggingId = idx\n        dragOffsetX = mx - t.x\n        dragOffsetY = my - t.y\n      end\n    end\n  elseif isMouseJustReleased() then\n    -- End dragging\n    if draggingId then\n      tokens[draggingId].dragging = false\n      draggingId = nil\n    end\n  end\n\n  if draggingId then\n    local t = tokens[draggingId]\n    t.x = mx - dragOffsetX\n    t.y = my - dragOffsetY\n    t.x = clamp(t.x, t.r, w - t.r)\n    t.y = clamp(t.y, t.r, h - t.r)\n  end\n\n  -- Buttons interaction\n  local r = rounds[roundIndex]\n  local relevantToken = tokens[tokenIndexByType[r.target]]\n  local letter = getZoneAt(relevantToken.x, relevantToken.y)\n  local canCheck = (letter ~= nil) and (not roundAnswered)\n\n  if isMouseJustPressed() then\n    if isPointInRect(mx, my, checkBtn.x, checkBtn.y, checkBtn.w, checkBtn.h) and canCheck then\n      evaluateRound()\n    end\n    if isPointInRect(mx, my, nextBtn.x, nextBtn.y, nextBtn.w, nextBtn.h) and roundAnswered then\n      roundIndex = roundIndex + 1\n      if roundIndex > #rounds then\n        endState = true\n        endWin = score >= 3\n        endTimer = 0\n      else\n        resetRoundState()\n      end\n    end\n  end\nend\n\nfunction draw()\n  layout() -- Ensure layout is correct per frame\n  clear(colors.bg1)\n  drawGradientRect(0, 0, w, h, colors.bg1, colors.bg2, true)\n\n  -- Grove\n  drawRoundedRect(grove.x, grove.y, grove.w, grove.h, 24, colors.groveFill, true)\n  setBlendMode(\"overlay\")\n  drawRadialGradient(grove.x + grove.w*0.5, grove.y + grove.h*0.4, math.max(grove.w, grove.h)*0.6, rgba(255,255,255,40), rgba(0,0,0,0))\n  setBlendMode(\"normal\")\n  drawRoundedRect(grove.x, grove.y, grove.w, grove.h, 24, colors.groveBorder, false, 3)\n\n  -- Headings\n  local titleFS = math.max(18, math.floor(h*0.035))\n  local subFS = math.max(12, math.floor(h*0.024))\n  local title = ui.instruction_es\n  local sub = ui.instruction_en\n  local tw = measureText(title, titleFS)\n  drawText(title, grove.x + (grove.w - tw)/2, grove.y - titleFS - 14, colors.text, titleFS, \"monospace\")\n  local tw2 = measureText(sub, subFS)\n  drawText(sub, grove.x + (grove.w - tw2)/2, grove.y - subFS - 2, colors.subtext, subFS, \"monospace\")\n\n  -- Current clue\n  if not endState then\n    local r = rounds[roundIndex]\n    local clueFS = math.max(18, math.floor(h*0.032))\n    local clueSubFS = math.max(12, math.floor(h*0.024))\n    local ctw = measureText(r.es, clueFS)\n    drawText(r.es, grove.x + (grove.w - ctw)/2, grove.y + 10, colors.text, clueFS, \"monospace\")\n    local ctw2 = measureText(r.en, clueSubFS)\n    drawText(r.en, grove.x + (grove.w - ctw2)/2, grove.y + 10 + clueFS + 4, colors.subtext, clueSubFS, \"monospace\")\n  end\n\n  -- Zones\n  local rnow = rounds[roundIndex]\n  local relevantToken = tokens[tokenIndexByType[rnow.target]]\n  local hoveredLetter, hoveredIndex = getZoneAt(relevantToken.x, relevantToken.y)\n  for i=1,#zones do\n    local z = zones[i]\n    local hovered = (hoveredIndex == i) and (not roundAnswered)\n    drawZone(z, hovered, false)\n  end\n\n  -- Effects\n  drawEffects()\n\n  -- Tokens\n  for i=1,#tokens do\n    local t = tokens[i]\n    local highlight = (rnow and t.kind == rnow.target and not roundAnswered)\n    drawToken(t, highlight)\n  end\n\n  -- Score\n  local scoreFS = math.max(14, math.floor(h*0.028))\n  local sText = ui.score_es .. \": \" .. score .. \"/4\"\n  local sText2 = ui.score_en .. \": \" .. score .. \"/4\"\n  drawText(sText, 16, 12, colors.text, scoreFS, \"monospace\")\n  drawText(sText2, 16, 12 + scoreFS + 2, colors.subtext, math.floor(scoreFS*0.8), \"monospace\")\n\n  -- Buttons\n  if not endState then\n    local letter = getZoneAt(relevantToken.x, relevantToken.y)\n    local canCheck = (letter ~= nil) and (not roundAnswered)\n    drawButton(checkBtn, ui.check_es, ui.check_en, canCheck)\n    drawButton(nextBtn, ui.next_es, ui.next_en, roundAnswered)\n\n    -- Feedback text\n    if roundAnswered then\n      local fbFS = math.max(18, math.floor(h*0.034))\n      local msg_es = roundCorrect and \"¡Correcto!\" or \"Incorrecto\"\n      local msg_en = roundCorrect and \"Correct!\" or \"Incorrect\"\n      local col = roundCorrect ? colors.green : colors.red\n    end\n  end\n\n  -- Feedback overlay text with bilingual hint after answer\n  if not endState and roundAnswered then\n    local fbFS = math.max(20, math.floor(h*0.04))\n    local fbSub = math.max(14, math.floor(h*0.026))\n    local msg_es = roundCorrect and \"¡Correcto!\" or \"Incorrecto\"\n    local msg_en = roundCorrect and \"Correct!\" or \"Incorrect\"\n    local col = roundCorrect and colors.green or colors.red\n    local twx = measureText(msg_es, fbFS)\n    drawText(msg_es, grove.x + (grove.w - twx)/2, grove.y + grove.h - fbFS - 36, col, fbFS, \"monospace\")\n    local twx2 = measureText(msg_en, fbSub)\n    drawText(msg_en, grove.x + (grove.w - twx2)/2, grove.y + grove.h - fbSub - 12, rgba(255,255,255,220), fbSub, \"monospace\")\n  end\n\n  -- End state\n  if endState then\n    local overlayFS = math.max(24, math.floor(h*0.05))\n    local overlaySub = math.max(16, math.floor(h*0.032))\n    local msg_es = endWin and ui.win_es or ui.lose_es\n    local msg_en = endWin and ui.win_en or ui.lose_en\n    local panelW = math.min(w*0.86, 640)\n    local panelH = math.min(h*0.42, 320)\n    local px = (w - panelW)/2\n    local py = (h - panelH)/2\n    drawRoundedRect(px, py, panelW, panelH, 16, rgba(0,0,0,160), true)\n    drawRoundedRect(px, py, panelW, panelH, 16, rgba(255,255,255,80), false, 3)\n\n    local tw_es = measureText(msg_es, overlayFS)\n    local tw_en = measureText(msg_en, overlaySub)\n    drawText(msg_es, px + (panelW - tw_es)/2, py + panelH*0.35 - overlayFS, colors.text, overlayFS, \"monospace\")\n    drawText(msg_en, px + (panelW - tw_en)/2, py + panelH*0.35 + 8, colors.subtext, overlaySub, \"monospace\")\n    local resText = (ui.score_es .. \": \" .. score .. \"/4\")\n    local resText2 = (ui.score_en .. \": \" .. score .. \"/4\")\n    local rtw = measureText(resText, overlaySub)\n    drawText(resText, px + (panelW - rtw)/2, py + panelH*0.68, colors.text, overlaySub, \"monospace\")\n    local rtw2 = measureText(resText2, math.floor(overlaySub*0.9))\n    drawText(resText2, px + (panelW - rtw2)/2, py + panelH*0.68 + overlaySub + 4, colors.subtext, math.floor(overlaySub*0.9), \"monospace\")\n  end\nend",
      "id": "game_3_whispering_grove_there_is_a_se",
      "trigger_id": "npc_4_don_carlos",
      "trigger_type": "npc",
      "related_quest_id": "quest_4_the_green_grove_mystery"
    },
    {
      "name": {
        "native_language": "A Flower for Isabella: Word Glow",
        "target_language": "Una flor para Isabella: Brillo de palabras"
      },
      "description": {
        "native_language": "Tap the correct words to make short compliments and choose amigo/amiga correctly.",
        "target_language": "Toca las palabras correctas para crear cumplidos cortos y elige amigo/amiga correctamente."
      },
      "language_level": "A0+",
      "target_vocabulary": [
        "flor",
        "hermosa",
        "amigo",
        "amiga"
      ],
      "grammar_focus": [
        "nouns + adjectives agreement (feminine 'flor' + 'hermosa')",
        "basic noun gender (amigo/amiga)"
      ],
      "game_prompt": "A calm scene with a large stylized flower (five petal shapes) in the center. Two short rounds of tap-to-select. Mechanics: - Round 1: Show a sentence frame with one blank; three word chips float around the flower. Player taps the chip that correctly completes the phrase. - Round 2: Show a greeting line to Isabella with a blank for amigo/amiga; player taps the correct gender form. Visual design: lavender background, the selected correct chip emits a soft pink glow trail to the sentence. Educational content (all on-screen strings bilingual): UI: [{\"native_language\":\"Tap the correct word\",\"target_language\":\"Toca la palabra correcta\"},{\"native_language\":\"Next\",\"target_language\":\"Siguiente\"},{\"native_language\":\"Finish\",\"target_language\":\"Terminar\"},{\"native_language\":\"Great!\",\"target_language\":\"¡Genial!\"},{\"native_language\":\"Try again\",\"target_language\":\"Inténtalo de nuevo\"}] Chips: [{\"native_language\":\"beautiful\",\"target_language\":\"hermosa\"},{\"native_language\":\"friend (male)\",\"target_language\":\"amigo\"},{\"native_language\":\"friend (female)\",\"target_language\":\"amiga\"},{\"native_language\":\"flower\",\"target_language\":\"flor\"}] Sentence frames and correct answers: - Frame 1: [{\"native_language\":\"It is a ____ flower.\",\"target_language\":\"Es una flor ____ .\"}] Correct chip: 'hermosa'. Wrong decoys (also shown as chips): 'amigo', 'amiga'. - Frame 2: [{\"native_language\":\"Isabella, you are my ____ .\",\"target_language\":\"Isabella, eres mi ____ .\"}] Correct chip: 'amiga'. Wrong decoy: 'amigo'. Success message: [{\"native_language\":\"A beautiful flower for a good friend!\",\"target_language\":\"¡Una flor hermosa para una buena amiga!\"}] Win/Lose: Must answer both rounds correctly; allow 1 retry per round. If fail after retry, show: [{\"native_language\":\"Watch the words and try again.\",\"target_language\":\"Mira las palabras e inténtalo de nuevo.\"}] Animations: Correct chip glows and snaps into the blank; incorrect chip wobbles and fades slightly before returning.",
      "skill_points": 16,
      "lua_code": "local cw, ch\nlocal cx, cy\nlocal timeElapsed = 0\n\nlocal rounds = {}\nlocal currentRound = 1\nlocal chips = {}\nlocal particles = {}\nlocal score = 0\nlocal wrongs = 0\nlocal maxRounds = 2\n\nlocal allowSelect = true\nlocal showTryAgain = false\nlocal tryAgainTimer = 0\nlocal allowNext = false\n\nlocal status = \"playing\"\nlocal endTimer = 0\n\nlocal blank = {x=0,y=0,w=0,h=0}\nlocal frameSpanish = \"\"\nlocal frameEnglish = \"\"\nlocal correctWordES = \"\"\nlocal correctWordEN = \"\"\n\nlocal btn = {x=0,y=0,w=0,h=0,labelES=\"\",labelEN=\"\",visible=false}\n\nlocal flowerSpin = 0\nlocal flowerPulse = 0\n\nlocal colLavTop = \"#EBD8FF\"\nlocal colLavBot = \"#D9C3FF\"\nlocal colPetal = \"#FFD1E8\"\nlocal colPetal2 = \"#FFC1DE\"\nlocal colCenter = \"#FFF4A3\"\nlocal colStem = \"#77C27A\"\nlocal colLeaf = \"#97D69E\"\nlocal colText = \"#43225F\"\nlocal colWhite = \"#FFFFFF\"\nlocal colGlow = rgba(255,120,180,140)\nlocal colGlowStrong = rgba(255,120,180,200)\n\nlocal chimeName = \"s_chime\"\nlocal buzzName = \"s_buzz\"\n\nlocal function lerp(a,b,t) return a + (b-a)*t end\nlocal function clamp(x,a,b) if x<a then return a elseif x>b then return b else return x end end\nlocal function easeOutCubic(t) t = clamp(t,0,1) return 1 - (1 - t) * (1 - t) * (1 - t) end\nlocal function easeInOutSine(t) return -0.5*(math.cos(math.pi*t)-1) end\nlocal function pointInRect(px,py,r) return px>=r.x and py>=r.y and px<=r.x+r.w and py<=r.y+r.h end\n\nlocal function makeButton(x,y,w,h,labelES,labelEN)\n  btn.x,btn.y,btn.w,btn.h = x,y,w,h\n  btn.labelES,btn.labelEN = labelES,labelEN\n  btn.visible = true\nend\n\nlocal function hideButton() btn.visible = false end\n\nlocal function playChime() playSound(chimeName) end\nlocal function playBuzz() playSound(buzzName) end\n\nlocal function addParticle(x,y)\n  local p = {\n    x=x, y=y,\n    r=random(6,12),\n    life=0, maxLife=random(0.35,0.65),\n    dx=random(-20,20),\n    dy=random(-20,20),\n    a=colGlow\n  }\n  table.insert(particles, p)\nend\n\nlocal function spawnTrailBurst(x,y,n)\n  for i=1,n do\n    addParticle(x + random(-4,4), y + random(-4,4))\n  end\nend\n\nlocal function resetChipsAlpha()\n  for _,c in ipairs(chips) do\n    c.alpha = 1.0\n  end\nend\n\nlocal function computeBlankForRound(r)\n  local word = r.correct.es\n  local w,h = measureText(word, 28)\n  blank.w = w + 48\n  blank.h = h + 18\n  blank.x = cx - blank.w/2\n  blank.y = ch*0.22\nend\n\nlocal function setupRound(idx)\n  local r = rounds[idx]\n  frameSpanish = r.frame.es\n  frameEnglish = r.frame.en\n  correctWordES = r.correct.es\n  correctWordEN = r.correct.en\n  chips = {}\n  wrongs = 0\n  allowSelect = true\n  allowNext = false\n  showTryAgain = false\n  tryAgainTimer = 0\n  hideButton()\n  computeBlankForRound(r)\n  local n = #r.options\n  local baseR = math.min(cw,ch)*0.26\n  for i=1,n do\n    local opt = r.options[i]\n    local a = (i-1)*(2*math.pi/n) + random(0,0.5)\n    local chip = {\n      es = opt.es,\n      en = opt.en,\n      correct = (opt.es == r.correct.es),\n      angle = a,\n      speed = random(0.25,0.45) * (random(0,1)>0.5 and 1 or -1),\n      orbit = baseR + random(-18,18),\n      r = 46,\n      alpha = 1.0,\n      x = 0, y = 0,\n      bobPhase = random(0,6.28),\n      state = \"floating\",\n      t = 0,\n      sx = 0, sy = 0,\n      tx = blank.x + blank.w/2, ty = blank.y + blank.h/2,\n      wobbleTime = 0\n    }\n    chip.x = cx + math.cos(chip.angle)*chip.orbit\n    chip.y = cy + math.sin(chip.angle)*chip.orbit\n    table.insert(chips, chip)\n  end\nend\n\nlocal function nextRound()\n  currentRound = currentRound + 1\n  if currentRound > maxRounds then\n    status = \"won\"\n    endTimer = 0\n    return\n  end\n  setupRound(currentRound)\nend\n\nlocal function beginSnap(chip)\n  chip.state = \"snap\"\n  chip.t = 0\n  chip.sx, chip.sy = chip.x, chip.y\n  chip.tx, chip.ty = blank.x + blank.w/2, blank.y + blank.h/2\n  allowSelect = false\n  for _,c in ipairs(chips) do\n    if c ~= chip then c.alpha = 0.25 end\n  end\n  playChime()\nend\n\nlocal function wrongSelect(chip)\n  chip.state = \"wobble\"\n  chip.wobbleTime = 0\n  chip.alpha = 0.6\n  showTryAgain = true\n  tryAgainTimer = 1.2\n  wrongs = wrongs + 1\n  playBuzz()\n  if wrongs >= 2 then\n    status = \"failed\"\n    endTimer = 0\n  end\nend\n\nlocal function drawFlower()\n  pushTransform()\n  translate(cx, cy + ch*0.06)\n  local t = timeElapsed\n  local spin = flowerSpin + t*0.25\n  local pulse = 1 + 0.06*math.sin(t*2)\n  local petalDist = 110\n  for i=0,4 do\n    pushTransform()\n    rotate(spin + i*2*math.pi/5)\n    scale(1,1)\n    local px = 0\n    local py = -petalDist\n    setBlendMode(\"normal\")\n    drawEllipse(px, py, 54*pulse, 92*pulse, colPetal, true)\n    drawEllipse(px, py, 54*pulse, 92*pulse, rgba(255,255,255,40), false, 2)\n    popTransform()\n  end\n  setBlendMode(\"normal\")\n  drawCircle(0,0, 52, colCenter, true)\n  drawCircle(0,0, 52, rgba(0,0,0,25), false, 2)\n  drawRect(-6, 0, 12, 120, colStem, true)\n  drawEllipse(-60, 60, 32, 14, colLeaf, true)\n  drawEllipse(60, 90, 34, 16, colLeaf, true)\n  popTransform()\nend\n\nlocal function drawHeader()\n  local titleES = \"Toca la palabra correcta\"\n  local titleEN = \"Tap the correct word\"\n  local tw1,th1 = measureText(titleES, 26)\n  drawText(titleES, cx - tw1/2, 14, colText, 26, \"monospace\")\n  local tw2,th2 = measureText(titleEN, 14)\n  drawText(titleEN, cx - tw2/2, 14 + th1 + 2, rgba(67,34,95,180), 14, \"monospace\")\n  local scoreStr = \"Puntos: \"..tostring(score)..\"/\"..tostring(maxRounds)\n  drawRoundedRect(10,10, 126, 38, 10, rgba(255,255,255,120), true)\n  drawText(scoreStr, 18, 16, colText, 20, \"monospace\")\nend\n\nlocal function drawFrame()\n  local frameW = math.min(cw*0.86, 720)\n  local frameH = 140\n  local fx = cx - frameW/2\n  local fy = ch*0.12\n  drawRoundedRect(fx, fy, frameW, frameH, 18, rgba(255,255,255,180), true)\n  drawRoundedRect(fx, fy, frameW, frameH, 18, rgba(67,34,95,40), false, 2)\n  drawText(frameSpanish, fx+20, fy+16, colText, 24, \"monospace\")\n  drawText(frameEnglish, fx+20, fy+16+28, rgba(67,34,95,190), 16, \"monospace\")\n  drawRoundedRect(blank.x, blank.y, blank.w, blank.h, 12, rgba(255,255,255,220), true)\n  drawRoundedRect(blank.x, blank.y, blank.w, blank.h, 12, rgba(255,105,180,120), false, 2)\nend\n\nlocal function drawChips()\n  for _,c in ipairs(chips) do\n    local r = c.r\n    local a = clamp(c.alpha,0,1)\n    local chipCol = rgba(255,255,255, 230*a)\n    local outline = rgba(67,34,95, 80*a)\n    setBlendMode(\"normal\")\n    drawRadialGradient(c.x, c.y, r+10, rgba(255,255,255,40*a), rgba(255,255,255,0))\n    drawCircle(c.x, c.y, r, chipCol, true)\n    drawCircle(c.x, c.y, r, outline, false, 2)\n    if c.state == \"snap\" or c.state == \"inBlank\" then\n      setBlendMode(\"add\")\n      drawCircle(c.x, c.y, r+10, colGlow, true)\n      drawCircle(c.x, c.y, r+18, rgba(255,120,180,90), true)\n      setBlendMode(\"normal\")\n    end\n    local es = c.es\n    local en = c.en\n    local tw,th = measureText(es, 20)\n    drawText(es, c.x - tw/2, c.y - 10, colText, 20, \"monospace\")\n    local tw2,th2 = measureText(en, 12)\n    drawText(en, c.x - tw2/2, c.y + 8, rgba(67,34,95,190), 12, \"monospace\")\n  end\nend\n\nlocal function drawParticles()\n  setBlendMode(\"add\")\n  for _,p in ipairs(particles) do\n    local k = 1 - p.life/p.maxLife\n    local col = rgba(255,120,180, math.floor(200*k))\n    drawCircle(p.x, p.y, p.r*k + 2, col, true)\n  end\n  setBlendMode(\"normal\")\nend\n\nlocal function drawBlankWord()\n  for _,c in ipairs(chips) do\n    if c.state == \"inBlank\" then\n      local w = c.es\n      local tw,th = measureText(w, 28)\n      local bx = blank.x + blank.w/2 - tw/2\n      local by = blank.y + blank.h/2 - th/2\n      setBlendMode(\"add\")\n      drawCircle(blank.x + blank.w/2, blank.y + blank.h/2, 32, rgba(255,120,180,80), true)\n      setBlendMode(\"normal\")\n      drawText(w, bx, by, colText, 28, \"monospace\")\n    end\n  end\nend\n\nlocal function drawTryAgain()\n  if showTryAgain then\n    local sES = \"Inténtalo de nuevo\"\n    local sEN = \"Try again\"\n    local tw,th = measureText(sES, 22)\n    drawRoundedRect(cx - tw/2 - 16, blank.y + blank.h + 14, tw+32, 46, 12, rgba(255,255,255,190), true)\n    drawText(sES, cx - tw/2, blank.y + blank.h + 20, rgba(200,60,80,255), 22, \"monospace\")\n    local tw2 = measureText(sEN, 14)\n    drawText(sEN, cx - tw2/2, blank.y + blank.h + 20 + 22, rgba(200,60,80,200), 14, \"monospace\")\n  end\nend\n\nlocal function drawNextButton()\n  if not btn.visible then return end\n  local glow = 6 + 4*math.sin(timeElapsed*4)\n  setBlendMode(\"add\")\n  drawRoundedRect(btn.x - 2, btn.y - 2, btn.w + 4, btn.h + 4, 18, rgba(255,120,180,80), true)\n  setBlendMode(\"normal\")\n  drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 18, rgba(255,255,255,230), true)\n  drawRoundedRect(btn.x, btn.y, btn.w, btn.h, 18, rgba(67,34,95,60), false, 2)\n  local label = btn.labelES\n  local label2 = btn.labelEN\n  local tw = measureText(label, 22)\n  drawText(label, btn.x + btn.w/2 - tw/2, btn.y + 10, colText, 22, \"monospace\")\n  local tw2 = measureText(label2, 14)\n  drawText(label2, btn.x + btn.w/2 - tw2/2, btn.y + 10 + 22, rgba(67,34,95,190), 14, \"monospace\")\nend\n\nlocal function drawStatusOverlay()\n  if status == \"won\" then\n    local msgES = \"¡Una flor hermosa para una buena amiga!\"\n    local msgEN = \"A beautiful flower for a good friend!\"\n    setBlendMode(\"normal\")\n    drawGradientRect(0,0,cw,ch, rgba(255,255,255,30), rgba(255,255,255,180), true)\n    local tw = measureText(msgES, 28)\n    drawText(msgES, cx - tw/2, ch*0.72, colText, 28, \"monospace\")\n    local tw2 = measureText(msgEN, 18)\n    drawText(msgEN, cx - tw2/2, ch*0.72 + 28, rgba(67,34,95,200), 18, \"monospace\")\n  elseif status == \"failed\" then\n    local msgES = \"Mira las palabras e inténtalo de nuevo.\"\n    local msgEN = \"Watch the words and try again.\"\n    drawGradientRect(0,0,cw,ch, rgba(255,255,255,30), rgba(255,255,255,200), true)\n    local tw = measureText(msgES, 26)\n    drawText(msgES, cx - tw/2, ch*0.72, rgba(200,60,80,255), 26, \"monospace\")\n    local tw2 = measureText(msgEN, 18)\n    drawText(msgEN, cx - tw2/2, ch*0.72 + 26, rgba(200,60,80,220), 18, \"monospace\")\n  end\nend\n\nlocal function drawGreat()\n  local gES = \"¡Genial!\"\n  local gEN = \"Great!\"\n  local tw = measureText(gES, 30)\n  setBlendMode(\"add\")\n  drawCircle(cx, blank.y - 30, 40, rgba(255,120,180,70), true)\n  setBlendMode(\"normal\")\n  drawText(gES, cx - tw/2, blank.y - 42, rgba(80,160,90,255), 30, \"monospace\")\n  local tw2 = measureText(gEN, 16)\n  drawText(gEN, cx - tw2/2, blank.y - 42 + 30, rgba(80,160,90,220), 16, \"monospace\")\nend\n\nfunction init()\n  cw = getScreenWidth()\n  ch = getScreenHeight()\n  cx = cw/2\n  cy = ch/2\n  randomSeed(os.time())\n  createSound(chimeName, 880, 0.14, 0.4, \"triangle\")\n  createSound(buzzName, 120, 0.18, 0.35, \"noise\")\n  rounds = {\n    {\n      frame = {es=\"Es una flor ____ .\", en=\"It is a ____ flower.\"},\n      correct = {es=\"hermosa\", en=\"beautiful\"},\n      options = {\n        {es=\"hermosa\", en=\"beautiful\"},\n        {es=\"amigo\", en=\"friend (male)\"},\n        {es=\"amiga\", en=\"friend (female)\"}\n      }\n    },\n    {\n      frame = {es=\"Isabella, eres mi ____ .\", en=\"Isabella, you are my ____ .\"},\n      correct = {es=\"amiga\", en=\"friend (female)\"},\n      options = {\n        {es=\"amigo\", en=\"friend (male)\"},\n        {es=\"amiga\", en=\"friend (female)\"}\n      }\n    }\n  }\n  setupRound(1)\nend\n\nfunction update(dt)\n  timeElapsed = timeElapsed + dt\n  flowerSpin = flowerSpin + dt*0.2\n  flowerPulse = 0.5 + 0.5*math.sin(timeElapsed*2.2)\n  if status == \"won\" then\n    endTimer = endTimer + dt\n    for i=1,2 do\n      addParticle(cx + random(-80,80), ch*0.65 + random(-20,20))\n    end\n    if endTimer > 2.6 then\n      halt(2)\n    end\n    for i=#particles,1,-1 do\n      local p = particles[i]\n      p.life = p.life + dt\n      p.x = p.x + p.dx*dt*0.2\n      p.y = p.y + p.dy*dt*0.2\n      if p.life >= p.maxLife then table.remove(particles, i) end\n    end\n    return\n  elseif status == \"failed\" then\n    endTimer = endTimer + dt\n    if endTimer > 2.2 then\n      halt(1)\n    end\n    for i=#particles,1,-1 do\n      local p = particles[i]\n      p.life = p.life + dt\n      if p.life >= p.maxLife then table.remove(particles, i) end\n    end\n    return\n  end\n  if tryAgainTimer > 0 then\n    tryAgainTimer = tryAgainTimer - dt\n    if tryAgainTimer <= 0 then showTryAgain = false end\n  end\n  for _,c in ipairs(chips) do\n    if c.state == \"floating\" then\n      c.angle = c.angle + c.speed*dt\n      local bob = 6*math.sin(timeElapsed*2 + c.bobPhase)\n      c.x = cx + math.cos(c.angle)*c.orbit\n      c.y = cy + math.sin(c.angle)*c.orbit + bob\n    elseif c.state == \"wobble\" then\n      c.wobbleTime = c.wobbleTime + dt\n      local t = c.wobbleTime\n      local bob = 8*math.sin(t*20) * (1 - clamp(t/0.5,0,1))\n      c.x = cx + math.cos(c.angle)*c.orbit + bob\n      c.y = cy + math.sin(c.angle)*c.orbit\n      if c.wobbleTime >= 0.5 then\n        c.state = \"floating\"\n        c.alpha = 1.0\n        c.wobbleTime = 0\n      end\n    elseif c.state == \"snap\" then\n      c.t = c.t + dt*1.6\n      local tt = easeOutCubic(c.t)\n      c.x = lerp(c.sx, c.tx, tt)\n      c.y = lerp(c.sy, c.ty, tt)\n      spawnTrailBurst(c.x, c.y, 2)\n      if c.t >= 1 then\n        c.state = \"inBlank\"\n        allowNext = true\n        if currentRound == 1 then\n          makeButton(cx - 90, ch - 80, 180, 58, \"Siguiente\", \"Next\")\n        else\n          makeButton(cx - 90, ch - 80, 180, 58, \"Terminar\", \"Finish\")\n        end\n        score = score + 1\n      end\n    elseif c.state == \"inBlank\" then\n      c.x = c.tx\n      c.y = c.ty\n    end\n  end\n  for i=#particles,1,-1 do\n    local p = particles[i]\n    p.life = p.life + dt\n    p.x = p.x + p.dx*dt*0.5\n    p.y = p.y + p.dy*dt*0.5\n    if p.life >= p.maxLife then table.remove(particles, i) end\n  end\n  if isMouseJustPressed() then\n    local mx, my = getMouseX(), getMouseY()\n    if allowNext and btn.visible and pointInRect(mx,my,btn) then\n      allowNext = false\n      hideButton()\n      nextRound()\n      return\n    end\n    if allowSelect then\n      for i=#chips,1,-1 do\n        local c = chips[i]\n        if c.state == \"floating\" then\n          local dx = mx - c.x\n          local dy = my - c.y\n          if dx*dx + dy*dy <= (c.r)^2 then\n            if c.correct then\n              beginSnap(c)\n            else\n              wrongSelect(c)\n            end\n            break\n          end\n        end\n      end\n    end\n  end\nend\n\nfunction draw()\n  clear(colLavTop)\n  drawGradientRect(0,0,cw,ch, colLavTop, colLavBot, true)\n  drawHeader()\n  drawFrame()\n  drawFlower()\n  drawBlankWord()\n  drawChips()\n  drawParticles()\n  if allowNext then\n    drawGreat()\n    drawNextButton()\n  end\n  drawTryAgain()\n  if status == \"won\" or status == \"failed\" then\n    drawStatusOverlay()\n  end\nend",
      "id": "game_4_a_flower_for_isabella_word_glo",
      "trigger_id": "npc_7_isabella",
      "trigger_type": "npc",
      "related_quest_id": "quest_13_a_flower_for_isabella"
    },
    {
      "name": {
        "native_language": "Pablo, Please Join!",
        "target_language": "¡Pablo, por favor, únete!"
      },
      "description": {
        "native_language": "Build polite requests and conditional questions to convince Pablo to join the team for the festival.",
        "target_language": "Forma peticiones corteses y preguntas en condicional para convencer a Pablo de unirse al equipo para el festival."
      },
      "language_level": "A2",
      "target_vocabulary": [
        "festival",
        "equipo",
        "unirse"
      ],
      "grammar_focus": [
        "conditional (te unirías)",
        "polite requests (podrías, por favor)",
        "questions with inversion and punctuation"
      ],
      "game_prompt": "Persuasion meter mini-game with two unique phases: Multiple-Choice Politeness and Jigsaw Sentence. Visual design: town square background (pale stone rectangle). At top, a horizontal 'Charm Meter' bar that fills on correct answers. Phase 1 (Multiple-Choice Politeness): Show an English prompt and three floating Spanish speech-bubble options; player clicks the most polite/conditional one. Phase 2 (Jigsaw Sentence): Tile pieces with Spanish words drift; player drags them into slots to form a correct conditional/polite request. Educational content (all visible strings bilingual): UI: [{\"native_language\":\"Start\",\"target_language\":\"Iniciar\"},{\"native_language\":\"Charm Meter\",\"target_language\":\"Medidor de encanto\"},{\"native_language\":\"Choose the best request\",\"target_language\":\"Elige la mejor petición\"},{\"native_language\":\"Build the sentence\",\"target_language\":\"Forma la oración\"},{\"native_language\":\"Great choice!\",\"target_language\":\"¡Buena elección!\"},{\"native_language\":\"Try again\",\"target_language\":\"Inténtalo de nuevo\"},{\"native_language\":\"Convince Pablo\",\"target_language\":\"Convence a Pablo\"}] Vocabulary chips: [{\"native_language\":\"festival\",\"target_language\":\"festival\"},{\"native_language\":\"team\",\"target_language\":\"equipo\"},{\"native_language\":\"to join\",\"target_language\":\"unirse\"}] Phase 1 prompts and options (correct marked here for design): - Prompt 1: [{\"native_language\":\"Ask Pablo to join the team.\",\"target_language\":\"Pídele a Pablo que se una al equipo.\"}] Options: A) [{\"native_language\":\"Would you join the team?\",\"target_language\":\"¿Te unirías al equipo?\"}] (correct) B) [{\"native_language\":\"Join the team.\",\"target_language\":\"Únete al equipo.\"}] C) [{\"native_language\":\"You join the team.\",\"target_language\":\"Tú te unes al equipo.\"}] - Prompt 2: [{\"native_language\":\"Ask politely with 'could'.\",\"target_language\":\"Pide con cortesía con 'podrías'.\"}] Options: A) [{\"native_language\":\"Could you join the team?\",\"target_language\":\"¿Podrías unirte al equipo?\"}] (correct) B) [{\"native_language\":\"You can join the team.\",\"target_language\":\"Puedes unirte al equipo.\"}] C) [{\"native_language\":\"Join the team, please.\",\"target_language\":\"Únete al equipo, por favor.\"}] Phase 2 jigsaw targets (provide draggable tiles that must be ordered exactly): - Target sentence 1: [{\"native_language\":\"Would you join the team for the festival?\",\"target_language\":\"¿Te unirías al equipo para el festival?\"}] Tiles: [\"¿Te\",\"unirías\",\"al\",\"equipo\",\"para\",\"el\",\"festival?\"] - Target sentence 2: [{\"native_language\":\"Could you join the team, please?\",\"target_language\":\"¿Podrías unirte al equipo, por favor?\"}] Tiles: [\"¿Podrías\",\"unirte\",\"al\",\"equipo,\",\"por\",\"favor?\"] Mechanics details: - Multiple-Choice: When correct, the chosen bubble turns green and the Charm Meter fills by 30%. Wrong answers flash red and deduct 10% (never below 0). - Jigsaw: Snap-to-slot grid; on submit, correct tiles glow; wrong tiles shake and return to the pool. Each correct jigsaw fills 20% of the meter. Win/Lose conditions: Win when meter >= 80%. On win, display: [{\"native_language\":\"Pablo smiles: 'Okay, I'll join!'\",\"target_language\":\"Pablo sonríe: '¡Está bien, me uno!'\"}] If the player uses 3 wrong attempts total, show: [{\"native_language\":\"Be polite and try again.\",\"target_language\":\"Sé cortés e inténtalo de nuevo.\"}] Animations: meter fills smoothly; speech bubbles bob gently; tiles snap with a soft pop sound cue (can be simulated with a quick scale-up).",
      "skill_points": 26,
      "lua_code": "local state = \"menu\"\nlocal sw, sh = 800, 600\nlocal t = 0\nlocal ui = {\n  start = {en=\"Start\", es=\"Iniciar\"},\n  meterLabel = {en=\"Charm Meter\", es=\"Medidor de encanto\"},\n  choose = {en=\"Choose the best request\", es=\"Elige la mejor petición\"},\n  build = {en=\"Build the sentence\", es=\"Forma la oración\"},\n  great = {en=\"Great choice!\", es=\"¡Buena elección!\"},\n  tryAgain = {en=\"Try again\", es=\"Inténtalo de nuevo\"},\n  convince = {en=\"Convince Pablo\", es=\"Convence a Pablo\"},\n  loseMsg = {en=\"Be polite and try again.\", es=\"Sé cortés e inténtalo de nuevo.\"},\n  winMsg = {en=\"Pablo smiles: 'Okay, I'll join!'\", es=\"Pablo sonríe: '¡Está bien, me uno!'\"},\n  submit = {en=\"Submit\", es=\"Enviar\"},\n  attempts = {en=\"Attempts\", es=\"Intentos\"},\n  score = {en=\"Score\", es=\"Puntuación\"}\n}\nlocal vocab = {\n  {en=\"festival\", es=\"festival\"},\n  {en=\"team\", es=\"equipo\"},\n  {en=\"to join\", es=\"unirse\"}\n}\nlocal phase1Questions = {\n  {\n    promptEN=\"Ask Pablo to join the team.\",\n    promptES=\"Pídele a Pablo que se una al equipo.\",\n    options={\n      {text=\"¿Te unirías al equipo?\", correct=true},\n      {text=\"Únete al equipo.\", correct=false},\n      {text=\"Tú te unes al equipo.\", correct=false}\n    }\n  },\n  {\n    promptEN=\"Ask politely with 'could'.\",\n    promptES=\"Pide con cortesía con 'podrías'.\",\n    options={\n      {text=\"¿Podrías unirte al equipo?\", correct=true},\n      {text=\"Puedes unirte al equipo.\", correct=false},\n      {text=\"Únete al equipo, por favor.\", correct=false}\n    }\n  }\n}\nlocal phase2Targets = {\n  {\n    targetEN=\"Would you join the team for the festival?\",\n    targetES=\"¿Te unirías al equipo para el festival?\",\n    tiles={\"¿Te\",\"unirías\",\"al\",\"equipo\",\"para\",\"el\",\"festival?\"}\n  },\n  {\n    targetEN=\"Could you join the team, please?\",\n    targetES=\"¿Podrías unirte al equipo, por favor?\",\n    tiles={\"¿Podrías\",\"unirte\",\"al\",\"equipo,\",\"por\",\"favor?\"}\n  }\n}\nlocal meter = 0\nlocal meterTarget = 0\nlocal wrongAttempts = 0\nlocal maxWrong = 3\nlocal currentQ = 1\nlocal bubbles = {}\nlocal bubbleFeedback = {text=\"\", t=0, good=false}\nlocal proceedTimer = 0\nlocal submitBtn = {x=0,y=0,w=0,h=0}\nlocal jigsaw = {\n  index = 1,\n  tiles = {},\n  slots = {},\n  allFilled = false,\n  feedback = {text=\"\", t=0, good=false}\n}\nlocal endState = nil\nlocal endCountdown = 0\nlocal startButton = {x=0,y=0,w=0,h=0}\nlocal pabloBob = 0\nlocal popScaleSpeed = 6\nlocal stoneRect = {x=0,y=0,w=0,h=0}\n\nlocal function clamp(a, lo, hi)\n  if a < lo then return lo end\n  if a > hi then return hi end\n  return a\nend\n\nlocal function lerp(a,b,tv)\n  return a + (b - a) * tv\nend\n\nlocal function pointInRect(px,py, rx,ry,rw,rh)\n  return px >= rx and px <= rx+rw and py >= ry and py <= ry+rh\nend\n\nlocal function makeBubblesForQuestion(q)\n  bubbles = {}\n  local spacing = 16\n  local baseY = stoneRect.y + stoneRect.h*0.35\n  local totalW = 0\n  local bubbleObjects = {}\n  for i,opt in ipairs(q.options) do\n    local tw,th = measureText(opt.text, 20)\n    local w = tw + 30\n    local h = th + 20\n    table.insert(bubbleObjects, {w=w,h=h,opt=opt})\n    totalW = totalW + w\n  end\n  totalW = totalW + spacing*(#bubbleObjects-1)\n  local startX = (sw - totalW)/2\n  local x = startX\n  for i,o in ipairs(bubbleObjects) do\n    local phase = random(0, math.pi*2)\n    table.insert(bubbles, {\n      x=x, y=baseY, w=o.w, h=o.h, text=o.opt.text, correct=o.opt.correct,\n      bobPhase=phase, selected=false, flashT=0, color=rgb(255,255,255)\n    })\n    x = x + o.w + spacing\n  end\nend\n\nlocal function beginPhase1()\n  state = \"phase1\"\n  currentQ = 1\n  makeBubblesForQuestion(phase1Questions[currentQ])\nend\n\nlocal function beginPhase2()\n  state = \"phase2\"\n  jigsaw.index = 1\n  jigsaw.tiles = {}\n  jigsaw.slots = {}\n  jigsaw.feedback = {text=\"\", t=0, good=false}\n  local target = phase2Targets[jigsaw.index]\n  local fontSize = 20\n  local tiles = {}\n  local spacing = 10\n  local paddX = 16\n  local paddY = 10\n  local totalW = 0\n  local widths = {}\n  local heights = {}\n  for i,word in ipairs(target.tiles) do\n    local tw,th = measureText(word, fontSize)\n    local w = tw + paddX*2\n    local h = th + paddY*2\n    widths[i]=w; heights[i]=h\n    totalW = totalW + w + (i>1 and spacing or 0)\n  end\n  local slotsY = stoneRect.y + stoneRect.h*0.30\n  local startX = (sw - totalW)/2\n  local sx = startX\n  for i,word in ipairs(target.tiles) do\n    table.insert(jigsaw.slots, {x=sx, y=slotsY, w=widths[i], h=heights[i], filled=false, correct=false, index=i})\n    sx = sx + widths[i] + spacing\n  end\n  local poolY = stoneRect.y + stoneRect.h*0.60\n  for i,word in ipairs(target.tiles) do\n    local tw,th = measureText(word, fontSize)\n    local w = tw + paddX*2\n    local h = th + paddY*2\n    local px = random(stoneRect.x + 40, stoneRect.x + stoneRect.w - w - 40)\n    local py = random(poolY, poolY + 90)\n    table.insert(tiles, {\n      text=word, x=px, y=py, w=w, h=h, baseX=px, baseY=py,\n      held=false, offx=0, offy=0, slotIndex=nil, bobPhase=random(0, math.pi*2),\n      scale=1, correctLocked=false, shakeT=0\n    })\n  end\n  jigsaw.tiles = tiles\nend\n\nlocal function proceedPhase1Or2()\n  if currentQ < #phase1Questions then\n    currentQ = currentQ + 1\n    makeBubblesForQuestion(phase1Questions[currentQ])\n  else\n    beginPhase2()\n  end\nend\n\nlocal function addMeter(delta)\n  meterTarget = clamp(meterTarget + delta, 0, 100)\nend\n\nlocal function incWrong()\n  wrongAttempts = wrongAttempts + 1\n  if wrongAttempts >= maxWrong and not endState then\n    endState = \"fail\"\n    endCountdown = 2.0\n  end\nend\n\nlocal function anyTileHeld()\n  for _,tile in ipairs(jigsaw.tiles) do\n    if tile.held then return true end\n  end\n  return false\nend\n\nlocal function slotsAllFilled()\n  for _,s in ipairs(jigsaw.slots) do\n    if not s.filled then return false end\n  end\n  return true\nend\n\nlocal function clearSlots()\n  for _,s in ipairs(jigsaw.slots) do\n    s.filled=false\n    s.correct=false\n  end\n  for _,tile in ipairs(jigsaw.tiles) do\n    tile.slotIndex=nil\n    tile.correctLocked=false\n  end\nend\n\nlocal function checkWinCondition()\n  if meterTarget >= 80 and not endState then\n    endState = \"win\"\n    endCountdown = 2.0\n  end\nend\n\nlocal function drawSpeechBubble(b, col)\n  local r = 14\n  drawRoundedRect(b.x, b.y, b.w, b.h, r, col, true)\n  local tailW, tailH = 14, 10\n  local tx1 = b.x + b.w*0.25\n  local ty1 = b.y + b.h\n  drawTriangle(tx1, ty1, tx1+tailW, ty1, tx1+tailW*0.5, ty1+tailH, col, true)\n  local tw, th = measureText(b.text, 20)\n  drawText(b.text, b.x + (b.w-tw)/2, b.y + (b.h-th)/2, rgb(30,30,30), 20)\nend\n\nlocal function drawTile(tile, colorFill, colorStroke)\n  pushTransform()\n  local cx = tile.x + tile.w/2\n  local cy = tile.y + tile.h/2\n  translate(cx, cy)\n  scale(tile.scale, tile.scale)\n  translate(-tile.w/2, -tile.h/2)\n  drawRoundedRect(0, 0, tile.w, tile.h, 10, colorFill, true)\n  drawRoundedRect(0, 0, tile.w, tile.h, 10, colorStroke, false, 2)\n  local tw, th = measureText(tile.text, 20)\n  drawText(tile.text, (tile.w - tw)/2, (tile.h - th)/2, rgb(30,30,30), 20)\n  popTransform()\nend\n\nlocal function drawSlot(slot, color)\n  drawRoundedRect(slot.x, slot.y, slot.w, slot.h, 10, color, false, 2)\nend\n\nlocal function resetTileToPool(tile)\n  local poolY = stoneRect.y + stoneRect.h*0.60\n  tile.x = random(stoneRect.x + 40, stoneRect.x + stoneRect.w - tile.w - 40)\n  tile.y = random(poolY, poolY + 90)\n  tile.baseX = tile.x\n  tile.baseY = tile.y\n  tile.slotIndex = nil\n  tile.correctLocked = false\nend\n\nlocal function handleSubmit()\n  if state ~= \"phase2\" then return end\n  if not slotsAllFilled() then return end\n  local target = phase2Targets[jigsaw.index]\n  local anyWrong = false\n  for i,slot in ipairs(jigsaw.slots) do\n    local foundTile = nil\n    for _,tile in ipairs(jigsaw.tiles) do\n      if tile.slotIndex == i then foundTile = tile break end\n    end\n    if foundTile and foundTile.text == target.tiles[i] then\n      slot.correct = true\n      foundTile.correctLocked = true\n    else\n      anyWrong = true\n      slot.correct = false\n    end\n  end\n  if anyWrong then\n    for i,slot in ipairs(jigsaw.slots) do\n      if not slot.correct then\n        slot.filled = false\n      end\n    end\n    for _,tile in ipairs(jigsaw.tiles) do\n      if not tile.correctLocked and tile.slotIndex ~= nil then\n        tile.shakeT = 0.5\n        tile.slotIndex = nil\n      end\n    end\n    jigsaw.feedback = {text=ui.tryAgain.es..\" / \"..ui.tryAgain.en, t=1.2, good=false}\n    incWrong()\n    playSound(\"bad\")\n  else\n    jigsaw.feedback = {text=ui.great.es..\" / \"..ui.great.en, t=1.2, good=true}\n    addMeter(20)\n    playSound(\"good\")\n    checkWinCondition()\n    proceedTimer = 0.9\n  end\nend\n\nfunction init()\n  randomSeed(os.time())\n  sw = getScreenWidth()\n  sh = getScreenHeight()\n  stoneRect.x = sw*0.08\n  stoneRect.w = sw*0.84\n  stoneRect.h = sh*0.70\n  stoneRect.y = sh*0.20\n  createSound(\"pop\", 880, 0.07, 0.5, \"sine\")\n  createSound(\"good\", 520, 0.12, 0.5, \"triangle\")\n  createSound(\"bad\", 180, 0.18, 0.5, \"square\")\n  startButton.w, startButton.h = 220, 56\n  startButton.x = (sw - startButton.w)/2\n  startButton.y = sh*0.62\nend\n\nfunction update(dt)\n  t = t + dt\n  pabloBob = math.sin(t*2.0)*4\n  meter = lerp(meter, meterTarget, clamp(dt*4.5, 0, 1))\n  if endState then\n    endCountdown = endCountdown - dt\n    if endCountdown <= 0 then\n      if endState == \"win\" then\n        halt(2)\n      else\n        halt(1)\n      end\n    end\n    return\n  end\n  if state == \"menu\" then\n    if isMouseJustPressed() then\n      local mx, my = getMouseX(), getMouseY()\n      if pointInRect(mx,my,startButton.x,startButton.y,startButton.w,startButton.h) then\n        beginPhase1()\n      end\n    end\n  elseif state == \"phase1\" then\n    for i,b in ipairs(bubbles) do\n      local bob = math.sin(t*2 + b.bobPhase)*6\n      b.y = stoneRect.y + stoneRect.h*0.35 + bob\n      b.flashT = math.max(0, b.flashT - dt)\n    end\n    if isMouseJustPressed() and proceedTimer <= 0 then\n      local mx, my = getMouseX(), getMouseY()\n      for i,b in ipairs(bubbles) do\n        if pointInRect(mx,my,b.x,b.y,b.w,b.h) then\n          b.selected = true\n          b.flashT = 0.6\n          if b.correct then\n            bubbleFeedback = {text=ui.great.es..\" / \"..ui.great.en, t=1.0, good=true}\n            addMeter(30)\n            playSound(\"good\")\n            proceedTimer = 0.9\n          else\n            bubbleFeedback = {text=ui.tryAgain.es..\" / \"..ui.tryAgain.en, t=1.0, good=false}\n            addMeter(-10)\n            incWrong()\n            playSound(\"bad\")\n          end\n          checkWinCondition()\n          break\n        end\n      end\n    end\n    if proceedTimer > 0 then\n      proceedTimer = proceedTimer - dt\n      if proceedTimer <= 0 then\n        proceedPhase1Or2()\n        bubbleFeedback.t = 0\n      end\n    end\n    bubbleFeedback.t = math.max(0, bubbleFeedback.t - dt)\n  elseif state == \"phase2\" then\n    if #jigsaw.tiles == 0 then\n      beginPhase2()\n    end\n    jigsaw.feedback.t = math.max(0, jigsaw.feedback.t - dt)\n    for _,tile in ipairs(jigsaw.tiles) do\n      if not tile.held and tile.slotIndex == nil then\n        local dx = math.sin(t*1.8 + tile.bobPhase)*5\n        local dy = math.cos(t*1.3 + tile.bobPhase)*3\n        tile.x = tile.baseX + dx\n        tile.y = tile.baseY + dy\n      end\n      if tile.scale > 1 then\n        tile.scale = lerp(tile.scale, 1, clamp(dt*popScaleSpeed,0,1))\n      end\n      if tile.shakeT > 0 then\n        tile.shakeT = tile.shakeT - dt\n        tile.x = tile.x + math.sin(t*40)*2\n      end\n    end\n    jigsaw.allFilled = slotsAllFilled()\n    local mx, my = getMouseX(), getMouseY()\n    if isMouseJustPressed() then\n      for i=#jigsaw.tiles,1,-1 do\n        local tile = jigsaw.tiles[i]\n        local w = tile.w * tile.scale\n        local h = tile.h * tile.scale\n        local tx = tile.x + tile.w/2 - w/2\n        local ty = tile.y + tile.h/2 - h/2\n        if pointInRect(mx,my,tx,ty,w,h) then\n          tile.held = true\n          tile.offx = mx - tile.x\n          tile.offy = my - tile.y\n          break\n        end\n      end\n    end\n    if isMouseDown() then\n      for _,tile in ipairs(jigsaw.tiles) do\n        if tile.held then\n          tile.x = mx - tile.offx\n          tile.y = my - tile.offy\n        end\n      end\n    end\n    if isMouseJustReleased() then\n      for _,tile in ipairs(jigsaw.tiles) do\n        if tile.held then\n          tile.held = false\n          local placed = false\n          local closest, ci, cd = nil, nil, 1e9\n          for i,slot in ipairs(jigsaw.slots) do\n            if not slot.filled then\n              local scx = slot.x + slot.w/2\n              local scy = slot.y + slot.h/2\n              local tcx = tile.x + tile.w/2\n              local tcy = tile.y + tile.h/2\n              local dist = math.sqrt((scx-tcx)^2 + (scy-tcy)^2)\n              if dist < cd then\n                cd = dist\n                closest = slot\n                ci = i\n              end\n            end\n          end\n          if closest and cd < math.max(closest.w, closest.h)*0.8 then\n            tile.x = closest.x\n            tile.y = closest.y\n            tile.slotIndex = ci\n            closest.filled = true\n            tile.scale = 1.15\n            playSound(\"pop\")\n            placed = true\n          else\n            if tile.slotIndex ~= nil then\n              jigsaw.slots[tile.slotIndex].filled = false\n              tile.slotIndex = nil\n            end\n          end\n        end\n      end\n    end\n    submitBtn.w, submitBtn.h = 200, 50\n    submitBtn.x = (sw - submitBtn.w)/2\n    submitBtn.y = stoneRect.y + stoneRect.h*0.45\n    if isMouseJustPressed() then\n      local mx, my = getMouseX(), getMouseY()\n      if pointInRect(mx,my,submitBtn.x,submitBtn.y,submitBtn.w,submitBtn.h) and jigsaw.allFilled and proceedTimer <= 0 then\n        handleSubmit()\n      end\n    end\n    if proceedTimer > 0 then\n      proceedTimer = proceedTimer - dt\n      if proceedTimer <= 0 then\n        if jigsaw.index < #phase2Targets then\n          jigsaw.index = jigsaw.index + 1\n          jigsaw.tiles = {}\n          jigsaw.slots = {}\n          jigsaw.feedback = {text=\"\", t=0, good=false}\n          local target = phase2Targets[jigsaw.index]\n          local fontSize = 20\n          local spacing = 10\n          local paddX = 16\n          local paddY = 10\n          local widths = {}\n          local heights = {}\n          local totalW = 0\n          for i,word in ipairs(target.tiles) do\n            local tw,th = measureText(word, fontSize)\n            local w = tw + paddX*2\n            local h = th + paddY*2\n            widths[i]=w; heights[i]=h\n            totalW = totalW + w + (i>1 and spacing or 0)\n          end\n          local slotsY = stoneRect.y + stoneRect.h*0.30\n          local startX = (sw - totalW)/2\n          local sx = startX\n          for i,word in ipairs(target.tiles) do\n            table.insert(jigsaw.slots, {x=sx, y=slotsY, w=widths[i], h=heights[i], filled=false, correct=false, index=i})\n            sx = sx + widths[i] + spacing\n          end\n          local poolY = stoneRect.y + stoneRect.h*0.60\n          for i,word in ipairs(target.tiles) do\n            local tw,th = measureText(word, fontSize)\n            local w = tw + paddX*2\n            local h = th + paddY*2\n            local px = random(stoneRect.x + 40, stoneRect.x + stoneRect.w - w - 40)\n            local py = random(poolY, poolY + 90)\n            table.insert(jigsaw.tiles, {\n              text=word, x=px, y=py, w=w, h=h, baseX=px, baseY=py,\n              held=false, offx=0, offy=0, slotIndex=nil, bobPhase=random(0, math.pi*2),\n              scale=1, correctLocked=false, shakeT=0\n            })\n          end\n        end\n      end\n    end\n  end\nend\n\nfunction draw()\n  local skyTop = rgb(200,230,255)\n  local skyBottom = rgb(170,210,245)\n  drawGradientRect(0,0,sw,sh, skyTop, skyBottom, true)\n  drawGradientRect(stoneRect.x, stoneRect.y, stoneRect.w, stoneRect.h, \"#FFF7E8\", \"#E9DFCF\", true)\n  for i=0,10 do\n    drawLine(stoneRect.x, stoneRect.y + i*(stoneRect.h/10), stoneRect.x+stoneRect.w, stoneRect.y + i*(stoneRect.h/10), rgba(150,140,120,40), 1)\n  end\n  for i=0,10 do\n    drawLine(stoneRect.x + i*(stoneRect.w/10), stoneRect.y, stoneRect.x + i*(stoneRect.w/10), stoneRect.y+stoneRect.h, rgba(150,140,120,40), 1)\n  end\n  local meterLabel = ui.meterLabel.es..\" / \"..ui.meterLabel.en\n  local mw, mh = measureText(meterLabel, 18)\n  drawText(meterLabel, 20, 16, rgb(40,40,40), 18)\n  local barX = 20\n  local barY = 40\n  local barW = sw - 40\n  local barH = 18\n  drawRoundedRect(barX, barY, barW, barH, 9, rgba(255,255,255,160), true)\n  local fillW = (meter/100) * barW\n  drawRoundedRect(barX, barY, fillW, barH, 9, rgb(80,200,120), true)\n  setBlendMode(\"add\")\n  drawRoundedRect(barX, barY, fillW, barH, 9, rgba(120,255,180,120), true)\n  setBlendMode(\"normal\")\n  local scoreStr = ui.score.es..\": \"..math.floor(meter)..\"% / \"..ui.score.en..\": \"..math.floor(meter)..\"%\"\n  drawText(scoreStr, sw-20 - measureText(scoreStr, 16), 16, rgb(40,40,40), 16)\n  local attemptsStr = ui.attempts.es..\": \"..wrongAttempts..\"/\"..maxWrong..\" / \"..ui.attempts.en..\": \"..wrongAttempts..\"/\"..maxWrong\n  drawText(attemptsStr, sw-20 - measureText(attemptsStr, 14), 36, rgb(80,60,60), 14)\n  local pX = stoneRect.x + stoneRect.w - 120\n  local pY = stoneRect.y + stoneRect.h*0.15 + pabloBob\n  drawCircle(pX, pY, 28, rgb(255,224,190), true)\n  drawCircle(pX-8, pY-5, 4, rgb(40,40,40), true)\n  drawCircle(pX+8, pY-5, 4, rgb(40,40,40), true)\n  drawArc(pX, pY+5, 12, math.pi*0.1, math.pi- math.pi*0.1, rgb(80,120,80), false, 2)\n  drawRoundedRect(pX-20, pY+28, 40, 60, 8, rgb(90,160,220), true)\n  local title = ui.convince.es..\" / \"..ui.convince.en\n  drawText(title, stoneRect.x+20, stoneRect.y-28, rgb(30,60,90), 22)\n  local chipX = stoneRect.x + 20\n  local chipY = stoneRect.y + stoneRect.h + 8\n  for i,chip in ipairs(vocab) do\n    local txt = chip.es..\" / \"..chip.en\n    local tw,th = measureText(txt, 14)\n    local w = tw + 20\n    local h = th + 10\n    drawRoundedRect(chipX, chipY, w, h, 9, rgba(255,255,255,180), true)\n    drawRoundedRect(chipX, chipY, w, h, 9, rgba(0,0,0,50), false, 1)\n    drawText(txt, chipX + 10, chipY + (h-th)/2, rgb(50,50,50), 14)\n    chipX = chipX + w + 8\n  end\n  if state == \"menu\" then\n    local tt = ui.convince.es..\" / \"..ui.convince.en\n    local prompt = \"Pablo, ¡por favor, únete! / Pablo, please join!\"\n    local tw, th = measureText(tt, 28)\n    drawText(tt, (sw - tw)/2, sh*0.26, rgb(30,60,90), 28)\n    local pw, ph = measureText(prompt, 18)\n    drawText(prompt, (sw - pw)/2, sh*0.26 + 34, rgb(60,60,60), 18)\n    drawRoundedRect(startButton.x, startButton.y, startButton.w, startButton.h, 12, rgb(90,200,120), true)\n    setBlendMode(\"add\")\n    drawRoundedRect(startButton.x, startButton.y, startButton.w, startButton.h, 12, rgba(120,255,160,100), true)\n    setBlendMode(\"normal\")\n    local st = ui.start.es..\" / \"..ui.start.en\n    local stw, sth = measureText(st, 20)\n    drawText(st, startButton.x + (startButton.w - stw)/2, startButton.y + (startButton.h-sth)/2, rgb(30,60,40), 20)\n  elseif state == \"phase1\" then\n    local q = phase1Questions[currentQ]\n    local head = ui.choose.es..\" / \"..ui.choose.en\n    local headW = measureText(head, 22)\n    drawText(head, (sw-headW)/2, stoneRect.y + 20, rgb(50,70,100), 22)\n    local pr = q.promptES..\" / \"..q.promptEN\n    local prW = measureText(pr, 18)\n    drawText(pr, (sw-prW)/2, stoneRect.y + 52, rgb(60,60,60), 18)\n    for _,b in ipairs(bubbles) do\n      local baseColor = rgba(255,255,255,220)\n      if b.flashT > 0 then\n        if b.selected and b.correct then\n          baseColor = rgb(140,240,160)\n        elseif b.selected and not b.correct then\n          baseColor = rgb(250,150,150)\n        end\n      end\n      drawSpeechBubble(b, baseColor)\n    end\n    if bubbleFeedback.t > 0 then\n      local alpha = math.floor(255 * math.min(1, bubbleFeedback.t))\n      local col = bubbleFeedback.good and rgba(50,180,100,alpha) or rgba(200,70,70,alpha)\n      local msg = bubbleFeedback.text\n      local mw2 = measureText(msg, 20)\n      drawText(msg, (sw - mw2)/2, stoneRect.y + stoneRect.h*0.55, col, 20)\n    end\n  elseif state == \"phase2\" then\n    local head = ui.build.es..\" / \"..ui.build.en\n    local headW = measureText(head, 22)\n    drawText(head, (sw-headW)/2, stoneRect.y + 20, rgb(50,70,100), 22)\n    local target = phase2Targets[jigsaw.index]\n    local pr = target.targetES..\" / \"..target.targetEN\n    local prW = measureText(pr, 18)\n    drawText(pr, (sw-prW)/2, stoneRect.y + 52, rgb(60,60,60), 18)\n    for _,slot in ipairs(jigsaw.slots) do\n      local col = rgba(60,60,60,120)\n      drawSlot(slot, col)\n    end\n    for _,tile in ipairs(jigsaw.tiles) do\n      local fill = rgba(255,255,255,230)\n      local stroke = rgba(0,0,0,60)\n      if tile.correctLocked then\n        fill = rgb(140,240,160)\n        setBlendMode(\"add\")\n        drawRadialGradient(tile.x + tile.w/2, tile.y + tile.h/2, math.max(tile.w,tile.h), rgba(120,255,160,120), rgba(120,255,160,0))\n        setBlendMode(\"normal\")\n      end\n      if tile.shakeT > 0 then\n        stroke = rgb(220,80,80)\n      end\n      drawTile(tile, fill, stroke)\n    end\n    local canSubmit = jigsaw.allFilled and proceedTimer <= 0\n    local btnCol = canSubmit and rgb(90,160,240) or rgba(120,140,160,140)\n    drawRoundedRect(submitBtn.x, submitBtn.y, submitBtn.w, submitBtn.h, 10, btnCol, true)\n    if canSubmit then\n      setBlendMode(\"add\")\n      drawRoundedRect(submitBtn.x, submitBtn.y, submitBtn.w, submitBtn.h, 10, rgba(140,200,255,90), true)\n      setBlendMode(\"normal\")\n    end\n    local st = ui.submit.es..\" / \"..ui.submit.en\n    local stw, sth = measureText(st, 18)\n    drawText(st, submitBtn.x + (submitBtn.w-stw)/2, submitBtn.y + (submitBtn.h-sth)/2, rgb(30,50,80), 18)\n    if jigsaw.feedback.t > 0 then\n      local alpha = math.floor(255 * math.min(1, jigsaw.feedback.t))\n      local col = jigsaw.feedback.good and rgba(50,180,100,alpha) or rgba(200,70,70,alpha)\n      local msg = jigsaw.feedback.text\n      local mw2 = measureText(msg, 20)\n      drawText(msg, (sw - mw2)/2, submitBtn.y + submitBtn.h + 14, col, 20)\n    end\n  end\n  if endState then\n    local overlay = rgba(0,0,0,120)\n    drawRect(0,0,sw,sh, overlay, true)\n    local msg = endState==\"win\" and (ui.winMsg.es..\" / \"..ui.winMsg.en) or (ui.loseMsg.es..\" / \"..ui.loseMsg.en)\n    local mw, mh = measureText(msg, 24)\n    local y = sh*0.42\n    setBlendMode(\"add\")\n    drawText(msg, (sw-mw)/2, y, rgba(255,255,255,220), 24)\n    setBlendMode(\"normal\")\n  end\nend",
      "id": "game_5_pablo_please_join",
      "trigger_id": "npc_6_pablo",
      "trigger_type": "npc",
      "related_quest_id": "quest_24_convince_pablo_to_join"
    }
  ],
  "_games_by_location": {},
  "_games_by_npc": {
    "npc_1_lucas": [
      "game_1_lost_apple_quick_click"
    ],
    "npc_11_maria": [
      "game_2_bread_lines_to_market"
    ],
    "npc_4_don_carlos": [
      "game_3_whispering_grove_there_is_a_se"
    ],
    "npc_7_isabella": [
      "game_4_a_flower_for_isabella_word_glo"
    ],
    "npc_6_pablo": [
      "game_5_pablo_please_join"
    ]
  },
  "_games_by_quest": {
    "quest_1_the_lost_apple": [
      "game_1_lost_apple_quick_click"
    ],
    "quest_2_bread_delivery": [
      "game_2_bread_lines_to_market"
    ],
    "quest_4_the_green_grove_mystery": [
      "game_3_whispering_grove_there_is_a_se"
    ],
    "quest_13_a_flower_for_isabella": [
      "game_4_a_flower_for_isabella_word_glo"
    ],
    "quest_24_convince_pablo_to_join": [
      "game_5_pablo_please_join"
    ]
  }
}